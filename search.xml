<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>HTML5+CSS301-day01</title>
    <url>/posts/10501.html</url>
    <content><![CDATA[<p>第一天笔记 <span id="more"></span></p>
<h1 id="html定义">HTML定义</h1>
<p>HTML超文本标记语言―—HyperText Markup Language。</p>
<ul>
<li>超文本是什么? 链接</li>
<li>标记是什么? 标记也叫标签，带尖括号的文本</li>
</ul>
<h1 id="标签语法">标签语法</h1>
<ul>
<li><p>标签成对出现，中间包裹内容</p></li>
<li><p>&lt;&gt;里面放英文字母(标签名)</p></li>
<li><p>结束标签比开始标签多/</p></li>
<li><p>拓展</p>
<ul>
<li>双标签:成对出现的标签</li>
<li>单标签:只有开始标签，没有结束标签</li>
</ul></li>
</ul>
<h1 id="基本骨架">基本骨架</h1>
<ul>
<li>html:整个网页</li>
<li>head:网页头部，用来存放给浏览器看的信息，例如CSS
<ul>
<li>title:网页标题</li>
</ul></li>
<li>body:网页主体，用来存放给用户看的信息，例如图片、文字</li>
</ul>
<h1 id="标签的关系">标签的关系</h1>
<p>作用：明确标签的书写位置;让代码格式更整齐 + 父子关系（嵌套关系) +
兄弟关系（并列关系) + *代码格式 + 父子关系：子级标签换行且缩进(Tab键) +
兄弟关系：兄弟标签换行要对齐</p>
<h1 id="注释">注释</h1>
<h1 id="排版标签标题和段落">排版标签，标题和段落</h1>
<h2 id="标题标签">标题标签</h2>
<p>一般用在新闻标题、文章标题、网页区域名称、产品名称等等。</p>
<p>标签名: h1 ~h6（双标签）</p>
<p>显示特点：</p>
<ul>
<li>文字加粗</li>
<li>字号逐渐减小</li>
<li>独占一行（换行）</li>
</ul>
<p>经验分享： - h1标签在一个网页中只能用一次 -
用来放新闻标题或网页的logo. h2~ h6没有使用次数的限制</p>
<h2 id="段落标签">段落标签</h2>
<p>一般用在新闻段落、文章段落、产品描述信息等等。</p>
<p>标签名: p（双标签）</p>
<p>显示特点：</p>
<ul>
<li>独占一行</li>
<li>段落之间存在间隙</li>
</ul>
<h1 id="换行和水平线标签">换行和水平线标签</h1>
<ul>
<li>换行标签 &lt;br&gt; （单标签）</li>
<li>水平线标签 &lt;hr&gt; （单标签）</li>
</ul>
<h1 id="文本格式化标签">文本格式化标签</h1>
<p>作用：为文本添加特殊格式，以突出重点。常见的文本格式</p>
<ul>
<li><strong>加粗</strong></li>
<li><em>倾斜</em></li>
<li><ins>
下划线
</ins></li>
<li><del>
删除线
</del></li>
<li>等等</li>
</ul>
<table>
<thead>
<tr class="header">
<th>标签名</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>&lt;strong&gt;&lt;/strong&gt;</td>
<td>加粗</td>
</tr>
<tr class="even">
<td>&lt;em&gt;&lt;/em&gt;</td>
<td>倾斜</td>
</tr>
<tr class="odd">
<td>&lt;ins&gt;&lt;/ins&gt;</td>
<td>下划线</td>
</tr>
<tr class="even">
<td>&lt;del&gt;&lt;/del&gt;</td>
<td>删除线</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th>标签名</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>b</td>
<td>加错</td>
</tr>
<tr class="even">
<td>i</td>
<td>倾斜</td>
</tr>
<tr class="odd">
<td>u</td>
<td>下划线</td>
</tr>
<tr class="even">
<td>s</td>
<td>删除线</td>
</tr>
</tbody>
</table>
<p><strong>strong、em、ins、
del标签自带强调含义（语义），一般使用这一套</strong></p>
<p><strong>两个文本格式化标签是在一行显示</strong></p>
<h1 id="图像标签">图像标签</h1>
<p>作用：在网页中插入图片。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;图片的url&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>src用于指定图像的位置和名称，是&lt;img&gt;的必须属性。</p>
<p>标签属性</p>
<table>
<thead>
<tr class="header">
<th>属性</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>alt</td>
<td>替换文本</td>
<td>图片无法显示时显示的文字</td>
</tr>
<tr class="even">
<td>title</td>
<td>提示文本</td>
<td>鼠标悬停在图片上时显示的文字</td>
</tr>
<tr class="odd">
<td>width</td>
<td>图片的宽度</td>
<td>值为数字，没有单位</td>
</tr>
<tr class="even">
<td>height</td>
<td>图片的高度</td>
<td>值为数字，没有单位</td>
</tr>
</tbody>
</table>
<ul>
<li>属性名="属性值"</li>
<li>属性写在尖括号里面，标签名后面，标签名和属性之间用空格隔开，不区分先后顺序</li>
</ul>
<h1 id="文件路径">文件路径</h1>
<p>路径分类：</p>
<ul>
<li>相对路径：从当前文件位置出发查找目标文件</li>
<li>绝对路径：从盘符出发查找目标文件</li>
</ul>
<p>相对路径写法：</p>
<ul>
<li>. 当前文件所在文件夹</li>
<li>../ 当前文件上一级文件夹</li>
<li>/ 进入某个文件夹里面</li>
</ul>
<p>绝对路径写法：</p>
<p>Windows 默认是，其他系统是/，建议统一写为/</p>
<h1 id="超链接标签">超链接标签</h1>
<p>作用：点击跳转到其他页面。</p>
<p>**注意：属性 target="_blank" 表示新窗口跳转页面**</p>
<p>经验分享：开发初期，不知道超链接的跳转地址，href属性值写#，表示空链接，不会跳转</p>
<h1 id="音频标签">音频标签</h1>
<p>常见属性</p>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 21%" />
<col style="width: 57%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">属性</th>
<th style="text-align: center;">作用</th>
<th style="text-align: center;">特殊说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">src（必须属性）</td>
<td style="text-align: center;">音频URL</td>
<td style="text-align: center;">支持格式：MP3、Ogg、Wav</td>
</tr>
<tr class="even">
<td style="text-align: center;">controls</td>
<td style="text-align: center;">展示音频控制面板</td>
<td style="text-align: center;">/</td>
</tr>
<tr class="odd">
<td style="text-align: center;">loop</td>
<td style="text-align: center;">循环播放</td>
<td style="text-align: center;">/</td>
</tr>
<tr class="even">
<td style="text-align: center;">autoplay</td>
<td style="text-align: center;">自动播放</td>
<td
style="text-align: center;">为了提升用户体验，浏览器一般会禁用自动播放</td>
</tr>
</tbody>
</table>
<p>简写：属性名和属性值一样，可以进行简写，例如</p>
<!-- 简写 -->
<audio src="音频的url" contrils loop>
</audio>
<h1 id="视频标签">视频标签</h1>
<p>常见属性</p>
<table>
<colgroup>
<col style="width: 18%" />
<col style="width: 20%" />
<col style="width: 60%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">属性</th>
<th style="text-align: center;">作用</th>
<th style="text-align: center;">特殊说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">src（必须属性）</td>
<td style="text-align: center;">视频URL</td>
<td style="text-align: center;">支持格式：MP4、WebM、Ogg</td>
</tr>
<tr class="even">
<td style="text-align: center;">controls</td>
<td style="text-align: center;">展示音频控制面板</td>
<td style="text-align: center;">/</td>
</tr>
<tr class="odd">
<td style="text-align: center;">loop</td>
<td style="text-align: center;">循环播放</td>
<td style="text-align: center;">/</td>
</tr>
<tr class="even">
<td style="text-align: center;">muted</td>
<td style="text-align: center;">静音播放</td>
<td style="text-align: center;">/</td>
</tr>
<tr class="odd">
<td style="text-align: center;">autoplay</td>
<td style="text-align: center;">自动播放</td>
<td
style="text-align: center;">为了提升用户体验，浏览器支持在静音模式下自动播放</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>HTML+CSS</category>
      </categories>
      <tags>
        <tag>HTML+CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+Butterfly主题博客搭建01</title>
    <url>/posts/10001.html</url>
    <content><![CDATA[<p>Hexo+Butterfly主题博客搭建01 ——— 个人博客搭建的基础环境配置工作
<span id="more"></span></p>
<h1 id="node.js的配置">Node.js的配置</h1>
<p><a href="https://nodejs.org/en/download">nodejs的官网</a></p>
<p>选择适合自己系统的下载即可，大部分人应该是Windows Installer (.msi)
64位，选择msi位安装程序，mac和linux用户选择适合自己的版本即可。</p>
<p>安装是一路默认选项即可，<strong>注意安装的路径可以根据自己的需求，一定要记住安装在哪里了</strong></p>
<p>安装完成之后可以在cmd中测试是否安装成功</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">npm -v</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://wang-nine.cn/images/Hexo01-01%E6%9F%A5%E7%9C%8Bnode%E6%98%AF%E5%90%A6%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F.png"
alt="Hexo01-01查看node是否安装成功" />
<figcaption
aria-hidden="true">Hexo01-01查看node是否安装成功</figcaption>
</figure>
<h1 id="git的配置">Git的配置</h1>
<p><a href="https://git-scm.com/">Git的官网</a></p>
<figure>
<img
src="https://wang-nine.cn/images/Hexo01-02Git%E5%AE%89%E8%A3%85-1.png"
alt="Hexo01-02Git安装-1" />
<figcaption aria-hidden="true">Hexo01-02Git安装-1</figcaption>
</figure>
<p>选择适合自己系统的下载即可，大部分人应该是Windows64位，所以直接点击Downloade
for Windows即可。</p>
<p>安装是一路默认选项即可，<strong>注意安装的路径可以根据自己的需求，一定要记住安装在哪里了</strong></p>
<p>安装完成之后可以在cmd中测试是否安装成功</p>
<h1 id="github的配置">github的配置</h1>
<p>在github新建一个仓库</p>
<blockquote>
<p>名称为 <strong>你的名称.github.io</strong></p>
</blockquote>
<p>如图所示为我的仓库样例：</p>
<figure>
<img
src="https://wang-nine.cn/images/Hexo01-03github%E7%9A%84%E9%85%8D%E7%BD%AE.png"
alt="Hexo01-03github的配置" />
<figcaption aria-hidden="true">Hexo01-03github的配置</figcaption>
</figure>
<h1 id="博客的初始化">博客的初始化</h1>
<h2 id="安装hexo">安装Hexo</h2>
<p>所有必备的应用程序安装完成后，即可使用<code>npm</code>安装<code>Hexo</code>。不要觉得安装这个框架有多复杂，只需要一条命令就可以了。<code>npm</code>是安装工具，<code>install</code>表示安装，<code>-g</code>表示全局安装，<code>hexo-cli</code>表示安装的是hexo框架。</p>
<p>在 git
命令行下输入下述的命令，<strong>若无法安装可能是因为权限不够，可以以管理员权限运行
gitbash</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<h2 id="初始化博客">初始化博客</h2>
<p>安装完框架之后新建一个存放博客的文件夹Blog，这里在D盘新建了一个Blog文件夹，在该文件夹下右键Git
Bash Here并输入<code>hexo init</code>命令初始化这个文件夹。注意新建 Blog
文件夹和初始化这个文件夹只需要下面这条命令就可以了。</p>
<h2 id="启动和配置博客">启动和配置博客</h2>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">hexo clean  # 清除缓存</span><br><span class="line">hexo g      # 生成静态网页</span><br><span class="line">hexo d      # 部署到Github</span><br><span class="line">hexo s 		# 是 hexo server 的缩写，启动本地服务器，用于预览主题。默认地址： http://localhost:4000/</span><br></pre></td></tr></table></figure>
<p>此时输入 <code>hexo clean</code> <code>hexo d</code>
<code>hexo h</code> <code>hexo s</code> 命令即可初步查看自己的 Blog 页面
在浏览器输入 http://localhost:4000/ 即可访问
顺利的话，在浏览器输入：<code>用户名.github.io</code>
即可初步访问自己的博客</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML5+CSS3总览</title>
    <url>/posts/10500.html</url>
    <content><![CDATA[<h1 id="html5css301-day01">HTML5+CSS301-day01</h1>
<p><a
href="https://wang-nine.cn/posts/10501.html">HTML5+CSS301-day01</a></p>
<h1 id="html5css302-day02">HTML5+CSS302-day02</h1>
<p><a
href="https://wang-nine.cn/posts/10502.html">HTML5+CSS302-day02</a></p>
<h1 id="html5css303-day03">HTML5+CSS303-day03</h1>
<p><a
href="https://wang-nine.cn/posts/10503.html">HTML5+CSS303-day02</a></p>
]]></content>
      <categories>
        <category>HTML+CSS</category>
      </categories>
      <tags>
        <tag>HTML+CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo-Butterfly主题博客搭建02</title>
    <url>/posts/10002.html</url>
    <content><![CDATA[<p>Hexo+Butterfly主题博客搭建02 ——— 下载有关butterfly主题并进行配置
<span id="more"></span></p>
<h1 id="butterfly主题的安装">Butterfly主题的安装</h1>
<ol type="1">
<li>在 hexo 项目根目录下执行操作clone主题</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>如果沒有 pug 以及 <a
href="https://so.csdn.net/so/search?q=stylus&amp;spm=1001.2101.3001.7020">stylus</a>
的渲染器，还需要下载，否则在项目运行时会报错：</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>修改项目根目录下的_config.yml文件（称为站点配置文件），开启主题</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># extensions</span><br><span class="line">## plugins: https://hexo.io/plugins/</span><br><span class="line">## themes: https://hexo.io/themes/</span><br><span class="line">#theme: landscape</span><br><span class="line">theme: butterfly</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li>升级建议</li>
</ol>
<p>为了減少升级主题带来的不便，我们还需要做以下操作： 把主题文件夹中的
_config.yml 复制到 hexo 根目录下，同重命名为 _config.butterfly.yml</p>
<p>hexo会自动合并主题中的 _config.yml 和 _config.butterfly.yml
里的配置，如果存在同名配置，会使用 _config.butterfly.yml
的配置，其优先度较高。</p>
<h1 id="butterfly主题">butterfly主题</h1>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo-Butterfly主题博客搭建03</title>
    <url>/posts/10003.html</url>
    <content><![CDATA[
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE02-Java中的文件与方法递归与IO流</title>
    <url>/posts/10102.html</url>
    <content><![CDATA[<p>详细的描述了Java中
File类的使用，一步一步剖析了IO流如何创建、如何使用以及其中的注意事项。</p>
<p>File类使用：详细的描述了使用File的对象操作文件，如:删除、获取文件信息、创建文件夹等
方法递归：详细的描述了递归算法思想并能完成常见递归题目，以及文件搜索
字符集：程序中经常要读取文件中的数据，知道数据的底层形式才能够去学习如何读写数据
IO流的作用：使用IO流完成文件数据的读写等操作
字节流与字符流：数据的类型很多，要学会选择不同的流进行读写操作
<span id="more"></span></p>
<h1 id="file">File</h1>
<p><strong>File类在包java.io.File下、代表操作系统的文件对象（文件、文件夹）。</strong>
<strong>File类提供了诸如∶定位文件，获取文件本身的信息、删除文件、创建文件（文件夹）等功能</strong>
<strong>但是不能读写文件内容。</strong></p>
<p>File类创建对象API</p>
<table>
<colgroup>
<col style="width: 44%" />
<col style="width: 55%" />
</colgroup>
<thead>
<tr class="header">
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>public File(String pathname)</td>
<td>根据文件路径创建文件对象</td>
</tr>
<tr class="even">
<td>public File(String parent, String child)</td>
<td>从父路径名字符串和子路径名字符串创建文件对象</td>
</tr>
<tr class="odd">
<td>public File(File parent, String child)</td>
<td>根据父路径对应文件对象和子路径名字符串创建文件对象</td>
</tr>
</tbody>
</table>
<h2 id="案例查询文件的大小">案例：查询文件的大小</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.创建一个FILE文件，指代某个具体的文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\test.txt&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:&quot;</span> + File.separator + <span class="string">&quot;test.txt&quot;</span>); <span class="comment">//跨平台写法，不同系统的文件分隔符不同</span></span><br><span class="line">        System.out.println(f1.length());    <span class="comment">//文件大小</span></span><br><span class="line">        System.out.println(f2.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意</p>
<ul>
<li>查询文件夹大小为文件夹大小，不包括文件夹内部内容大小。</li>
<li>File对象既可以代表文件、也可以代表文件夹。</li>
<li>File封装的对象仅仅是一个路径名，这个路径可以是存在的，也允许是不存在的。</li>
</ul>
<h2 id="file类的常用方法">FILE类的常用方法</h2>
<h3
id="file提供的判断文件类型获取文件信息功能">File提供的判断文件类型、获取文件信息功能</h3>
<table>
<colgroup>
<col style="width: 34%" />
<col style="width: 65%" />
</colgroup>
<thead>
<tr class="header">
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>public boolean exists()</td>
<td>判断当前文件对象，对应的文件路径是否存在，存在返回true</td>
</tr>
<tr class="even">
<td>public boolean isFile()</td>
<td>判断当前文件对象指代的是否是文件，是文件返回true，反之。</td>
</tr>
<tr class="odd">
<td>public boolean isDirectory()</td>
<td>判断当前文件对象指代的是否是文件夹，是文件夹返回true，反之。</td>
</tr>
<tr class="even">
<td>public string getName()</td>
<td>获取文件的名称((包含后缀)</td>
</tr>
<tr class="odd">
<td>public long length()</td>
<td>获取文件的大小，返回字节个数</td>
</tr>
<tr class="even">
<td>public long lastModified()</td>
<td>获取文件的最后修改时间。</td>
</tr>
<tr class="odd">
<td>public string getPath()</td>
<td>获取创建文件对象时，使用的路径</td>
</tr>
<tr class="even">
<td>public string getAbsolutePath()</td>
<td>获取绝对路径</td>
</tr>
</tbody>
</table>
<h3 id="file提供的创建文件删除文件">FILE提供的创建文件，删除文件</h3>
<table>
<colgroup>
<col style="width: 35%" />
<col style="width: 64%" />
</colgroup>
<thead>
<tr class="header">
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>public boolean preateNewFile()</td>
<td>创建一个新文件（文件内容为空，创建成功返回true，反之。</td>
</tr>
<tr class="even">
<td>public boolean mkdir()</td>
<td>用于创建文件夹，注意：只能创建一级文件夹</td>
</tr>
<tr class="odd">
<td>public boolean mkdirs()</td>
<td>用于创建文件夹，注意：可以创建多级文件夹</td>
</tr>
<tr class="even">
<td>public boolean delete()</td>
<td>删除文件，或者空文件，注意：不能删除非空文件夹。</td>
</tr>
</tbody>
</table>
<p><strong>注意：delete方法默认只能删除文件和空文件夹，删除后的文件不会进入回收站。</strong></p>
<h3 id="file提供的遍历文件夹">FILE提供的遍历文件夹</h3>
<table>
<colgroup>
<col style="width: 29%" />
<col style="width: 70%" />
</colgroup>
<thead>
<tr class="header">
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>public string[] list()</td>
<td>获取当前目录下所有的"一级文件名称"到一个字符串数组中去返回。</td>
</tr>
<tr class="even">
<td>public File[] listFiles()</td>
<td>获取当前目录下所有的"—级文件对象"到一个文件对象数组中去返口</td>
</tr>
</tbody>
</table>
<p><strong>使用listFiles方法时的注意事项：</strong></p>
<ul>
<li>当主调是文件，或者路径不存在时，返回null</li>
<li>当主调是空文件夹时，返回一个长度为O的数组</li>
<li><strong>当主调是一个有内容的文件夹时，将里面所有一级文件和文件夹的路径放在File数组中返回</strong></li>
<li>当主调是一个文件夹，且里面有隐藏文件时，将里面所有文件和文件夹的路径放在File数组中返回，包含隐藏文件</li>
<li>当主调是一个文件夹，但是没有权限访问该文件夹时，返回null</li>
</ul>
]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的多线程</title>
    <url>/posts/10101.html</url>
    <content><![CDATA[<p>详细的描述了Java中多线程的创建、使用、同步问题，以及线程池的创建、使用问题，详细的描述了定时器的创建和使用，详细的分析了Java中六种不同的线程转态以及转换。
<span id="more"></span></p>
<h1 id="java中的多线程创建">1.Java中的多线程创建</h1>
<p><big>
<strong>java中多线程的创建可以分为三种不同的形式：</strong></big></p>
<h2 id="继承thread类">① 继承Thread类</h2>
<p><strong>具体步骤：</strong></p>
<blockquote>
<p>1.定义一个类MyThread继承 2.创建MyThread对象
3.调用线程对象的start方法启动线程（启动后会自动执行MyThread中重写的run()方法）
具体的例子如下</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 3.new一个线程对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 4.调用start()方法执行线程</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程执行输出&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.定义一个线程类继承Thread</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2.重写run方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程执行输出&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong>
<strong>1.为什么不直接调用run方法，而是调用start启动线程</strong>
<strong>答：直接调用run方法会当成普通方法执行，此时还是相当于单线程执行。</strong>
<strong>2.为什么主线程任务放在子线程之后？</strong>
<strong>答：否则会先执行主线程任务再执行子线程任务。</strong></p>
</blockquote>
<blockquote>
<p><strong>优缺点：</strong> <strong>优点：编程简单</strong>
<strong>缺点：单继承的局限性，不能继承其他类，不便于扩展。</strong></p>
</blockquote>
<h2 id="实现runnable接口">② 实现Runnable接口</h2>
<p><strong>具体步骤：</strong></p>
<blockquote>
<p>1.定义一个线程任务类MyRunnable实现Runnable接口，重写run方法
2.创建MyRunnable对象 3.把MyRunnable对象交给Thread处理 具体的例子如下</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 2.创建MyRunnable对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 3.把MyRunnable对象交给Thread处理</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(target);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程执行输出&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.定义一个线程任务类MyRunnable实现Runnable接口，重写run方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程执行输出&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>优缺点： 优点：扩展性强，可以继续继承和实现。
缺点：如果线程有执行结果不能直接返回。</p>
</blockquote>
<blockquote>
<p>注意：也可通过匿名内部类实现（建议的写法）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过匿名内部类来实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;匿名内部类子线程的输出&quot;</span> + i);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>
<h2 id="实现callable接口通过futuretask接口接收返回值jdk5新增">③
实现Callable接口，通过FutureTask接口接收返回值（JDK5新增）</h2>
<blockquote>
<p>1.得到任务对象
第一步：定义一个线程任务类MyCallable实现Callable接口，重写call方法，该方法可以返回结果
第二步：用Future吧Callable对象封装成线程任务对象
2.把线程任务对象交给Thread处理 3.调用Thread的start方法启动任务
4.线程执行完毕后，通过FutureTask的get方法获得结果</p>
</blockquote>
<p>具体的例子如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 3.创建任务对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Callable&lt;String&gt; call1 = <span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 4.把Callable任务对象交给FutureTask对象</span></span><br><span class="line"><span class="comment">         * FutureTask的作用1：FutureTask实现了Runnable接口，此时就可以交给Thread了</span></span><br><span class="line"><span class="comment">         * FutureTask的作用2：可以在线程执行完毕后调用get方法得到线程执行的结果</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//Thread t = new Thread(call);  报错，Thread不能接收call对象</span></span><br><span class="line">        FutureTask&lt;String&gt; f1 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(call1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 5.交给线程处理</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(f1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 6.启动线程</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Callable&lt;String&gt; call2 = <span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">200</span>);</span><br><span class="line">        FutureTask&lt;String&gt; f2 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(call2);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(f2);</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">rs1</span> <span class="operator">=</span> f1.get();   <span class="comment">//直接调用call方法，可能还没有执行完，使用get时若发现线程未执行完会先等线程执行完毕</span></span><br><span class="line">            System.out.println(<span class="string">&quot;第一个结果为：&quot;</span> + rs1);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">rs2</span> <span class="operator">=</span> f2.get();   <span class="comment">//直接调用call方法，可能还没有执行完，使用get时若发现线程未执行完会先等线程执行完毕</span></span><br><span class="line">            System.out.println(<span class="string">&quot;第二个结果为：&quot;</span> + rs2);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.定义一个实现类，实现Callable接口，记得声明结果的数据类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2.重写call方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyCallable</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;子线程执行的结果是&quot;</span> + sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>优缺点： 优点：扩展性强，可以继续继承和实现。
可以在线程执行完毕后获取线程执行的结果。 缺点：编程较为复杂。</p>
</blockquote>
<blockquote>
<p>注意：Callable 与 FutureTask 创建对象时都需要声明类型</p>
</blockquote>
<h1 id="java中的多线程常用方法">2.Java中的多线程常用方法</h1>
<h2 id="线程名称有关的方法">① 线程名称有关的方法</h2>
<table>
<thead>
<tr class="header">
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>void setName()</td>
<td>设置线程名称</td>
</tr>
<tr class="even">
<td>String getName(String name)</td>
<td>获得线程名称</td>
</tr>
<tr class="odd">
<td>CuurentThread()</td>
<td>获取当前的线程对象，哪个线程执行，拿到哪个线程对象</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th>也可在构造器中取名</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>public Thread(String name)</td>
</tr>
<tr class="even">
<td>public Thread(Runnable target)</td>
</tr>
<tr class="odd">
<td>public Thread(Runnable target, String name)</td>
</tr>
</tbody>
</table>
<h2 id="线程休眠有关的方法">② 线程休眠有关的方法</h2>
<table>
<thead>
<tr class="header">
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>sleep(long time)</td>
<td>单位为ms</td>
</tr>
</tbody>
</table>
<p>具体的例子如下 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;一号线程&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"><span class="comment">//        t1.setName(&quot;一号线程&quot;);</span></span><br><span class="line">        System.out.println(t1.getName());</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;二号线程&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line"><span class="comment">//        t2.setName(&quot;二号线程&quot;);</span></span><br><span class="line">        System.out.println(t2.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//哪个线程执行，拿到哪个线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">m</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        System.out.println(m.getName());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Main线程输出&quot;</span> + i);</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">3</span>)</span><br><span class="line">                Thread.sleep(<span class="number">3</span> * <span class="number">1000</span>); <span class="comment">//主线程休眠3000ms</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>线程的子类，自定义的线程MyThread <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="comment">//让父类的构造器进行构造</span></span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;输出&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="java中的线程安全问题">3.Java中的线程安全问题</h1>
<h2 id="问题描述">问题描述</h2>
<p><strong><big>多个线程同时操作一个共享资源可能会出现业务安全问题，称为线程安全问题</big></strong></p>
<p>例如小明和小红有一个共同账户，余额为10万元，模拟两人同时取钱10万元
基础的定义代码如下：</p>
<p><strong>①
提供一个账户类，创建一个账户对象代表两个人的共享账户</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String cardId;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money;   <span class="comment">//余额</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(String cardId, <span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cardId = cardId;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">DrawMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName(); <span class="comment">//获取取钱人的姓名</span></span><br><span class="line">        <span class="comment">//1.判断账户中的钱是否足够</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.money &gt;= money) &#123;</span><br><span class="line">            <span class="comment">//2.取钱</span></span><br><span class="line">            System.out.println(name + <span class="string">&quot;来取钱成功，吐出：&quot;</span> + money);</span><br><span class="line">            <span class="comment">//3.更新余额</span></span><br><span class="line">            <span class="built_in">this</span>.money -= money;</span><br><span class="line">            System.out.println(<span class="string">&quot;取钱后剩余：&quot;</span> + <span class="built_in">this</span>.money);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//4.余额不足</span></span><br><span class="line">            System.out.println(name + <span class="string">&quot;来取钱，余额不足！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> cardId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCardId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cardId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cardId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCardId</span><span class="params">(String cardId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cardId = cardId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> money</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Account&#123;cardId = &quot;</span> + cardId + <span class="string">&quot;, money = &quot;</span> + money + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>② 定义一个线程类，用来处理账户对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 取钱的线程类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DrawThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Account acc;    <span class="comment">//定义一个账户对象，便于对账户对象进行操作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DrawThread</span><span class="params">(Account acc, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.acc = acc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        acc.DrawMoney(<span class="number">100000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>③ 创建两个线程对象，传入同一个账户对象</strong></p>
<p><strong>④ 启动两个线程，去同一个账户对象中取钱10万</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟取钱案例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1.定义线程类，创建一个共享的账户对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Account</span> <span class="variable">acc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>(<span class="string">&quot;ICBC-999&quot;</span>, <span class="number">100000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 2.创建两个线程对象，代表小明和小红同时取钱</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DrawThread</span>(acc, <span class="string">&quot;小明&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DrawThread</span>(acc, <span class="string">&quot;小红&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意会出现下面的错误样例：</p>
<figure>
<img
src="https://wang-nine.cn/images/JavaSE01-01%E9%94%99%E8%AF%AF%E6%A0%B7%E4%BE%8B.png"
alt="JavaSE01-01错误样例" />
<figcaption aria-hidden="true">JavaSE01-01错误样例</figcaption>
</figure>
<h2 id="解决方法线程同步">解决方法：线程同步</h2>
<p><strong>针对上述错误解决线程安全问题：线程同步（同一个时刻仅有一个线程可以访问共享资源）</strong></p>
<h3 id="同步代码块">① 同步代码块</h3>
<p>synchorized(同步锁对象) { 操作共享资源的代码（核心代码） }</p>
<blockquote>
<p><strong>注意：同步锁对象对于不同的对象来说唯一即可，同一时间只能被一个人占用，因此可以使用字符串为同步锁对象，字符串在常量池中</strong>
<strong>注意：上述同步锁对象对于小明小红唯一，但是若有小黑小白另一家庭取钱，此时也会等待，此时会出问题。</strong>
<strong>锁对象使用任意的唯一对象可以吗？</strong>
<strong>答：不可以，会影响其他无关线程的执行。</strong>
<strong>锁对象的规范要求：使用共享资源作为锁对象</strong>
<strong>因此：对于实例方法：使用this作为锁对象</strong>
<strong>对于静态方法：使用字节码（类名.class)作为锁对象</strong></p>
</blockquote>
<p>实例代码如下(修改了上述的代码之后，结果正确)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">DrawMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName(); <span class="comment">//获取取钱人的姓名</span></span><br><span class="line">    <span class="comment">//同步代码块</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="comment">//1.判断账户中的钱是否足够</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.money &gt;= money) &#123;</span><br><span class="line">            <span class="comment">//2.取钱</span></span><br><span class="line">            System.out.println(name + <span class="string">&quot;来取钱成功，吐出：&quot;</span> + money);</span><br><span class="line">            <span class="comment">//3.更新余额</span></span><br><span class="line">            <span class="built_in">this</span>.money -= money;</span><br><span class="line">            System.out.println(<span class="string">&quot;取钱后剩余：&quot;</span> + <span class="built_in">this</span>.money);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//4.余额不足</span></span><br><span class="line">            System.out.println(name + <span class="string">&quot;来取钱，余额不足！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure>
<img
src="https://wang-nine.cn/images/JavaSE01-02%E6%AD%A3%E7%A1%AE%E6%A0%B7%E4%BE%8B.png"
alt="JavaSE02-正确样例" />
<figcaption aria-hidden="true">JavaSE02-正确样例</figcaption>
</figure>
<h3 id="同步方法">② 同步方法</h3>
<p>修饰符 synchorized 返回值类型 方法名称(形参列表) {
操作共享资源的代码（核心代码） }</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">DrawMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;     <span class="comment">//同步方法</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName(); <span class="comment">//获取取钱人的姓名</span></span><br><span class="line">    <span class="comment">//1.判断账户中的钱是否足够</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.money &gt;= money) &#123;</span><br><span class="line">        <span class="comment">//2.取钱</span></span><br><span class="line">        System.out.println(name + <span class="string">&quot;来取钱成功，吐出：&quot;</span> + money);</span><br><span class="line">        <span class="comment">//3.更新余额</span></span><br><span class="line">        <span class="built_in">this</span>.money -= money;</span><br><span class="line">        System.out.println(<span class="string">&quot;取钱后剩余：&quot;</span> + <span class="built_in">this</span>.money);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//4.余额不足</span></span><br><span class="line">        System.out.println(name + <span class="string">&quot;来取钱，余额不足！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：同步方法底层也有锁对象，为隐式锁对象，锁的范围是整个方法代码</strong>
<strong>如果方法是实例方法，会用this作为同步锁对象</strong>
<strong>如果方法是静态方法，会用类名.class作为同步锁对象</strong></p>
</blockquote>
<blockquote>
<p><strong>注意，上述两种方法中，同步代码块性能较好，范围越小性能越好，相当于一个在厕所外面排队，一个在坑外面排队，但是同步方法更好些更直观，在实际应用中多数使用同步方法</strong></p>
</blockquote>
<h3 id="同步锁jdk5后提供了新的锁对象lock更加的灵活方便">③
同步锁（JDK5后提供了新的锁对象Lock，更加的灵活方便）</h3>
<p><strong>Lock是接口，采用实现类ReentrantLock来构建Lock锁对象</strong></p>
<p><strong>常用api如下</strong></p>
<table>
<thead>
<tr class="header">
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>public ReentrantLock()</td>
<td>获得Lock锁的实现类对象</td>
</tr>
<tr class="even">
<td>void lock()</td>
<td>获得锁</td>
</tr>
<tr class="odd">
<td>void unlock()</td>
<td>释放锁</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用final修饰，锁对象是唯一且不可替换的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">DrawMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;     <span class="comment">//同步方法</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName(); <span class="comment">//获取取钱人的姓名</span></span><br><span class="line">    <span class="comment">//1.判断账户中的钱是否足够</span></span><br><span class="line">    lock.lock();    <span class="comment">//上锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.money &gt;= money) &#123;</span><br><span class="line">            <span class="comment">//2.取钱</span></span><br><span class="line">            System.out.println(name + <span class="string">&quot;来取钱成功，吐出：&quot;</span> + money);</span><br><span class="line">            <span class="comment">//3.更新余额</span></span><br><span class="line">            <span class="built_in">this</span>.money -= money;</span><br><span class="line">            System.out.println(<span class="string">&quot;取钱后剩余：&quot;</span> + <span class="built_in">this</span>.money);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//4.余额不足</span></span><br><span class="line">            System.out.println(name + <span class="string">&quot;来取钱，余额不足！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();  <span class="comment">//解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：一、锁对象声明为final代表锁是唯一且不可替换的</strong>
<strong>二、unlock放在finally中，防止代码出错而不执行unlock导致程序卡死</strong></p>
<h1
id="java中的多线程通信综合以上内容的综合样例">4.Java中的多线程通信（综合以上内容的综合样例）</h1>
<p><big>常用的模型：生产者与消费者模型</big></p>
<p><strong>object中提供的等待唤醒方法如下</strong> |方法名称|说明|
|---|---| |void
wait()|当前线程等待并且释放所占锁，直到另外一个线程调用notify()或者notifyaAll|
|void notify()|唤醒正在等待的单个线程| |void
notufyAll()|唤醒正在等待的所有线程|</p>
<blockquote>
<p><strong>上述方法应该使用当前同步锁对象调用</strong>
<strong>注意：一定是先唤醒别人在等待，相当于自己叫醒别人再晕过去，否则相当于自己先晕过去没法叫人。</strong></p>
</blockquote>
<p>实例代码如下 <strong>账户类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String cardId;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money;   <span class="comment">//余额</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(String cardId, <span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cardId = cardId;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 小红 小明：取钱</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">DrawMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName(); <span class="comment">//取钱人</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.money &gt;= money) &#123;</span><br><span class="line">                <span class="comment">// 钱够，可以取钱</span></span><br><span class="line">                <span class="built_in">this</span>.money -= money;</span><br><span class="line">                System.out.println(name + <span class="string">&quot;取钱成功，取出&quot;</span> + money + <span class="string">&quot;元！余额是：&quot;</span> + <span class="built_in">this</span>.money);</span><br><span class="line">                <span class="comment">// 没钱了</span></span><br><span class="line">                <span class="comment">// 钱不够</span></span><br><span class="line">                <span class="built_in">this</span>.notifyAll();   <span class="comment">//唤醒其他所有的线程</span></span><br><span class="line">                <span class="built_in">this</span>.wait();    <span class="comment">//锁对象，让当前线程进入等待</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 钱不够，不可取</span></span><br><span class="line">                <span class="comment">// 唤醒别人存钱，等待自己取钱</span></span><br><span class="line">                <span class="built_in">this</span>.notifyAll();   <span class="comment">//唤醒其他所有的线程</span></span><br><span class="line">                <span class="built_in">this</span>.wait();    <span class="comment">//锁对象，让当前线程进入等待</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 亲爹 干爹 岳父：取钱</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">depositMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName(); <span class="comment">//存钱人</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.money == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//没钱了，存钱</span></span><br><span class="line">                <span class="built_in">this</span>.money += money;</span><br><span class="line">                System.out.println(name + <span class="string">&quot;存钱&quot;</span> + money + <span class="string">&quot;元成功，余额为&quot;</span> + <span class="built_in">this</span>.money + <span class="string">&quot;元！&quot;</span>);</span><br><span class="line">                <span class="comment">// 存完钱了</span></span><br><span class="line">                <span class="built_in">this</span>.notifyAll();   <span class="comment">//唤醒其他所有的线程</span></span><br><span class="line">                <span class="built_in">this</span>.wait();    <span class="comment">//锁对象，让当前线程进入等待</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 有钱了，不用存钱</span></span><br><span class="line">                <span class="built_in">this</span>.notifyAll();   <span class="comment">//唤醒其他所有的线程</span></span><br><span class="line">                <span class="built_in">this</span>.wait();    <span class="comment">//锁对象，让当前线程进入等待</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCardId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cardId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCardId</span><span class="params">(String cardId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cardId = cardId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>取钱线程类：</strong> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 取钱的线程类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DrawThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Account acc;    <span class="comment">//定义一个账户对象，便于对账户对象进行操作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DrawThread</span><span class="params">(Account acc, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.acc = acc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//不断的存取前</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            acc.DrawMoney(<span class="number">100000</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3</span> * <span class="number">1000</span>);     <span class="comment">//每隔三秒取一次钱</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>存钱线程类：</strong> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 取钱的线程类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DepositThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Account acc;    <span class="comment">//定义一个账户对象，便于对账户对象进行操作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DepositThread</span><span class="params">(Account acc, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.acc = acc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//不断的存取前</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            acc.depositMoney(<span class="number">100000</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2</span> * <span class="number">1000</span>);     <span class="comment">//每隔两秒存一次钱</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>主程序：</strong> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 三个父亲线程（生产者） 两个孩子线程（消费者） 模拟存取钱通信思想（一存 一取）</span></span><br><span class="line">        <span class="comment">// 1.创建账户对象，代表五个人共同操作的账户</span></span><br><span class="line">        <span class="type">Account</span> <span class="variable">acc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>(<span class="string">&quot;ICBC-999&quot;</span>, <span class="number">0</span>);   <span class="comment">//初始化零元</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.创建两个取钱线程 小明 小红</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DrawThread</span>(acc, <span class="string">&quot;小明&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DrawThread</span>(acc, <span class="string">&quot;小红&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.创建三个存钱线程 亲爹 干爹 岳父</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DepositThread</span>(acc, <span class="string">&quot;亲爹&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DepositThread</span>(acc, <span class="string">&quot;干爹&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DepositThread</span>(acc, <span class="string">&quot;岳父&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果</p>
<figure>
<img
src="https://wang-nine.cn/images/JavaSE01-03%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%A0%B7%E4%BE%8B.png"
alt="JavaSE01-03线程通信样例" />
<figcaption aria-hidden="true">JavaSE01-03线程通信样例</figcaption>
</figure>
<h1 id="线程池的创建以及使用">5.线程池的创建以及使用</h1>
<p><strong>线程池是一个可以复用线程的技术。解决了每次都为新请求创建线程，导致开销较大的问题</strong>
JDK5.0起提供了代表线程池的接口：ExecutorService
得到线程池对象的两种办法：
一、使用ExecutorService的实现类ThreadPoolExecutor自己创建一个线程池对象。
二、使用Executors（线程池的工具类）调用方法放回不同特点的线程池对象。</p>
<h2 id="线程池的api简介"><small>① 线程池的API简介</small></h2>
<p>ThreadPoolExecutor构造器： public ThreadPoolExecutor（int
corePoolSize int maximumPoolSize, long keepAliveTIme, TimeUnit unit,
BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory,
RejectedExecutionHandler handler)
参数一：指定线程池的线程数量（核心线程）：corePoolsize -----&gt;
不能小于0 参数二：指定线程池可支持的最大线程数：maximumPoolSize
------&gt; 最大数量&gt;=核心线程数量
参数三：指定临时线程的最大存活时间：keepAliveTime ------&gt; 不能小于0
参数四：存活时间的单位（秒，分，时，天）：unit ------&gt; 时间单位
参数五：指定任务队列：workQueue ------&gt; 不能为null
参数六：指定用那个线程工厂创建线程：threadFactory ------&gt; 不能为null
参数七：指定线程忙，任务慢的时候，新任务来了怎么办，即拒绝策略：handler
------&gt; 不能为null</p>
<blockquote>
<p><strong>（重要！！！）注意两点：</strong>
<strong>临时线程什么时候创建：新任务提交时发现核心线程都在忙，任务队列满，还可以创建临时线程时才会创建。</strong>
<strong>什么时候开始拒绝任务：核心线程和临时线程都在忙，任务队列都满，新任务过来会拒绝。</strong></p>
</blockquote>
<p>ExecutorService的常用方法： |方法名称|说明| |---|---| |void
execute(Runable command)|执行任务，无返回值，一般用于执行Runnable任务|
|Future<T> submit(Callable<T>
Task|执行任务，返回未来任务对象获取线程结果，一般用于执行Runnable任务|
|void shutdown()|等待任务执行完毕后关闭线程池| |List<Runnable>
shutdownNow()|立即关闭，停止正在执行的任务，返回队列中未执行的任务|</p>
<p>拒绝策略：</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>策略</th>
<th>详解</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ThreadPoolExecutor.AbortPolicy</td>
<td>丢弃任务抛出RejectedExecutionException异常</td>
</tr>
<tr class="even">
<td>ThreadPoolExecutor.DiscardPolicy</td>
<td>丢弃任务不抛出异常（不推荐）</td>
</tr>
<tr class="odd">
<td>ThreadPoolExecutor.DiscardOldestPolicy</td>
<td>抛弃等待最久的任务并把当前任务加入队列</td>
</tr>
<tr class="even">
<td>ThreadPoolExecutor.CallerRunsPolicy</td>
<td>由主线程负责调用的run()方法绕过线程池直接执行，即来新任务主线程亲自服务</td>
</tr>
</tbody>
</table>
<h2 id="线程池处理runnable任务"><small>②
线程池处理Runnable任务</small></h2>
<p>样例代码： Runnable实现代码： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;输出了：HelloWorld&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 睡眠线程，观察线程的执行情况</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;本任务与线程绑定了，进入休眠状态了~~~&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);  <span class="comment">//让其睡眠时间久一点，便于观察线程池的复用情况</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>线程池创建代码： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">threadPoolDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.创建线程池对象</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *     public ThreadPoolExecutor(int corePoolSize,</span></span><br><span class="line"><span class="comment">         *                               int maximumPoolSize,</span></span><br><span class="line"><span class="comment">         *                               long keepAliveTime,</span></span><br><span class="line"><span class="comment">         *                               TimeUnit unit,</span></span><br><span class="line"><span class="comment">         *                               BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="comment">         *                               ThreadFactory threadFactory,</span></span><br><span class="line"><span class="comment">         *                               RejectedExecutionHandler handler) &#123;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>,</span><br><span class="line">                TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">5</span>), Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.把任务给线程池处理</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        <span class="comment">//核心线程运行</span></span><br><span class="line">        pool.execute(target);</span><br><span class="line">        pool.execute(target);</span><br><span class="line">        pool.execute(target);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不创建临时线程</span></span><br><span class="line">        pool.execute(target);</span><br><span class="line">        pool.execute(target);</span><br><span class="line">        pool.execute(target);</span><br><span class="line">        pool.execute(target);</span><br><span class="line">        pool.execute(target);       <span class="comment">//任务队列满了！！核心线程都忙！！</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建临时线程</span></span><br><span class="line">        pool.execute(target);</span><br><span class="line">        pool.execute(target);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拒绝策略触发</span></span><br><span class="line">        pool.execute(target);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭线程池（开发一般不使用，线程池作用就是长久存活）</span></span><br><span class="line">        <span class="comment">//pool.shutdownNow();     //立即关闭，即使任务未完成也关闭</span></span><br><span class="line">        <span class="comment">//pool.shutdown();    //等待任务执行完毕再关闭</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>拒绝策略样例： <img
src="https://wang-nine.cn/images/JavaSE01-04%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5%E6%A0%B7%E4%BE%8B.png"
alt="JavaSE01-04线程池拒绝策略样例" /></p>
<p>线程池运行样例： <img
src="https://wang-nine.cn/images/JavaSE01-05Runnable%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%BF%90%E8%A1%8C%E6%A0%B7%E4%BE%8B.png"
alt="JavaSE01-05Runnable线程池运行样例" /></p>
<h2 id="线程池处理callable任务"><small>③
线程池处理Callable任务</small></h2>
<p>样例代码（简单测试一下，Callable实现在上面写过，具体使用方式与Runnable一致）：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">threadPoolDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.创建线程池对象</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *     public ThreadPoolExecutor(int corePoolSize,</span></span><br><span class="line"><span class="comment">         *                               int maximumPoolSize,</span></span><br><span class="line"><span class="comment">         *                               long keepAliveTime,</span></span><br><span class="line"><span class="comment">         *                               TimeUnit unit,</span></span><br><span class="line"><span class="comment">         *                               BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="comment">         *                               ThreadFactory threadFactory,</span></span><br><span class="line"><span class="comment">         *                               RejectedExecutionHandler handler) &#123;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>,</span><br><span class="line">                TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">5</span>), Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.把任务给线程池处理</span></span><br><span class="line">        Future&lt;String&gt; f1 = pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">100</span>));</span><br><span class="line">        Future&lt;String&gt; f2 = pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">200</span>));</span><br><span class="line">        Future&lt;String&gt; f3 = pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">300</span>));</span><br><span class="line">        Future&lt;String&gt; f4 = pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">400</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(f1.get());</span><br><span class="line">        System.out.println(f2.get());</span><br><span class="line">        System.out.println(f3.get());</span><br><span class="line">        System.out.println(f4.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>线程池运行样例： <img
src="https://wang-nine.cn/images/JavaSE01-06Callable%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%BF%90%E8%A1%8C%E6%A0%B7%E4%BE%8B.png"
alt="JavaSE01-06Callable线程池运行样例" /></p>
<h2 id="重要-executors工具类实现线程池"><small>④ （重要！）
Executors工具类实现线程池</small></h2>
<p>Executors获得线程池的常用方法： |方法名称|说明| |:--|---| |public
static ExecutorService
newCachedThreadPool()|线程数随着任务增加而增加，若线程任务执行完毕且空闲一段时间会被回收|
|public static ExecutorService
newFixedThreadPool()|创建固定数量的线程池。若某个线程因为异常而结束，那么线程池会补充一个新线程代替它|
|public static ExecutorService
newSingleThreadExecutor()|创建只有一个线程对象的线程池对象，如果该线程因为异常而结束，那么线程池会补充一个新线程|
|public static ScheduledExecutorService newScheduledThreadPool(int
PoolSize)|创建一个线程池，可以实现在给定的延迟后运行任务，或者定期执行任务|</p>
<blockquote>
<p><strong>注意：Executors的底层其实也是基于线程池的实现类ThreadPoolExecutor创建线程池对象</strong>
<strong>注意：大型并发环境使用Executors如果不注意可能会出现系统风险，例如阿里开发手册不建议使用Executors创建线程池对象，而是建
议使用ThreadPoolExecutor自己创建</strong></p>
</blockquote>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">方法名称</th>
<th>存在问题</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">public static ExecutorService
newCachedThreadPool()</td>
<td>允许请求的任务队列长度为Integer.MAX_VALUE，可能出现OOM错误(OutOfMemoryError)</td>
</tr>
<tr class="even">
<td style="text-align: left;">public static ExecutorService
newFixedThreadPool()</td>
<td>同上</td>
</tr>
<tr class="odd">
<td style="text-align: left;">public static ExecutorService
newSingleThreadExecutor()</td>
<td>创建的线程数量上限为Integer.MAX_VALUE，线程数随着任务1:1增长，可能出现OOM错误(OutOfMemoryError)</td>
</tr>
<tr class="even">
<td style="text-align: left;">public static ScheduledExecutorService
newScheduledThreadPool(int PoolSize)</td>
<td>同上</td>
</tr>
</tbody>
</table>
<h1 id="补充知识">6.补充知识</h1>
<h2 id="定时器"><small>① 定时器</small></h2>
<blockquote>
<p>定时器是一种控制任务延时调用，或者周期调用的技术
<strong>作用：闹钟，定时邮件发送</strong></p>
</blockquote>
<p><big><strong>定时器的两种实现方式如下</strong></big></p>
<h3 id="timer">Timer</h3>
<table>
<thead>
<tr class="header">
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>public Timer()</td>
<td>创建Timer定时器对象</td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>public void schedule(TimerTask task, long delay, long period）</td>
<td>开启一个定时器，按照计划处理TimerTask任务，delay是延时，period是周期</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意：TimerTask是Runnable的实现类</strong></p>
</blockquote>
<blockquote>
<p><strong>存在的问题：</strong>
<strong>Timer是单线程，处理多个任务有序执行，存在演示与设置定时器的时间有出入</strong>
<strong>可能因为某个任务的异常使得Timer线程死掉，从而影响后续任务的执行</strong></p>
</blockquote>
<p>样例代码如下： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Timer;</span><br><span class="line"><span class="keyword">import</span> java.util.TimerTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimerDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.创建Timer定时器</span></span><br><span class="line">        <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();  <span class="comment">//本身就是一个单线程</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.调用方法，给定定时任务</span></span><br><span class="line">        timer.schedule(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行任务A~~~&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>); <span class="comment">//休眠5s</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>, <span class="number">2000</span>); <span class="comment">//三秒后执行，每隔两秒执行一次</span></span><br><span class="line"></span><br><span class="line">        timer.schedule(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行任务B~~~&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>, <span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意，本来A应该7s一次（2s间隔 + 5s睡眠），B应该2s一次</span></span><br><span class="line">        <span class="comment">// 实际情况与上述不符合，只存在一个线程，</span></span><br><span class="line">        <span class="comment">// B任务受到了A任务的影响</span></span><br><span class="line">        <span class="comment">// 其次，如果中间某个线程异常，其余线程都死亡</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行样例如下: <img
src="https://wang-nine.cn/images/JavaSE01-06Timer%E6%A0%B7%E4%BE%8B.png"
alt="JavaSE01-06Timer样例" /></p>
<h3 id="scheduledexecutorservice">ScheduledExecutorService</h3>
<blockquote>
<p><strong>ScheduledExecutorService弥补了Timer的缺陷</strong></p>
</blockquote>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>Executors的方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>public static ScheduledExecutorService newScheduledThreadPool(int
PoolSize</td>
<td>得到线程池对象</td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>ScheduledExecutorService的方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>public Scheduled&lt;?&gt; scheduleAtFixedRate(Runnable command, long
initialDelay, long period, TimeUnit unit)</td>
<td>周期调度方法</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>优点：基于线程池，某个任务的执行情况不会影响其他任务的执行</strong></p>
</blockquote>
<p>样例代码如下： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.TimerTask;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimerDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.创建ScheduledExecutorService线程池对象</span></span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.开启定时任务</span></span><br><span class="line">        pool.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行任务A~~~&quot;</span>);</span><br><span class="line">                <span class="comment">//把该线程堵塞</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        pool.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行任务B~~~&quot;</span>);</span><br><span class="line">                System.out.println(<span class="number">10</span> / <span class="number">0</span>); <span class="comment">//使该线程异常</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        pool.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行任务C~~~&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行样例如下： <img
src="https://wang-nine.cn/images/JavaSE01-07ScheduledExecutorService%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A0%B7%E4%BE%8B.png"
alt="JavaSE01-07ScheduledExecutorService线程池样例" /></p>
<blockquote>
<p><strong>异常不会影响</strong>
<strong>也不受其他任务的影响</strong></p>
</blockquote>
<h2 id="并发与并行"><small>② 并发与并行</small></h2>
<blockquote>
<p><strong>并发与并行：</strong>
<strong>正在运行的程序（软件）就是一个独立的进程，线程是属于进程的，多个线程其实是并发与并行同时进行的。</strong></p>
</blockquote>
<blockquote>
<p><strong>并发的理解：</strong>
<strong>CPU同时处理线程的数量有限。</strong>
<strong>CPU会轮询为系统的每个线程服务，由于CPU切换的速度很快，给我们的感觉这些线程在同时执行，这就是并发。</strong></p>
</blockquote>
<blockquote>
<p><strong>并行的理解：</strong>
<strong>在同一个时刻上，同时有多个线程在被CPU处理并执行。</strong></p>
</blockquote>
<h2 id="重点线程的生命周期"><small>③
（重点！！！）线程的生命周期</small></h2>
<blockquote>
<p><strong>线程的状态:</strong>
<strong>也就是线程从生到死的过程，以及中间经历的各种状态及状态转换。理解线程的状态有利于提升并发编程的理解能力。</strong></p>
</blockquote>
<blockquote>
<p><strong>Java线程的状态：</strong>
<strong>Java总共定义了6种状态</strong>
<strong>6种状态都定义在Thread类的内部枚举类中。</strong></p>
</blockquote>
<p><strong>线程6种状态的转换如下图</strong></p>
<figure>
<img
src="https://wang-nine.cn/images/JavaSE01-08%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2.png"
alt="JavaSE01-08线程状态之间的转换" />
<figcaption
aria-hidden="true">JavaSE01-08线程状态之间的转换</figcaption>
</figure>
<blockquote>
<p><strong>注意以下几点：</strong>
<strong>sleep()是睡眠，过程中不会释放锁对象，醒来后直接进入可运行状态</strong>
<strong>wait()是等待，过程中会释放锁对象，但是时间到了或者被notity时会重新获得锁对象，进入可运行状态</strong></p>
</blockquote>
<p><big><strong>总结：</strong></big></p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>线程状态</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>NEW（新建）</strong></td>
<td><strong>线程刚被创建，但是并未启动。</strong></td>
</tr>
<tr class="even">
<td><strong>Runnable（可运行）</strong></td>
<td><strong>线程已经调用了start()等待CPU调度</strong></td>
</tr>
<tr class="odd">
<td><strong>Blocked（锁阻塞）</strong></td>
<td><strong>线程在执行的时候未竞争到锁对象，则该线程进入Blocked状态</strong></td>
</tr>
<tr class="even">
<td><strong>Waiting（无限等待）</strong></td>
<td><strong>一个线程进入Waiting状态，另一个线程调用notify或者notifyAll方法才能够唤醒</strong></td>
</tr>
<tr class="odd">
<td><strong>Time Waiting（计时等待）</strong></td>
<td><strong>同waiting状态，有几个方法有超时参数，调用他们将进入Timed
waiting状态。带有超时参数的常用方法有Thread.sleep和Object.wait</strong></td>
</tr>
<tr class="even">
<td><strong>Teminated（被终止）</strong></td>
<td><strong>因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。</strong></td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML5+CSS301-day02</title>
    <url>/posts/10502.html</url>
    <content><![CDATA[<p>第二天笔记 <span id="more"></span></p>
<h1 id="列表">列表</h1>
<p>作用：布局内容排列整齐的区域。</p>
<h2 id="无序列表">无序列表</h2>
<p>作用：布局排列整齐的不需要规定顺序的区域。</p>
<p>标签：ul嵌套li，ul是无序列表，li是列表条目。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span>第一项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第二项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第三项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    ......</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ul>
<li>ul标签里面只能包裹li标签</li>
<li>li标签里面可以包裹任何内容</li>
</ul>
<h2 id="有序列表">有序列表</h2>
<p>作用：布局排列整齐的需要规定顺序的区域。</p>
<p>标签：ol嵌套li，ol是有序列表，li是列表条目。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span>第一项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第二项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第三项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    ......</span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ul>
<li>ol标签里面只能包裹li标签</li>
<li>li标签里面可以包裹任何内容</li>
</ul>
<h2 id="定义列表">定义列表</h2>
<p>标签：dl嵌套dt和dd，dl是定义列表，dt是定义列表的标题，dd是定义列表的描述/详情。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dt</span>&gt;</span>列表标题<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dd</span>&gt;</span>列表描述/详情<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    ......</span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ul>
<li>dl标签里面只能包裹li标签</li>
<li>dt和dd标签里面可以包裹任何内容</li>
</ul>
<h1 id="表格">表格</h1>
<h2 id="表格标签">表格标签</h2>
<p>网页中的表格与Excel表格类似，用来展示数据。</p>
<p>标签:table嵌套tr，tr嵌套td / th。</p>
<table>
<thead>
<tr class="header">
<th>标签名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>table</td>
<td>表格</td>
</tr>
<tr class="even">
<td>tr</td>
<td>行</td>
</tr>
<tr class="odd">
<td>td</td>
<td>表头单元格</td>
</tr>
<tr class="even">
<td>th</td>
<td>内容单元格</td>
</tr>
</tbody>
</table>
<p>提示：在网页中，表格默认没有边框线，使用border属性可以为表格添加边框线。</p>
<h2 id="表格结构标签">表格结构标签</h2>
<p>作用：用表格结构标签把内容划分区域，让表格结构更清晰，语义更清晰。</p>
<table>
<thead>
<tr class="header">
<th>标签名</th>
<th>含义</th>
<th>特殊说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>thead</td>
<td>表格头部</td>
<td>表格头部内容</td>
</tr>
<tr class="even">
<td>tbody</td>
<td>表格主体</td>
<td>主要内容区域</td>
</tr>
<tr class="odd">
<td>tfoot</td>
<td>表格底部</td>
<td>汇总信息区域</td>
</tr>
</tbody>
</table>
<h2 id="合并单元格">合并单元格</h2>
<p>作用：将多个单元格合并成一个单元格，以合并同类信息</p>
<p>跨行合并 跨列合并</p>
<p>合并单元格的步骤：</p>
<p>1．明确合并的目标</p>
<p>2．保留<strong>最左最上</strong>的单元格，添加属性（<strong>取值是数字，表示需要合并的单元格数量</strong>）</p>
<ul>
<li>跨行合并，保留<strong>最上</strong>单元格，添加属性<strong>rowspan</strong></li>
<li>跨列合并，保留<strong>最左</strong>单元格，添加属性<strong>colspan</strong></li>
</ul>
<p>3．删除其他单元格</p>
<h1 id="表单">表单</h1>
<p>input 标签的 type 属性不同，则功能不同</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">type属性值</th>
<th style="text-align: center;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">text</td>
<td style="text-align: center;">文本框，用于输入单行文本</td>
</tr>
<tr class="even">
<td style="text-align: center;">password</td>
<td style="text-align: center;">密码框</td>
</tr>
<tr class="odd">
<td style="text-align: center;">radio</td>
<td style="text-align: center;">单选框</td>
</tr>
<tr class="even">
<td style="text-align: center;">checkbox</td>
<td style="text-align: center;">多选框</td>
</tr>
<tr class="odd">
<td style="text-align: center;">file</td>
<td style="text-align: center;">上传文件</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>HTML+CSS</category>
      </categories>
      <tags>
        <tag>HTML+CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL01-基础语法</title>
    <url>/posts/10401.html</url>
    <content><![CDATA[<p>详细的描述了MySQL中的基础语法。 <span id="more"></span></p>
<h1 id="sql语法">SQL语法</h1>
<h2 id="sql通用语法">SQL通用语法</h2>
<ul>
<li>1.SQL语句可以单行或多行书写，以分号结尾。</li>
<li>2.SQL语句可以使用空格/缩进来增强语句的可读性。</li>
<li>3.MySQL数据库的SQL语句不区分大小写，关键字建议使用大写。</li>
<li>4.注释：
<ul>
<li>单行注释：--注释内容或#注释内容(MySQL特有)</li>
<li>多行注释：/*注释内容*/</li>
</ul></li>
</ul>
<h1 id="sql分类">SQL分类</h1>
<table>
<colgroup>
<col style="width: 4%" />
<col style="width: 30%" />
<col style="width: 64%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">分类</th>
<th>全称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">DDL</td>
<td>Data Definition Language</td>
<td>数据定义语言，用来定义数据库对象(数据库，表，字段)</td>
</tr>
<tr class="even">
<td style="text-align: center;">DML</td>
<td>Data Manipulation Language</td>
<td>数据操作语言，用来对数据库表中的数据进行增删改</td>
</tr>
<tr class="odd">
<td style="text-align: center;">DQL</td>
<td>Data Query Language</td>
<td>数据查询语言，用来查询数据库中表的记录</td>
</tr>
<tr class="even">
<td style="text-align: center;">DCL</td>
<td>Data Control Language</td>
<td>数据控制语言，用来创建数据库用户、控制数据库的访问权限</td>
</tr>
</tbody>
</table>
<h1 id="ddldata-definition-language-数据定义语言">DDL(Data Definition
Language 数据定义语言)</h1>
<h2 id="数据库操作">数据库操作</h2>
<h3 id="查询">查询</h3>
<ul>
<li>查询所有数据库</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW DATABASES;</span><br></pre></td></tr></table></figure>
<ul>
<li>查询当前数据库</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT DATABASE();</span><br></pre></td></tr></table></figure>
<h3 id="创建">创建</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE [IF NOT EXISTS] 数据库名 [DEFAULT CHARSET 字符集] [COLLATE 排序规则];</span><br></pre></td></tr></table></figure>
<h3 id="删除">删除</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP DATABASE [IF EXISTS] 数据库名;</span><br></pre></td></tr></table></figure>
<h3 id="使用">使用</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">USE 数据库名;</span><br></pre></td></tr></table></figure>
<h2 id="表操作">表操作</h2>
<h3 id="查询-1">查询</h3>
<ul>
<li>查询当前数据库所有表</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW TABLES;</span><br></pre></td></tr></table></figure>
<ul>
<li>查询表结果</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DESC 表明;</span><br></pre></td></tr></table></figure>
<ul>
<li>查询指定表的建表语句</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW CREATE TABLE 表名;</span><br></pre></td></tr></table></figure>
<h3 id="创建-1">创建</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE表名(</span><br><span class="line">	字段1 字段1类型[COMMENT 字段1注释],</span><br><span class="line">    字段2 字段2类型[COMMENT 字段2注释],</span><br><span class="line">    字段3 字段3类型[COMMENT 字段3注释],</span><br><span class="line">    ......</span><br><span class="line">	字段n 字段n类型[COMMENT 字段n注释]</span><br><span class="line">)[COMMENT 表注释];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>最后一个字段后面没有逗号</p>
</blockquote>
<h4 id="字段类型如下">字段类型如下</h4>
<h5 id="数值类型">数值类型</h5>
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 4%" />
<col style="width: 36%" />
<col style="width: 37%" />
<col style="width: 12%" />
</colgroup>
<thead>
<tr class="header">
<th>类型</th>
<th>大小</th>
<th>有符号(SIGNED)范围</th>
<th>无符号(UNSIGNED)范围</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>TINYINT</td>
<td>1 byte</td>
<td>(-128,127)</td>
<td>(0，255)</td>
<td>小整数值</td>
</tr>
<tr class="even">
<td>SMALLINT</td>
<td>2 bytes</td>
<td>(-32768，32767)</td>
<td>(0，65535)</td>
<td>大整数值</td>
</tr>
<tr class="odd">
<td>MEDIUMINT</td>
<td>3 bytes</td>
<td>(-8388608，8388607)</td>
<td>(0，16777215)</td>
<td>大整数值</td>
</tr>
<tr class="even">
<td>INT或INTEGER</td>
<td>4 bytes</td>
<td>(-2147483648，2147483647)</td>
<td>(0，4294967295)</td>
<td>大整数值</td>
</tr>
<tr class="odd">
<td>BIGINT</td>
<td>8 bytes</td>
<td>(-2<sup>63</sup>，2<sup>63</sup>-1)</td>
<td>(0，2<sup>64</sup>-1)</td>
<td>极大整数值</td>
</tr>
<tr class="even">
<td>FLOAT</td>
<td>4 bytes</td>
<td>(-3.402823466 E+38，3.402823466351 E+38)</td>
<td>0和(1.175494351 E-38，3.402823466 E+38)</td>
<td>单精度浮点数值</td>
</tr>
<tr class="odd">
<td>DOUBLE</td>
<td>8 bytes</td>
<td>(-1.7976931348623157 E+308，1.7976931348623157 E+308)</td>
<td>0和(2.2250738585072014 E-308，1.7976931348623157 E+308)</td>
<td>双精度浮点数值</td>
</tr>
<tr class="even">
<td>DECIMAL</td>
<td></td>
<td>依赖于M(精度)和D(标度)的值</td>
<td>依赖于M(精度)和D(标度)的值</td>
<td>小数值(精确定点数)</td>
</tr>
</tbody>
</table>
<h5 id="字符串类型">字符串类型</h5>
<table>
<thead>
<tr class="header">
<th>类型</th>
<th>大小</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>CHAR</td>
<td>0-255 bytes</td>
<td>定长字符串</td>
</tr>
<tr class="even">
<td>VARCHAR</td>
<td>0-65535 bytes</td>
<td>变长字符串</td>
</tr>
<tr class="odd">
<td>TINYBLOB</td>
<td>0-255 bytes</td>
<td>不超过255个字符的二进制数据</td>
</tr>
<tr class="even">
<td>TINYTEXT</td>
<td>0-255 bytes</td>
<td>短文本字符串</td>
</tr>
<tr class="odd">
<td>BLOB</td>
<td>0-65 535 bytes</td>
<td>二进制形式的长文本数据</td>
</tr>
<tr class="even">
<td>TEXT</td>
<td>0-65 535 bytes</td>
<td>长文本数据</td>
</tr>
<tr class="odd">
<td>MEDIUMBLOB</td>
<td>0-16 777 215 bytes</td>
<td>二进制形式的中等长度文本数据</td>
</tr>
<tr class="even">
<td>MEDIUMTEXT</td>
<td>0-16 777 215 bytes</td>
<td>中等长度文本数据</td>
</tr>
<tr class="odd">
<td>LONGBLOB</td>
<td>0-4 294 967 295 bytes</td>
<td>二进制形式的极大文本数据</td>
</tr>
<tr class="even">
<td>LONGTEXT</td>
<td>0-4 294 967 295 bytes</td>
<td>极大文本数据</td>
</tr>
</tbody>
</table>
<h5 id="日期类型">日期类型</h5>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 4%" />
<col style="width: 43%" />
<col style="width: 19%" />
<col style="width: 23%" />
</colgroup>
<thead>
<tr class="header">
<th>类型</th>
<th>大小</th>
<th>范围</th>
<th>格式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>DATE</td>
<td>3</td>
<td>1000-01-01 至 9999-12-31</td>
<td>YYYY-MM-DD</td>
<td>日期值</td>
</tr>
<tr class="even">
<td>TIME</td>
<td>3</td>
<td>-838:59:59 至 838:59:59</td>
<td>HH:MM:SS</td>
<td>时间值或持续时间</td>
</tr>
<tr class="odd">
<td>YEAR</td>
<td>1</td>
<td>1901 至 2155</td>
<td>YYYY</td>
<td>年份值</td>
</tr>
<tr class="even">
<td>DATETIME</td>
<td>8</td>
<td>1000-01-01 00:00:00 至 9999-12-31 23:59:59</td>
<td>YYYY-MM-DD HH:MM:SS</td>
<td>混合日期和时间值</td>
</tr>
<tr class="odd">
<td>TIMESTAMP</td>
<td>4</td>
<td>1970-01-01 00:00:01 至 2038-01-19 03:14:07</td>
<td>YYYY-MM-DD HH:MM:SS</td>
<td>混合日期和时间值 时间戳</td>
</tr>
</tbody>
</table>
<h2 id="修改">修改</h2>
<h3 id="字段">字段</h3>
<ul>
<li>添加</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释][约束];</span><br></pre></td></tr></table></figure>
<ul>
<li><p>修改</p>
<ul>
<li>修改数据类型</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度);</span><br></pre></td></tr></table></figure>
<ul>
<li>修改字段名和字段类型</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释][约束];</span><br></pre></td></tr></table></figure></li>
<li><p>删除</p></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP 字段名;</span><br></pre></td></tr></table></figure>
<h3 id="表">表</h3>
<ul>
<li>修改表名</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 RENAME TO 新表名;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>删除</p>
<ul>
<li>删除表</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TABLE [IF EXISTS] 表名;</span><br></pre></td></tr></table></figure>
<ul>
<li>删除指定表，并重新创建该表</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TRUNCATE TABLE 表名;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="dmldata-manipulation-language-数据操作语言">DML(Data
Manipulation Language 数据操作语言)</h1>
<h2 id="添加数据">添加数据</h2>
<ul>
<li>给指定字段添加数据</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO 表名(字段名1, 字段名2, ...) VALUES (值1, 值2, ...);</span><br></pre></td></tr></table></figure>
<ul>
<li>给全部字段添加数据</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO 表名 VALUES (值1, 值2, ...);</span><br></pre></td></tr></table></figure>
<ul>
<li>批量添加数据</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO 表名(字段名1, 字段名2, ...) VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO 表名 VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
<ul>
<li>插入数据时，指定的字段顺序需要与值的顺序是一一对应</li>
<li>字符串和日期型数据应该包含在引号中</li>
<li>插入的数据大小，应该在字段的规定范围内。</li>
</ul>
</blockquote>
<h2 id="修改数据">修改数据</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE 表名 SET 字段名1 = 值1, 字段名2 = 值2, ... [WHERE 条件];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：修改语句的条件可以有，也可以没有，如果没有条件，则会修改整张表的所有数据。</p>
</blockquote>
<h2 id="删除数据">删除数据</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE FROM 表名 [WHERE 条件];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
<ul>
<li>DELETE语句的条件可以有，也可以没有，如果没有条件，则会删除整张表的所有数据</li>
<li>DELET语句不能删除某一个字段的值(可以使用UPDATE)</li>
</ul>
</blockquote>
<h1
id="dqldata-query-language-数据查询语言用来查询数据库中表的记录">DQL(Data
Query Language 数据查询语言，用来查询数据库中表的记录)</h1>
<h2 id="语法">语法</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	字段列表</span><br><span class="line">FROM</span><br><span class="line">	表名列表</span><br><span class="line">WHERE</span><br><span class="line">	条件列表</span><br><span class="line">GROUP BY</span><br><span class="line">	分组字段列表</span><br><span class="line">HAVING</span><br><span class="line">	分组后条件列表</span><br><span class="line">ORDER BY</span><br><span class="line">	排序字段列表</span><br><span class="line">LIMIT</span><br><span class="line">	分页参数</span><br></pre></td></tr></table></figure>
<h2 id="基本查询">基本查询</h2>
<ul>
<li>查询多个字段</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 字段1, 字段2, 字段3 ... FROM 表名;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM 表名;</span><br></pre></td></tr></table></figure>
<ul>
<li>设置别名</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 字段1 [AS 别名1],字段2[AS 别名2] ... FROM 表名;</span><br></pre></td></tr></table></figure>
<ul>
<li>去除重复记录</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT DISTINCT 字段列表 FROM 表名;</span><br></pre></td></tr></table></figure>
<h2 id="条件查询where">条件查询(WHERE)</h2>
<h2
id="聚合函数countmaxminavgsum">聚合函数(count、max、min、avg、sum)</h2>
<h2 id="分组查询group-by">分组查询(GROUP BY)</h2>
<h2 id="排序查询order-by">排序查询(ORDER BY)</h2>
<h2 id="分页查询limit">分页查询(LIMIT)</h2>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE03-Java高级</title>
    <url>/posts/10103.html</url>
    <content><![CDATA[
]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL02-事务</title>
    <url>/posts/10402.html</url>
    <content><![CDATA[<p>详细的描述了MySQL中的事务的四大特性以及事务的隔离级别。
<span id="more"></span></p>
<h1 id="事务的简介">事务的简介</h1>
<blockquote>
<p><strong>事务</strong>是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p>
</blockquote>
<blockquote>
<p>默认MySQL的事务是自动提交的，也就是说，当执行一条DML语句，MySQL会立即隐式的提交事务。</p>
</blockquote>
<h1 id="事务的操作">事务的操作</h1>
<h2 id="提交事务的方式">提交事务的方式</h2>
<h3 id="方式一">1.方式一</h3>
<h4 id="查看设置事务的提交方式">① 查看/设置事务的提交方式</h4>
<blockquote>
<p>SELECT @<span class="citation"
data-cites="autocommit">@autocommit</span>; SET @<span class="citation"
data-cites="autocommit">@autocommit</span> = 0; --1是自动 0是手动 #### ②
提交事务 COMMIT; --提交事务 #### ③ 回滚事务 ROLLBACK; --回滚事务</p>
</blockquote>
<h3 id="方式二手动开启并且提交">2.方式二（手动开启并且提交）</h3>
<h4 id="开启事务">① 开启事务</h4>
<blockquote>
<p>START TRANSACTION / BEGIN; #### ② 提交事务 COMMIT； #### ③ 回滚事务
ROLLBACK;</p>
</blockquote>
<h1 id="事务的四大特性acid">事务的四大特性（ACID）</h1>
<blockquote>
<h2
id="原子性atomicity事务是不可分割的最小操作单元要么全部成功要么全部失败"><font size=3>原子性（<strong>A</strong>tomicity)：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</font></h2>
</blockquote>
<blockquote>
<h2
id="一致性consistency事务完成时必须使所有的数据都保持一致状态"><font size=3>一致性（Consistency)：事务完成时，必须使所有的数据都保持一致状态。</font></h2>
</blockquote>
<blockquote>
<h2
id="隔离性isolation数据库系统提供的隔离机制保证事务在不受外部并发操作影响的独立环境下运行"><font size=3>隔离性（Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</font></h2>
</blockquote>
<blockquote>
<h2
id="持久性durability-事务一旦提交或回滚它对数据库中的数据的改变就是永久的"><font size=3>持久性（Durability)
:事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</font></h2>
</blockquote>
<h1 id="并发事务的问题">并发事务的问题</h1>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>问题</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>脏读</td>
<td>一个事务读到另外一个事务还没有提交的数据。</td>
</tr>
<tr class="even">
<td>不可重复读</td>
<td>一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。</td>
</tr>
<tr class="odd">
<td>幻读</td>
<td>一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已存在，好像出现了'幻影”。</td>
</tr>
</tbody>
</table>
<h1 id="事务的隔离级别">事务的隔离级别</h1>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">隔离级别</th>
<th style="text-align: center;">脏读</th>
<th style="text-align: center;">不可重复读</th>
<th style="text-align: center;">幻读</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Read Uncommitted</td>
<td style="text-align: center;">√</td>
<td style="text-align: center;">√</td>
<td style="text-align: center;">√</td>
</tr>
<tr class="even">
<td style="text-align: center;">Read Committed</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">√</td>
<td style="text-align: center;">√</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Repeatable Read（默认）</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">√</td>
</tr>
<tr class="even">
<td style="text-align: center;">Serializable</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL03-存储引擎</title>
    <url>/posts/10403.html</url>
    <content><![CDATA[<p>详细的描述了MySQL中的引擎之间的区别和选择。 <span id="more"></span></p>
<h1 id="mysql体系结构">MySQL体系结构</h1>
<figure>
<img
src="https://wang-nine.cn/images/MySQL02-01%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png"
alt="MySQL02-01体系结构" />
<figcaption aria-hidden="true">MySQL02-01体系结构</figcaption>
</figure>
<h2 id="连接层">连接层</h2>
<blockquote>
<p>最上层是一些客户端和链接服务，主要完成一些类似于连接处理、授权认证、及相关的安全方案。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</p>
</blockquote>
<h2 id="服务层">服务层</h2>
<blockquote>
<p>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程、函数等。</p>
</blockquote>
<h2 id="引擎层">引擎层</h2>
<blockquote>
<p>存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。</p>
</blockquote>
<h2 id="存储层">存储层</h2>
<blockquote>
<p>主要是将数据存储在文件系统之上，并完成与存储引擎的交互。</p>
</blockquote>
<h1 id="存储引擎简介">存储引擎简介</h1>
<p>建表语句中使用 ENGINE = 引擎名 可以指定使用何种引擎
查看当前数据库支持的引擎： SHOW ENGINES；</p>
<h1 id="存储引擎的特点">存储引擎的特点</h1>
<h2 id="innodb">InnoDB</h2>
<p>简介 InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在MySQL
5.5之后，InnoDB是默认的MySQL存储引擎。</p>
<p>特点（事务，外键，行级锁）
DML操作遵循ACID模型,支持<strong>事务</strong>
支持<strong>外键</strong>FOREIGN KEY约束，保证数据的完整性和正确性
<strong>行级锁</strong>，提高并发访问性能</p>
<p>文件 xxx.ibd:
xxx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结构(frm、gdi)
、数据和索引。参数: innodb_file_per_table</p>
<figure>
<img src="https://wang-nine.cn/images/MySQL02-02InnoDB.png"
alt="MySQL02-02InnoDB" />
<figcaption aria-hidden="true">MySQL02-02InnoDB</figcaption>
</figure>
<h2 id="myisam">MyISAM</h2>
<p>简介 MylSAM是MySQL早期的默认存储引擎。</p>
<p>特点 不支持事务 不支持外键支持表锁 不支持行锁访问速度快</p>
<p>文件 xxx.sdi:存储表结构信息 xxx.MYD:存储数据 xxx.MYI:存储索引</p>
<h2 id="memory">Memory</h2>
<p>介绍
Memory引擎的表数据时存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为临时表或缓存使用。</p>
<p>特点 内存存放 hash索引（默认)</p>
<p>文件 xxx.sdi:存储表结构信息</p>
<p>比较：（来自黑马程序员，侵删）</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">特点</th>
<th style="text-align: center;">InnoDB</th>
<th style="text-align: center;">MyISAM</th>
<th style="text-align: center;">Memory</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">存储限制</td>
<td style="text-align: center;">64TB</td>
<td style="text-align: center;">有</td>
<td style="text-align: center;">有</td>
</tr>
<tr class="even">
<td style="text-align: center;">事务安全</td>
<td style="text-align: center;"><strong>支持</strong></td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
</tr>
<tr class="odd">
<td style="text-align: center;">锁机制</td>
<td style="text-align: center;"><strong>行锁</strong></td>
<td style="text-align: center;">表锁</td>
<td style="text-align: center;">表锁</td>
</tr>
<tr class="even">
<td style="text-align: center;">B+Tree索引</td>
<td style="text-align: center;">支持</td>
<td style="text-align: center;">支持</td>
<td style="text-align: center;">支持</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Hash索引</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">支持</td>
</tr>
<tr class="even">
<td style="text-align: center;">全文索引</td>
<td style="text-align: center;">支持</td>
<td style="text-align: center;">支持</td>
<td style="text-align: center;">-</td>
</tr>
<tr class="odd">
<td style="text-align: center;">空间使用</td>
<td style="text-align: center;">高</td>
<td style="text-align: center;">低</td>
<td style="text-align: center;">N/A</td>
</tr>
<tr class="even">
<td style="text-align: center;">内存使用</td>
<td style="text-align: center;">高</td>
<td style="text-align: center;">低</td>
<td style="text-align: center;">中等</td>
</tr>
<tr class="odd">
<td style="text-align: center;">批量插入速度</td>
<td style="text-align: center;">低</td>
<td style="text-align: center;">高</td>
<td style="text-align: center;">高</td>
</tr>
<tr class="even">
<td style="text-align: center;">支持外键</td>
<td style="text-align: center;"><strong>支持</strong></td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
</tr>
</tbody>
</table>
<h1
id="存储引擎的选择总结自黑马程序员mysql课程侵删">存储引擎的选择（总结自黑马程序员MySQL课程，侵删）</h1>
<p>在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。</p>
<p>InnoDB:是Mysql的默认存储引擎，支持事务、外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操怍除了插入和查询之外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。</p>
<p>MyISAM:如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。（被MongoDB取代）</p>
<p>MEMORY:将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。（被Redis取代）</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL04-索引01-结构</title>
    <url>/posts/10404.html</url>
    <content><![CDATA[<p>详细的描述了MySQL中的索引的结构。 <span id="more"></span></p>
<h1 id="介绍">介绍</h1>
<p>索引（index）是帮助MySQL<strong>高效获取数据</strong>的数据结构（有序）。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。</p>
<h1 id="优缺点">优缺点</h1>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">优势</th>
<th style="text-align: left;">劣势</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td
style="text-align: left;">提高数据检索的效率，降低数据库的IO成本</td>
<td style="text-align: left;">索引列也会占用空间</td>
</tr>
<tr class="even">
<td
style="text-align: left;">通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。</td>
<td
style="text-align: left;">索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE时,效率降低。</td>
</tr>
</tbody>
</table>
<p>但是：</p>
<blockquote>
<p><strong>目前磁盘很便宜，无所谓占用空间</strong></p>
<p><strong>目前业务查询 SELECT
频次很高，INSERT、UPDATE、DELETE等操作频次较少</strong></p>
<p><strong>综上，使用索引是非常有必要的</strong></p>
</blockquote>
<h1 id="结构">结构</h1>
<h2 id="分类">分类</h2>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 74%" />
</colgroup>
<thead>
<tr class="header">
<th>索引结构</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>B+Tree索引</td>
<td>最常见的索引类型，大部分引擎都支持B+树索引</td>
</tr>
<tr class="even">
<td>Hash索引</td>
<td>底层数据结构是用哈希表实现的，只有精确匹配索引列的查询才有效不支持范围查询</td>
</tr>
<tr class="odd">
<td>R-tree（空间索引）</td>
<td>空间索引是MylSAM引擎的一个特殊索引类型，主要用于地理空间数据类型，使用较少</td>
</tr>
<tr class="even">
<td>Full-text（全文索引）</td>
<td>是一种通过建立倒排索引,快速匹配文档的方式。类似于Lucene，Solr，ES</td>
</tr>
</tbody>
</table>
<h2 id="引擎对于索引的支持情况">引擎对于索引的支持情况</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">索引</th>
<th style="text-align: center;">InnoDB</th>
<th style="text-align: center;">MyISAM</th>
<th style="text-align: center;">Memory</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">B+tree索引</td>
<td style="text-align: center;">支持</td>
<td style="text-align: center;">支持</td>
<td style="text-align: center;">支持</td>
</tr>
<tr class="even">
<td style="text-align: center;">Hash索引</td>
<td style="text-align: center;">不支持</td>
<td style="text-align: center;">不支持</td>
<td style="text-align: center;">支持</td>
</tr>
<tr class="odd">
<td style="text-align: center;">R-tree索引</td>
<td style="text-align: center;">不支持</td>
<td style="text-align: center;">支持</td>
<td style="text-align: center;">不支持</td>
</tr>
<tr class="even">
<td style="text-align: center;">Full-text</td>
<td style="text-align: center;">5.6版本之后支持</td>
<td style="text-align: center;">支持</td>
<td style="text-align: center;">不支持</td>
</tr>
</tbody>
</table>
<p>具体结构可以点击以下链接进入页面进行模拟操作：</p>
<p><a
href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">点击此处链接进行模拟数据结构</a></p>
<p><a
href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html">点击此处链接进行模拟B+树结构</a></p>
<p>具体数据结构在《数据结构》课中都有详细描述。</p>
<h2 id="b树结构样例如下">B树结构样例如下：</h2>
<figure>
<img src="https://wang-nine.cn/images/MySQL03-01-01B%E6%A0%91.png"
alt="MySQL03-01-01B树" />
<figcaption aria-hidden="true">MySQL03-01-01B树</figcaption>
</figure>
<h2 id="b树结构样例如下-1">B+树结构样例如下：</h2>
<figure>
<img src="http://wang-nine.cn/images/MySQL03-01-02B+%E6%A0%91.png"
alt="MySQL03-01-02B+树" />
<figcaption aria-hidden="true">MySQL03-01-02B+树</figcaption>
</figure>
<p><strong>B树与B+树的区别：</strong></p>
<blockquote>
<p>1.所有的数据都会出现在叶子节点</p>
</blockquote>
<blockquote>
<p>2.叶子节点形成了一个单向链表</p>
</blockquote>
<blockquote>
<p>3.MySQL索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能。即MySQL将单向链表优化为双向链表。</p>
</blockquote>
<h2 id="hash索引">Hash索引</h2>
<p>Hash通过hash算法将键值对映射到指定位置，出现碰撞（hash冲突）可以通过链表解决。</p>
<blockquote>
<p>Hash索引特点
1.Hash索引只能用于对等比较(=，in)，不支持范围查询(between，&gt;，&lt;，....
2.无法利用索引完成排序操作
3.查询效率高，通常只需要一次检索就可以了，效率通常要高于B+tree索引</p>
</blockquote>
<p>在MySQL中，支持hash索引的是Memory引擎，而InnoDB中具有<strong>自适应hash功能</strong>，hash索引是存储引擎根据B+Tree索引在指定条件下自动构建的。</p>
<h2
id="为什么innodb存储引擎选择使用btree索引结构">为什么InnoDB存储引擎选择使用B+tree索引结构?</h2>
<blockquote>
<p>1.相对于二叉树，层级更少，搜索效率高;
2.对于B-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量
数据，只能增加树的高度，导致性能降低;
3.相对Hash索引，B+tree支持范围匹配及排序操作;</p>
</blockquote>
<h1 id="索引分类">索引分类</h1>
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 42%" />
<col style="width: 34%" />
<col style="width: 11%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">分类</th>
<th style="text-align: center;">含义</th>
<th style="text-align: center;">特点</th>
<th style="text-align: center;">关键字</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">主键索引</td>
<td style="text-align: center;">针对表中主键创建的索引</td>
<td style="text-align: center;">默认自动创建，只能有一个</td>
<td style="text-align: center;">PRIMARY</td>
</tr>
<tr class="even">
<td style="text-align: center;">唯一索引</td>
<td style="text-align: center;">避免数据列重复</td>
<td style="text-align: center;">可以多个</td>
<td style="text-align: center;">UNIQUE</td>
</tr>
<tr class="odd">
<td style="text-align: center;">常规索引</td>
<td style="text-align: center;">快速查询</td>
<td style="text-align: center;">可以多个</td>
<td style="text-align: center;">-</td>
</tr>
<tr class="even">
<td style="text-align: center;">全文索引</td>
<td style="text-align: center;">查找文本关键词，并非比较索引值</td>
<td style="text-align: center;">可以多个</td>
<td style="text-align: center;">FULLTEXT</td>
</tr>
</tbody>
</table>
<h1 id="innodb索引分类">InnoDB索引分类</h1>
<table>
<colgroup>
<col style="width: 28%" />
<col style="width: 49%" />
<col style="width: 22%" />
</colgroup>
<thead>
<tr class="header">
<th>分类</th>
<th>含义</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>聚集索引(Clustered Index)</td>
<td>数据与索引放在一起，叶子节点保存了一行的数据</td>
<td>必须存在，且只有一个</td>
</tr>
<tr class="even">
<td>二级索引(Secondary Index)</td>
<td>数据与索引分开存储，叶子节点存储对应主键</td>
<td>可以多个</td>
</tr>
</tbody>
</table>
<blockquote>
<p>聚集索引选取规则： 1.如果存在主键，主键索引就是聚集索引。
2.如果不存在主键，将使用第一含唯一（UNIQUE）索引作为聚集索引。
3.如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。</p>
</blockquote>
<p><strong>回表查询：</strong></p>
<p><strong>在二级索引中查询到主键，在聚集索引中根据主键查询到想要的数据</strong></p>
<blockquote>
<p>InnoDB主键索引的B+树高度为多高呢？</p>
</blockquote>
<blockquote>
<p>假设:
一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB的指针占用6个字节的空间，主键即使为bigint，占用字节数为8。
高度为2: n * 8 + (n + 1) * 6 = 16 * 1024，算出n约为1170 1171 * 16=18736
高度为3: 1171 * 1171 * 16 = 21939856</p>
</blockquote>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL4-索引02-性能分析</title>
    <url>/posts/10405.html</url>
    <content><![CDATA[<p>详细的描述了MySQL中的索引的性能分析。 <span id="more"></span></p>
<h1 id="索引创建的语法">索引创建的语法</h1>
<h2 id="创建索引">创建索引</h2>
<p>CREATE [UNIQUE|FULLTEXT] INDEX index_name ON table_name (
index_col_name ... ) ;</p>
<h2 id="查看索引">查看索引</h2>
<p>SHOW INDEX FROM table_name ;</p>
<h2 id="删除索引">删除索引</h2>
<p>DROP INDEX index_name ON table_name ;</p>
<h1 id="性能分析">性能分析</h1>
<h2 id="sql执行频次">SQL执行频次</h2>
<p>MySQL客户端连接成功后，通过show [session] global status
命令可以提供服务器状态信息。通过如下指令，可以查看当前数据库的INSERT、UPDATE、DELETE、SELECT的访问频次:
SHOW GLOBAL STATUS LIKE 'Com______'；
<strong>注：Com后面六个下划线即为INSERT、UPDATE、DELETE、SELECTINSERT、UPDATE、DELETE、SELECT等单词的长度。</strong></p>
<h2 id="慢查询日志">慢查询日志</h2>
<p>慢查询日志记录了所有执行时间超过指定参数
(long_query_time，单位:秒，默认10秒) 的所有SQL语句的日志。</p>
<p>MySQL的慢查询日志默认没有开启，需要在MySQL的配置文件 (/etc/my.cnf)
中配置如下信息:</p>
<blockquote>
<p>#开启MySQL慢日志查询开关 slow_query_log=1
#设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志
long_query_time=2</p>
</blockquote>
<p>配置完毕之后，通过以下指令重新启动MySQL服务器进行测试，查看慢日志文件中记录的信息/var/lib/mysql/localhost-slow.log</p>
<h2 id="profile详情">profile详情</h2>
<p>show
profiles能够在做SQL优化时帮助我们了解时间的具体耗费。通过have_profiling参数，能够看到当前MySQL是否支持profile操作</p>
<blockquote>
<p>SELECT @<span class="citation"
data-cites="have_profiling">@have_profiling</span>;</p>
</blockquote>
<p>默认profiling是关闭的，可以通过set语句在session/global级别开启profiling</p>
<blockquote>
<p>SET profiling = 1;</p>
</blockquote>
<h2 id="重要explain执行计划">(重要！！！)explain执行计划</h2>
<p>EXPLAIN 或者 DESC
命令获取MySQL如何执行SELECT语句的信息，包括在SELECT语句执行过程中表如何连接和连接的顺序。</p>
<p>语法：</p>
<blockquote>
<p>#直接在select语句之前加上关键字explain / desc</p>
<p>EXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件;</p>
</blockquote>
<p>explain执行计划中包含的信息如下：</p>
<ul>
<li>id: 查询序列号</li>
<li>select_type: 查询类型</li>
<li>table: 表名或者别名</li>
<li>partitions: 匹配的分区</li>
<li>type: 访问类型</li>
<li>possible_keys: 可能用到的索引</li>
<li>key: 实际用到的索引</li>
<li>key_len: 索引长度</li>
<li>ref: 与索引比较的列</li>
<li>rows: 估算的行数</li>
<li>filtered: 按表条件筛选的行百分比</li>
<li>Extra: 额外信息</li>
</ul>
<h3 id="一id列">一、id列</h3>
<p>select查询的序列号(一组数字)，表示查询中执行select子句或者操作表的顺序。
id列分为三种情况： 1. 如果id相同，那么执行顺序从上到下 2.
如果id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行
3. id相同和不同的，同时存在，同时满足以上两种规则即可。</p>
<h3 id="二select_type列">二、select_type列</h3>
<p>复制代码主要用来分辨查询的类型，是普通查询还是联合查询还是子查询
1. sample: 简单的查询，不包含子查询和union 2. primary:
查询中若包含任何复杂的子查询，最外层查询则被标记为Primary 3. union:
在union，union all和子查询中的第二个和随后的select被标记为union
4. dependent union: 在包含UNION或者UNION
ALL的大查询中，如果各个小查询都依赖于外层查询的话，那除了最左边的那个小查询之外，其余的小查询的select_type的值就是DEPENDENT
UNION。 5. union result: 从union表获取结果的select。
6. subquery: 在select或者where列表中包含子查询（不在from子句中）
7. dependent subquery:
子查询中的第一个select（不在from子句中），而且取决于外面的查询。
8. derived: 在FROM列表中包含的子查询被标记为DERIVED，也叫做派生类
9. UNCACHEABLE
SUBQUERY：一个子查询的结果不能被缓存，必须重新评估外链接的第一行对于外层的主表，子查询不可被物化，每次都需要计算（耗时操作）
10. uncacheable union:
表示union的查询结果不能被缓存：没找到具体的sql语句验证</p>
<h3 id="三table列">三、table列</h3>
<p>对应行正在访问哪一个表，表名或者别名，可能是临时表或者union合并结果集.
1.
如果是具体的表名，则表明从实际的物理表中获取数据，当然也可以是表的别名.
2. 表名是derivedN的形式，表示使用了id为N的查询产生的衍生表. 3. 当有union
result的时候，表名是union n1,n2等的形式，n1,n2表示参与union的id.</p>
<h3 id="四type列">四，type列</h3>
<p>type是访问类型，访问类型表示以何种方式去访问我们的数据，
访问类型很多，效率从最好到最坏是： <strong>NULL &gt; system &gt; const
&gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge
&gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt;
ALL</strong></p>
<ol type="1">
<li>all:
全表扫描，需要扫描整张表，从头到尾找到需要的数据行。一般情况下出现这样的sql语句而且数据量比较大的话那么就需要进行优化。
2. index：全索引扫描这个比all的效率要好，主要有两种情况，一种是当前的查询时覆盖索引，即我们需要的数据在索引中就可以索取，或者是使用了索引进行排序，这样就避免数据的重排序
3. range：表示利用索引查询的时候限制了范围，在指定范围内进行查询，这样避免了index的全索引扫描，适用的操作符：=,
&lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, BETWEEN, LIKE, or IN() 
4. index_subquery：利用索引来关联子查询，不再扫描全表但是大多数情况下使用SELECT子查询时，MySQL查询优化器会自动将子查询优化为联表查询，因此
type 不会显示为 index_subquery,而是ref</li>
<li>unique_subquery: 该连接类型类似于index_subquery,使用的是唯一索引。大多数情况下使用SELECT子查询时，MySQL查询优化器会自动将子查询优化为联表查询，因此
type 不会显示为 index_subquery,而是eq_ref
6. index_merge：在查询过程中需要多个索引组合使用.
7. ref_or_null：对于某个字段即需要关联条件，也需要null值的情况下，查询优化器会选择这种访问方式.
8. ref：使用了非唯一性索引进行数据的查找
9. eq_ref ：当进行等值联表查询使用主键索引或者唯一性非空索引进行数据查找(实际上唯一索引等值查询type不是eq_ref而是const)
10. const：最多只能匹配到一条数据，通常使用主键或唯一索引进行等值条件查询
11. system：表只有一行记录（等于系统表），这是const类型的特例，平时不会出现,不需要进行磁盘io</li>
<li>NULL：直接显示，例如 SELECT 'A' ，一般业务不可能优化为NULL</li>
</ol>
<h3 id="五possible_keys列">五、possible_keys列</h3>
<p>显示可能应用在这张表中的索引，一个或多个，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用。</p>
<h3 id="六key列">六、key列</h3>
<p>实际使用的索引，如果为null，则没有使用索引，查询中若使用了覆盖索引，则该索引和查询的select字段重叠。
### 七、key_len列</p>
<p>表示索引中使用的字节数，可以通过key_len计算查询中使用的索引长度，在不损失精度的情况下长度越短越好。
索引越大占用存储空间越大，这样io的次数和量就会增加，影响执行效率</p>
<h3 id="八ref列">八、ref列</h3>
<p>显示之前的表在key列记录的索引中查找值所用的列或者常量</p>
<h3 id="九rows列">九、rows列</h3>
<p>根据表的统计信息及索引使用情况，大致估算出找出所需记录需要读取的行数，此参数很重要，直接反应的sql找了多少数据，在完成目的的情况下越少越好。</p>
<h3 id="十filtered列">十、filtered列</h3>
<p>针对表中符合某个条件(where子句或者联接条件)的记录数的百分比所做的一个悲观估算。</p>
<h3 id="十一extra列">十一、extra列</h3>
<p>包含额外的信息。 1. using
filesort: 说明mysql无法利用索引进行排序，只能利用排序算法进行排序，会消耗额外的位置
2. using temporary: 建立临时表来保存中间结果，查询完成之后把临时表删除
3. using
index: 这个表示当前的查询是覆盖索引的，直接从索引中读取数据，而不用访问数据表。如果同时出现using
where
表名索引被用来执行索引键值的查找，如果没有，表面索引被用来读取数据，而不是真的查找
4. using where: 使用where进行条件过滤 5. using join buffer: 使用连接缓存
6. impossible where：where语句的结果总是false</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL06-存储过程</title>
    <url>/posts/10408.html</url>
    <content><![CDATA[<p>详细的描述了MySQL中的存储过程。 <span id="more"></span></p>
<h1 id="存储过程介绍">存储过程介绍</h1>
<h2 id="简介">简介</h2>
<ul>
<li>存储过程是事先经过编译并存储在数据库中的一段SQL语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。</li>
<li>存储过程思想上很简单，就是数据库SQL语言层面的代码封装与重用。</li>
</ul>
<h2 id="特点">特点</h2>
<ul>
<li>封装，复用</li>
<li>可以接收参数，也可以返回数据</li>
<li>减少网络交互，效率提升</li>
</ul>
<h1 id="存储过程语法">存储过程语法</h1>
<h2 id="创建">创建</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE PROCEDURE 存储过程名称([参数列表])</span><br><span class="line">BEGIN</span><br><span class="line">	...SQL语句</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>
<h2 id="调用">调用</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CALL 名称([参数]);</span><br></pre></td></tr></table></figure>
<h2 id="查看">查看</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUINE_SQHEMA = &#x27;xxx&#x27;;  --查询指定数据库的存储过程及状态信息</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW CREATE PROCEDURE 存储过程名称; --查询某个存储过程的定义</span><br></pre></td></tr></table></figure>
<h2 id="删除">删除</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP PROCEDURE [IF EXISTS] 存储过程名称;</span><br></pre></td></tr></table></figure>
<h2 id="注意">注意</h2>
<p>注意：在命令行中，执行创建存储过程的SQL时，需要通过关键字 delimiter
指定SQL语句的结束符。</p>
<p>可以设置为两个$$符号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">delimiter $$</span><br></pre></td></tr></table></figure>
<h1 id="变量">变量</h1>
<h2 id="系统变量">系统变量</h2>
<p>系统变量是MySQL服务器提供，不是用户定义的，属于服务器层面。分为全局变量（GLOBAL）、会话变量（SESSION）</p>
<h3 id="查看系统变量">查看系统变量</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW [SESSION|GLOBAL] VARIABLES; --查看所有系统变量</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW [SESSION|GLOBAL] VARIABLES LIKE ...; --可以通过LIKE模糊匹配方式查找变量</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT @@[SESSION|GLOBAL] 系统变量名; --查看指定变量的值</span><br></pre></td></tr></table></figure>
<h3 id="设置系统变量">设置系统变量</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET [SESSION|GLOBAL] 系统变量名 = 值;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET @@[SESSION|GLOBAL] 系统变量名 = 值;</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong></p>
<ul>
<li>如果没有指定SESSION/GLOBAL，默认是SESSION，会话变量。</li>
<li>mysql服务重新启动之后，所设置的全局参数会失效，要想不失效，可以在/etc/my.cnf
中配置。</li>
</ul>
<h2 id="用户定义变量">用户定义变量</h2>
<p>用户定义变量是用户根据需要自己定义的变量，用户变量不用提前声明，在用的时候直接用“<span
class="citation"
data-cites="变量名">@变量名</span>”使用就可以。其作用域为当前连接即当前会话。</p>
<h3 id="赋值">赋值</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET @var_name = expr [,@var_name = expr] ...;</span><br><span class="line">SET @var_name := expr [,@var_name := expr] ...;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT @var_name := expr [, @var_name := expr]... ;</span><br><span class="line">SELECT 字段名 INTO @var_name FROM 表名;</span><br></pre></td></tr></table></figure>
<h3 id="使用">使用</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT @var_name;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ul>
<li><strong>在MySQL中， =
既可以作为赋值，也可以作为比较，因此在赋值时建议使用 := </strong></li>
<li><strong>用户定义的变量无需对其进行声明或初始化，只不过获取到的值为NULL.</strong></li>
</ul>
<h2 id="局部变量">局部变量</h2>
<p>局部变量是根据需要定义的在局部生效的变量，访问之前，需要DECLARE声明。可用作存储过程内的局部变量和输入参数，局部变量的范围是在其内声明的BEGIN....END块。</p>
<h3 id="声明">声明</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DECLARE 变量名变量类型 [DEFAULT ...];</span><br></pre></td></tr></table></figure>
<h3 id="赋值-1">赋值</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET 变量名 = 值;</span><br><span class="line">SET 变量名 := 值;</span><br><span class="line">SELECT 字段名 INTO 变量名 FROM 表名 ...;</span><br></pre></td></tr></table></figure>
<h1 id="存储过程">存储过程</h1>
<h2 id="存储过程---if-判断">存储过程 - if 判断</h2>
<h3 id="语法">语法</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IF 条件1 THEN</span><br><span class="line">	...</span><br><span class="line">ELSE IF 条件2 THEN --可选</span><br><span class="line">	...</span><br><span class="line">ELSE --可选</span><br><span class="line">	...</span><br><span class="line">END IF;</span><br></pre></td></tr></table></figure>
<h3 id="无参数的存储过程样例">无参数的存储过程样例</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 判定分数对应的分数等级。</span><br><span class="line">-- score &gt;= 85分，等级为优秀。</span><br><span class="line">-- score &gt;= 60分且score &lt; 85分，等级为及格。</span><br><span class="line">-- score &lt; 60分，等级为不及格。</span><br><span class="line">create procedure p1()</span><br><span class="line">begin</span><br><span class="line">    declare score int default 58;</span><br><span class="line">    declare result varchar(10);</span><br><span class="line">    if score &gt;= 85 then</span><br><span class="line">        set result := &#x27;优秀&#x27;;</span><br><span class="line">    elseif score &gt;= 60 then</span><br><span class="line">        set result := &#x27;及格&#x27;;</span><br><span class="line">    else</span><br><span class="line">        set result := &#x27;不及格&#x27;;</span><br><span class="line">    end if;</span><br><span class="line">    select result;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">call p1();</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure>
<img
src="https://wang-nine.cn/images/MySQL05-01%E6%97%A0%E5%8F%82%E6%95%B0if%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B.png"
alt="MySQL05-01无参数if存储过程" />
<figcaption aria-hidden="true">MySQL05-01无参数if存储过程</figcaption>
</figure>
<h2 id="参数">参数</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">类型</th>
<th>含义</th>
<th style="text-align: center;">备注</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">IN</td>
<td>该类参数作为输入，也就是需要调用时传入值</td>
<td style="text-align: center;">默认</td>
</tr>
<tr class="even">
<td style="text-align: center;">OUT</td>
<td>该类参数作为输出,也就是该参数可以作为返回值</td>
<td style="text-align: center;">/</td>
</tr>
<tr class="odd">
<td style="text-align: center;">INOUT</td>
<td>既可以作为输入参数,也可以作为输出参数</td>
<td style="text-align: center;">/</td>
</tr>
</tbody>
</table>
<h3 id="语法-1">语法</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE PROCEDURE 存储过程名称 ([IN / OUT / INOUT 参数名 参数类型])</span><br><span class="line">BEGIN</span><br><span class="line">	--SQL语句</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>
<h3 id="有参数的存储过程样例">有参数的存储过程样例</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 根据传入(in)参数score，判定当前分数对应的分数等级，并返回(out)。</span><br><span class="line">-- score &gt;= 85分，等级为优秀。</span><br><span class="line">-- score &gt;= 60分且score &lt; 85分，等级为及格。</span><br><span class="line">-- score &lt; 60分，等级为不及格。</span><br><span class="line">create procedure p1(in score int, out result varchar(10))</span><br><span class="line">begin</span><br><span class="line">    if score &gt;= 85 then</span><br><span class="line">        set result := &#x27;优秀&#x27;;</span><br><span class="line">    elseif score &gt;= 60 then</span><br><span class="line">        set result := &#x27;及格&#x27;;</span><br><span class="line">    else</span><br><span class="line">        set result := &#x27;不及格&#x27;;</span><br><span class="line">    end if;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">call p1(68, @result);</span><br><span class="line">select @result;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure>
<img
src="https://wang-nine.cn/images/MySQL05-02%E6%9C%89%E5%8F%82%E6%95%B0if%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B.png"
alt="MySQL05-02有参数if存储过程.png" />
<figcaption
aria-hidden="true">MySQL05-02有参数if存储过程.png</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 将传入的 200分制的分数,进行换算,换算成百分制，然后返阿分数---&gt; inout</span><br><span class="line">create procedure p2(inout score double)</span><br><span class="line">begin</span><br><span class="line">    set score := score * 0.5;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">set @score = 163;</span><br><span class="line">call p2(@score);</span><br><span class="line">select @score;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure>
<img
src="https://wang-nine.cn/images/MySQL05-03%E6%9C%89%E5%8F%82%E6%95%B0%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B.png"
alt="MySQL05-03有参数存储过程" />
<figcaption aria-hidden="true">MySQL05-03有参数存储过程</figcaption>
</figure>
<h2 id="存储过程---case">存储过程 - Case</h2>
<h3 id="语法一">语法一</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CASE case_value</span><br><span class="line">	WHEN when_value1 THEN statement_list1</span><br><span class="line">	[WHEN when_value2 THEN statement_Kist 2] ...</span><br><span class="line">	[ELSE statement_list]</span><br><span class="line">END CASE;</span><br></pre></td></tr></table></figure>
<h3 id="语法二">语法二</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CASE</span><br><span class="line">	WHEN search_condition1 THEN statement_list1</span><br><span class="line">	[WHEN search_condition2 THEN statement_list2] ...</span><br><span class="line">	[ELSE statemept tlist]</span><br><span class="line">END CASE;</span><br></pre></td></tr></table></figure>
<h3 id="样例">样例</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 根据传入的月份，判定月份所属的季节（要求采用case结构)。</span><br><span class="line">-- 1.1-3月份,为第一季度</span><br><span class="line">-- 2.4-6月份，为第二季度</span><br><span class="line">-- 3.7-9月份，为第三季度</span><br><span class="line">-- 4.10-12月份，为第四季度</span><br><span class="line">create procedure p3(in month int)</span><br><span class="line">begin</span><br><span class="line">    declare result varchar(10);</span><br><span class="line"></span><br><span class="line">    case</span><br><span class="line">        when month &gt;= 1 and month &lt;= 3</span><br><span class="line">            then set result := &#x27;第一季度&#x27;;</span><br><span class="line">        when month &gt;= 4 and month &lt;= 6</span><br><span class="line">            then set result := &#x27;第二季度&#x27;;</span><br><span class="line">        when month &gt;= 7 and month &lt;= 9</span><br><span class="line">            then set result := &#x27;第三季度&#x27;;</span><br><span class="line">        when month &gt;= 10 and month &lt;= 12</span><br><span class="line">            then set result := &#x27;第四季度&#x27;;</span><br><span class="line">        else</span><br><span class="line">            set result := &#x27;非法参数&#x27;;</span><br><span class="line">    end case;</span><br><span class="line">    select concat(&#x27;您输入的月份为&#x27;, month, &#x27;所属的季度为&#x27;, result);</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">call p3(4)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure>
<img
src="https://wang-nine.cn/images/MySQL05-03case%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B.png"
alt="MySQL05-03case存储过程" />
<figcaption aria-hidden="true">MySQL05-03case存储过程</figcaption>
</figure>
<h2 id="存储过程循环---while">存储过程循环 - while</h2>
<p><strong>while循环是有条件的循环控制语句。满足条件后，再执行循环体中的SQL语句。</strong></p>
<h3 id="语法-2">语法</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#先判定条件，如果条件为true，则执行逻辑，否则，不执行逻辑</span><br><span class="line">WHILE 条件 DO</span><br><span class="line">	SQL逻辑...</span><br><span class="line">END WHILE;</span><br></pre></td></tr></table></figure>
<h3 id="样例-1">样例</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 计算从1紧加到的值，n为传入的参数值。</span><br><span class="line">-- 1. 定义局部变量，记录累加后的值</span><br><span class="line">-- 2. 每新环一次,就会n进行减1,如果n减到0，则退出循环</span><br><span class="line">create procedure p4(in n int)</span><br><span class="line">begin</span><br><span class="line">    declare total int default 0;</span><br><span class="line">    while n &gt; 0 do</span><br><span class="line">        set total := total + n;</span><br><span class="line">        set n := n - 1;</span><br><span class="line">    end while;</span><br><span class="line">    select total;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">call p4(10);</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure>
<img
src="https://wang-nine.cn/images/MySQL05-04while%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B.png"
alt="MySQL05-04while存储过程.png" />
<figcaption aria-hidden="true">MySQL05-04while存储过程.png</figcaption>
</figure>
<h2 id="存储过程循环---repeat">存储过程循环 - repeat</h2>
<p><strong>repeat是有条件的循环控制语句，当满足条件的时候退出循环。</strong></p>
<h3 id="语法-3">语法</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#先执行一次逻辑，然后判定逻辑是否满足，如果满足，则退出。如果不满足，则继续下一次循环</span><br><span class="line">REPEAT</span><br><span class="line">	SQL逻辑 ...</span><br><span class="line">	UNTIL 条件</span><br><span class="line">END REPEAT;</span><br></pre></td></tr></table></figure>
<h3 id="样例-2">样例</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 计算从1紧加到的值，n为传入的参数值。</span><br><span class="line">-- 1. 定义局部变量，记录累加后的值</span><br><span class="line">-- 2. 每新环一次,就会n进行减1,如果n减到0，则退出循环</span><br><span class="line">create procedure p5(in n int)</span><br><span class="line">begin</span><br><span class="line">    declare total int default 0;</span><br><span class="line">    repeat</span><br><span class="line">        set total := total + n;</span><br><span class="line">        set n := n - 1;</span><br><span class="line">    until n &lt;= 0</span><br><span class="line">    end repeat;</span><br><span class="line">    select total;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">l p5(10);</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure>
<img
src="https://wang-nine.cn/images/MySQL05-04while%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B.png"
alt="MySQL05-04while存储过程.png" />
<figcaption aria-hidden="true">MySQL05-04while存储过程.png</figcaption>
</figure>
<h2 id="存储过程循环---loop">存储过程循环 - loop</h2>
<p><strong>LOOP实现简单的循环，如果不在SQL逻辑中增加退出循环的条件，可以用其来实现简单的死循环。</strong></p>
<p>OOP可以配合一下两个语句使用**</p>
<ul>
<li><strong>LEAVE：配合循环使用，退出循环。</strong></li>
<li><strong>ITERATE：必须用在循环中，作用是跳过当前循环剩下的语句，直接进入下一次循环。</strong></li>
</ul>
<h3 id="语法-4">语法</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[begin_label:] LOOP</span><br><span class="line">	SQL逻辑 ...</span><br><span class="line">END LOOP [end_label];</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LEAVE label; --退出指定标记的循环体</span><br><span class="line">ITERATE label; --直接进入下一次循环</span><br></pre></td></tr></table></figure>
<h3 id="样例1">样例1</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 计算从1紧加到的值,n为传入的参数值。</span><br><span class="line">-- 1. 定义局部变量,记录累加后的值</span><br><span class="line">-- 2. 每新环一次,就会n进行减1,如果n减到0，则退出循环   ---&gt; leave xxx;</span><br><span class="line">create procedure p6(in n int)</span><br><span class="line">begin</span><br><span class="line">    declare total int default 0;</span><br><span class="line">    sum : loop</span><br><span class="line">        if n &lt;= 0 then</span><br><span class="line">            leave sum;</span><br><span class="line">        end if;</span><br><span class="line"></span><br><span class="line">        set total := total + n;</span><br><span class="line">        set n := n - 1;</span><br><span class="line">    end loop;</span><br><span class="line">    select total;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">call p6(10);</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure>
<img
src="https://wang-nine.cn/images/MySQL05-04while%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B.png"
alt="MySQL05-04while存储过程.png" />
<figcaption aria-hidden="true">MySQL05-04while存储过程.png</figcaption>
</figure>
<h3 id="样例2">样例2</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 计算从1到n之问的偶数累加的值，n为传入的参数值。</span><br><span class="line">-- 1．定义局部变量，记录累加之后的值;</span><br><span class="line">-- 2．每循环一次，就会对n进行-1，如果n减到0，则退出循环   ---&gt; leave xxx</span><br><span class="line">-- 3．如果当次累加的数据是奇数，则直接进入下一次循环   ---&gt; iterate xxx</span><br><span class="line">create procedure p7(in n int)</span><br><span class="line">begin</span><br><span class="line">    declare total int default 0;</span><br><span class="line">    sum : loop</span><br><span class="line">        if n &lt;= 0 then</span><br><span class="line">            leave sum;</span><br><span class="line">        end if;</span><br><span class="line"></span><br><span class="line">        if n % 2 = 1 then</span><br><span class="line">            set n := n - 1;</span><br><span class="line">            iterate sum;</span><br><span class="line">        end if;</span><br><span class="line"></span><br><span class="line">        set total := total + n;</span><br><span class="line">        set n := n - 1;</span><br><span class="line">    end loop;</span><br><span class="line">    select total;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">call p7(10);</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure>
<img
src="https://wang-nine.cn/images/MySQL05-05loop%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B.png"
alt="MySQL05-05loop存储过程" />
<figcaption aria-hidden="true">MySQL05-05loop存储过程</figcaption>
</figure>
<h2 id="游标---cursor">游标 - Cursor</h2>
<p>游标（CURSOR）是用来存储查询结果集的数据类型，在存储过程和函数中可以使用游标对结果集进行循环的处理。</p>
<p>游标的使用包括游标的声明、OPEN、FETCH 和 CLOSE，其语法分别如下。</p>
<h3 id="语法-5">语法：</h3>
<h4 id="声明游标">声明游标</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DECLARE 游标名称 CURSOR FOR 查询语句;</span><br></pre></td></tr></table></figure>
<h4 id="打开游标">打开游标</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OPEN 游标名称;</span><br></pre></td></tr></table></figure>
<h4 id="获取游标记录">获取游标记录</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FETCH 游标名称 INTO 变量[变量];</span><br></pre></td></tr></table></figure>
<h4 id="关闭游标">关闭游标</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CLOSE 游标名称;</span><br></pre></td></tr></table></figure>
<h2 id="样例-3">样例</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 游标</span><br><span class="line">-- 根据传入的参数uage，来查询用户表tb_user中，所有的用户年龄小于等于uage的用户姓名(name)和专业（profession)，</span><br><span class="line">-- 并将用户的姓名和专业插入到所创建的一张新表(id,name,profession)中</span><br><span class="line"></span><br><span class="line">-- 逻辑</span><br><span class="line">-- 1. 声明游标，存储查询到的结果集</span><br><span class="line">-- 2. 准备：创建表结构</span><br><span class="line">-- 3. 开启游标</span><br><span class="line">-- 4， 获取游标中的记录</span><br><span class="line">-- 5. 将记录插入到新的表中</span><br><span class="line">-- 6. 关闭游标</span><br><span class="line">create procedure p8(in uage int)</span><br><span class="line">begin</span><br><span class="line">    declare uname varchar(100);</span><br><span class="line">    declare upro varchar(100);</span><br><span class="line">    declare u_cursor cursor for select name, profession from tb_user where age &lt;= uage;</span><br><span class="line"></span><br><span class="line">    drop table if exists tb_user_pro;</span><br><span class="line">    create table if not exists tb_user_pro(</span><br><span class="line">        id int primary key auto_increment,</span><br><span class="line">        name varchar(100),</span><br><span class="line">        profession varchar(100)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    open u_cursor;</span><br><span class="line"></span><br><span class="line">    while true do</span><br><span class="line">        fetch u_cursor into uname, upro;</span><br><span class="line">        insert into tb_user_pro values (null, uname, upro);</span><br><span class="line">    end while;</span><br><span class="line"></span><br><span class="line">    close u_cursor;</span><br><span class="line"></span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">call p8(30);</span><br></pre></td></tr></table></figure>
<p><strong>注意while的循环退出条件为true，即死循环，产生如下bug</strong></p>
<figure>
<img
src="https://wang-nine.cn/images/MySQL05-06cursor%E4%B8%AD%E7%9A%84bug.png"
alt="MySQL05-06cursor中的bug" />
<figcaption aria-hidden="true">MySQL05-06cursor中的bug</figcaption>
</figure>
<p><strong>注意</strong></p>
<ul>
<li>普通变量的声明先与游标</li>
<li>循环中如何得知循环结束的条件？即游标什么时候遍历完？</li>
</ul>
<h2 id="条件处理程序">条件处理程序</h2>
<p>条件处理程序（Handler）可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤。</p>
<h3 id="语法-6">语法</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DECLARE handler_action HANDLER FOR condition_value [,condition_value] ... statement;</span><br><span class="line"></span><br><span class="line">handler_action</span><br><span class="line">	cONTINUE:继续执行当前程序</span><br><span class="line">	EXIT:终止执行当前程序</span><br><span class="line">condition_value</span><br><span class="line">	SQLSTATE:sqlstate_value:状态码，如02000</span><br><span class="line">	SQLWARNING:所有以01开头的SQLSTATE代码的简写</span><br><span class="line">	NOT FOUND:所有以02开头的SQLSTATE代码的简写</span><br><span class="line">	SQLEXCEPTION:所有没有被SQLWARNING 或 NOT FOUND捕获的SQLSTATE代码的简写</span><br></pre></td></tr></table></figure>
<h3 id="样例改进了循环退出判断条件">样例(改进了循环退出判断条件)</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 游标</span><br><span class="line">-- 根据传入的参数uage，来查询用户表tb_user中，所有的用户年龄小于等于uage的用户姓名(name)和专业（profession)，</span><br><span class="line">-- 并将用户的姓名和专业插入到所创建的一张新表(id,name,profession)中</span><br><span class="line"></span><br><span class="line">-- 逻辑</span><br><span class="line">-- 1. 声明游标，存储查询到的结果集</span><br><span class="line">-- 2. 准备：创建表结构</span><br><span class="line">-- 3. 开启游标</span><br><span class="line">-- 4， 获取游标中的记录</span><br><span class="line">-- 5. 将记录插入到新的表中</span><br><span class="line">-- 6. 关闭游标</span><br><span class="line">create procedure p8(in uage int)</span><br><span class="line">begin</span><br><span class="line">    declare uname varchar(100);</span><br><span class="line">    declare upro varchar(100);</span><br><span class="line">    declare u_cursor cursor for select name, profession from tb_user where age &lt;= uage;</span><br><span class="line"></span><br><span class="line">    -- 声明条件处理程序，当状态码为 02000 时关闭游标</span><br><span class="line">    -- 也可以写为 declare exit handler for not found close u_cursor;</span><br><span class="line">    declare exit handler for sqlstate &#x27;02000&#x27; close u_cursor;</span><br><span class="line"></span><br><span class="line">    drop table if exists tb_user_pro;</span><br><span class="line">    create table if not exists tb_user_pro(</span><br><span class="line">        id int primary key auto_increment,</span><br><span class="line">        name varchar(100),</span><br><span class="line">        profession varchar(100)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    open u_cursor;</span><br><span class="line"></span><br><span class="line">    while true do</span><br><span class="line">        fetch u_cursor into uname, upro;</span><br><span class="line">        insert into tb_user_pro values (null, uname, upro);</span><br><span class="line">    end while;</span><br><span class="line"></span><br><span class="line">    close u_cursor;</span><br><span class="line"></span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">call p8(30);</span><br></pre></td></tr></table></figure>
<p>具体的详细的官方解释的状态码如下</p>
<p><a
href="https://dev.mysql.com/doc/mysql-errors/8.0/en/server-error-reference.html">MySQL官网文档状态码解释</a></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/posts/1.html</url>
    <content><![CDATA[<h2 id="mysql8.0.26-linux版安装">MySQL8.0.26-Linux版安装</h2>
<h3 id="准备一台linux服务器">1. 准备一台Linux服务器</h3>
<p>云服务器或者虚拟机都可以;</p>
<p>Linux的版本为 CentOS7;</p>
<h3 id="下载linux版mysql安装包">2. 下载Linux版MySQL安装包</h3>
<p>https://downloads.mysql.com/archives/community/</p>
<h3 id="上传mysql安装包">3. 上传MySQL安装包</h3>
<h3 id="创建目录并解压">4. 创建目录,并解压</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir mysql</span><br><span class="line"></span><br><span class="line">tar -xvf mysql-8.0.26-1.el7.x86_64.rpm-bundle.tar -C mysql</span><br></pre></td></tr></table></figure>
<h3 id="安装mysql的安装包">5. 安装mysql的安装包</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd mysql</span><br><span class="line"></span><br><span class="line">rpm -ivh mysql-community-common-8.0.26-1.el7.x86_64.rpm </span><br><span class="line"></span><br><span class="line">rpm -ivh mysql-community-client-plugins-8.0.26-1.el7.x86_64.rpm </span><br><span class="line"></span><br><span class="line">rpm -ivh mysql-community-libs-8.0.26-1.el7.x86_64.rpm </span><br><span class="line"></span><br><span class="line">rpm -ivh mysql-community-libs-compat-8.0.26-1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">yum install openssl-devel</span><br><span class="line"></span><br><span class="line">rpm -ivh  mysql-community-devel-8.0.26-1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">rpm -ivh mysql-community-client-8.0.26-1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">rpm -ivh  mysql-community-server-8.0.26-1.el7.x86_64.rpm</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="启动mysql服务">6. 启动MySQL服务</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start mysqld</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl stop mysqld</span><br></pre></td></tr></table></figure>
<h3 id="查询自动生成的root用户密码">7. 查询自动生成的root用户密码</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep &#x27;temporary password&#x27; /var/log/mysqld.log</span><br></pre></td></tr></table></figure>
<p>命令行执行指令 :</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>
<p>然后输入上述查询到的自动生成的密码, 完成登录 .</p>
<h3 id="修改root用户密码">8. 修改root用户密码</h3>
<p>登录到MySQL之后，需要将自动生成的不便记忆的密码修改了，修改成自己熟悉的便于记忆的密码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER  USER  &#x27;root&#x27;@&#x27;localhost&#x27;  IDENTIFIED BY &#x27;1234&#x27;;</span><br></pre></td></tr></table></figure>
<p>执行上述的SQL会报错，原因是因为设置的密码太简单，密码复杂度不够。我们可以设置密码的复杂度为简单类型，密码长度为4。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set global validate_password.policy = 0;</span><br><span class="line">set global validate_password.length = 4;</span><br></pre></td></tr></table></figure>
<p>降低密码的校验规则之后，再次执行上述修改密码的指令。</p>
<h3 id="创建用户">9. 创建用户</h3>
<p>默认的root用户只能当前节点localhost访问，是无法远程访问的，我们还需要创建一个root账户，用户远程访问</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create user &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;1234&#x27;;</span><br></pre></td></tr></table></figure>
<h3 id="并给root用户分配权限">10. 并给root用户分配权限</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grant all on *.* to &#x27;root&#x27;@&#x27;%&#x27;;</span><br></pre></td></tr></table></figure>
<h3 id="重新连接mysql">11. 重新连接MySQL</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>
<p>然后输入密码</p>
<h3 id="通过datagrip远程连接mysql">12. 通过DataGrip远程连接MySQL</h3>
]]></content>
  </entry>
  <entry>
    <title>MySQL05-SQL优化</title>
    <url>/posts/10407.html</url>
    <content><![CDATA[<p>详细的描述了MySQL中的SQL语句的优化。 <span id="more"></span></p>
<h1 id="mysql语句优化">MySQL语句优化</h1>
<h2 id="插入数据优化">插入数据优化</h2>
<h3 id="批量插入">批量插入</h3>
<blockquote>
<p>#客户端连接服务端时，加上参数 --local-infilemysql --local-infile -u
root -p #设置全局参数local_infile为，开启从本地加载文件导入数据的开关
set global local_infile = 1; #执行load指令将准备好的数据，加载到表结构中
load data local infile '/root/sql1.log' into table 'table' fields
terminated by ',' lines terminated by '';</p>
</blockquote>
<h3 id="手动提交事务">手动提交事务</h3>
<h3 id="主键顺序插入">主键顺序插入</h3>
<p>主键顺序插入性能高于乱序插入</p>
<h2 id="主键优化">主键优化</h2>
<h3 id="数据组织方式">数据组织方式</h3>
<blockquote>
<p>在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表(index
organized table IOT)。</p>
</blockquote>
<h3 id="页分裂">页分裂</h3>
<blockquote>
<p>页可以为空，也可以填充一半，也可以填充100%。每个页包含了2-N行数据(如果一行数据多大，会行溢出)，根据主键排列。
主键乱序插入</p>
</blockquote>
<h3 id="页合并">页合并</h3>
<blockquote>
<p>当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged)为删除并且它的空间变得允许被其他记录声明使用。
当页中删除的记录达到MERGE_THRESHOLD(默认为页的50%)，InnoDB会开始寻找最靠近的页（前或后）看看是否可以将两个页合并以优化空间使用。</p>
</blockquote>
<h3 id="主键设计原则">主键设计原则</h3>
<blockquote>
<ol type="1">
<li>满足业务需求的情况下，尽量降低主键的长度。</li>
<li>插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键。</li>
<li>尽量不要使用UUID做主键或者是其他自然主键，如身份证号。</li>
</ol>
</blockquote>
<h2 id="order-by-语句优化">order by 语句优化</h2>
<h3 id="using-flesort">Using flesort</h3>
<p>通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sort
buffer中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫FileSort排序。</p>
<h3 id="using-index">Using index</h3>
<p>通过有序索引顺序扫描直接返回有序数据，这种情况即为using
index，不需要额外排序，操作效率高。</p>
<h3 id="优化原则">优化原则</h3>
<blockquote>
<ol type="1">
<li>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。</li>
<li>尽量使用覆盖索引。</li>
<li>多字段排序,一个升序一个降序，此时需要注意联合索引在创建时的规则(ASC/DESC)。</li>
<li>如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小
sort_buffer_size(默认256k)。</li>
</ol>
</blockquote>
<h2 id="group-by-语句优化">group by 语句优化</h2>
<h3 id="优化原则-1">优化原则</h3>
<blockquote>
<ol type="1">
<li>在分组操作时，可以通过索引来提高效率。</li>
<li>分组操作时，索引的使用也是满足最左前缀法则的。</li>
</ol>
</blockquote>
<h2 id="limit-语句优化">limit 语句优化</h2>
<p><strong>一个常见又非常头疼的问题就是limit
20000000,10，此时需要MySQL排序前2000010记录，仅仅返回2000000 -
2000010的记录，其他记录丢弃，查询排序的代价非常大。</strong></p>
<h3 id="优化原则-2">优化原则</h3>
<p>一般分页查询时，通过创建覆盖索引能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化。</p>
<h2 id="count-语句优化">count 语句优化</h2>
<p>MylSAM引擎把二个表的总行数存在了磁盘上，因此执行count(*)的时候会直接返回这个数，效率很高
InnoDB引擎就麻烦了，它执行count(*)的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数</p>
<h3 id="优化原则自己计数">优化原则：自己计数</h3>
<blockquote>
<ol type="1">
<li>count (主键)
InnoDB引擎会遍历整张表，把每一行的主键id值都取出来，返回给服务层。服务层拿到主键后，直接按行进行累加(主键不可能为null)</li>
<li>count (字段) 没有not null约束:
InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断，不为null，计数累加。有not
null约束:
InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加。</li>
<li>count (1)
InnoDB引擎遍历整张表，但不取值。服务层对于返回的每一行，放一个数字“1”进去，直接按行进行累加。</li>
<li>count (*)
lnnoDB引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加。</li>
</ol>
</blockquote>
<p><strong>按照效率排序的话，count(字段):xcount(主键id)&lt; count(1) =
count(<em>)，所以尽量使用count(</em>)。</strong></p>
<h2 id="update-语句优化避免行级锁变为表级锁">update
语句优化(避免行级锁变为表级锁)</h2>
<h3 id="优化原则-3">优化原则</h3>
<p>InnoDB的行锁是针对索引加的锁，不是针对记录加的锁,并且该索引不能失效，否则会从行锁升级为表锁。</p>
<h1 id="mysql优化总结">MySQL优化总结</h1>
<h3 id="插入数据">插入数据</h3>
<p>insert:批量插入、手动控制事务、主键顺序插入 大批量插入: load data
local infile</p>
<h3 id="主键优化-1">主键优化</h3>
<p>主键长度尽量短、顺序插入 AUTO_INCREMENT <del>UUID</del></p>
<h3 id="order-by优化">order by优化</h3>
<p>using index:直接通过索引返回数据，性能高 using
filesort:需要将返回的结果在排序缓冲区排序</p>
<h3 id="group-by优化">group by优化</h3>
<p>索引，多字段分组满足最左前缀法则</p>
<h3 id="limit优化">limit优化</h3>
<p>覆盖索引+子查询</p>
<h3 id="count优化">count优化</h3>
<p>性能: count(字段) &lt; count(主键id) &lt; count(1) &lt; count(*)</p>
<h3 id="update优化">update优化</h3>
<p>尽量根据主键/索引字段进行数据更新</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL04-索引03-使用规则</title>
    <url>/posts/10406.html</url>
    <content><![CDATA[<p>详细的描述了MySQL中的索引的使用规则和设计原则。 <span id="more"></span></p>
<h1 id="使用规则">使用规则</h1>
<h2 id="联合索引">联合索引</h2>
<h3 id="最左前缀法则">最左前缀法则</h3>
<blockquote>
<p>如果索引了多列(联合索引)，要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，索引将部分失效(后面的字段索引失效)。</p>
</blockquote>
<h3 id="范围查询">范围查询</h3>
<blockquote>
<p>联合索引中，出现范围查询(&gt;,&lt;)，范围查询右侧的列索引失效</p>
</blockquote>
<h2 id="索引失效">索引失效</h2>
<h3 id="索引列运算">索引列运算</h3>
<blockquote>
<p>不要在索引列上进行运算操作,索引将失效。</p>
</blockquote>
<h3 id="字符串不加引号">字符串不加引号</h3>
<blockquote>
<p>字符串类型字段使用时，不加引号，索引将失效。会在内部自动进行隐式类型转换。</p>
</blockquote>
<h3 id="模糊查询">模糊查询</h3>
<blockquote>
<p>如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。</p>
</blockquote>
<p>### or连接的条件</p>
<blockquote>
<p>用or分割开的条件，如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。</p>
<p>解决办法：针对另一个数据列也建立索引即可</p>
</blockquote>
<h3 id="数据分布影响">数据分布影响</h3>
<blockquote>
<p>如果MysQL评估使用索引比全表更慢，则不使用索引。</p>
</blockquote>
<h2 id="sql提示">SQL提示</h2>
<h3 id="sql提示-1">SQL提示</h3>
<blockquote>
<p>SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。</p>
<p>放在where条件前，use/ignore/force index(索引名)</p>
<p>use index: 建议使用索引，数据库可以选择不使用</p>
<p>ignore index: 忽略某个索引</p>
<p>force index: 强制使用某个索引</p>
</blockquote>
<h2 id="覆盖索引">覆盖索引</h2>
<h3 id="覆盖索引-1">覆盖索引</h3>
<blockquote>
<p>尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到)，减少select
*。</p>
<p>尽量避免回表查询</p>
<p>extra中： using index condition :查找使用了索引,但是需要回表查询数据
using where; using
index:查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据</p>
</blockquote>
<h2 id="前缀索引">前缀索引</h2>
<h3 id="前缀索引-1">前缀索引</h3>
<blockquote>
<p>当字段类型为字符串(varchar,
text等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率。此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。</p>
<p>语法： create index idx_xxx on table_name(column(n)) ; - -
n为前缀长度</p>
<p>前缀长度的选择：
可以根据索引的选择性来决定，选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，
唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。
可以使用聚合函数查询选择性 select count(distinct substring(xxx,1,5))/
count(*) from table ; - - 即长度为5的选择性</p>
</blockquote>
<h2 id="单列联合索引">单列/联合索引</h2>
<h3 id="单列索引与联合索引">单列索引与联合索引</h3>
<blockquote>
<p>单列索引:即一个索引只包含单个列。</p>
<p>联合索引:即一个索引包含了多个列。</p>
<p>在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。</p>
<p>多条件联合查询时，MySQL优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询。</p>
</blockquote>
<h1
id="索引设计原则总结自黑马程序员侵删">索引设计原则（总结自黑马程序员，侵删）</h1>
<h3 id="索引设计原则">索引设计原则</h3>
<blockquote>
<ol type="1">
<li>针对于数据量较大，且查询比较频繁的表建立索引。</li>
<li>针对于常作为查询条件（where)、排序(order by)、分组(group
by)操作的字段建立索引。</li>
<li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。</li>
<li>如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。</li>
<li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。</li>
<li>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。</li>
<li>如果索引列不能存储NULL值，请在创建表时使用NOT
NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL07-存储函数</title>
    <url>/posts/10409.html</url>
    <content><![CDATA[<p>详细的描述了MySQL中的存储函数。 <span id="more"></span></p>
<h1 id="存储函数">存储函数</h1>
<p>存储函数是有返回值的存储过程，存储函数的参数只能是IN类型的。</p>
<h2 id="语法">语法</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE FUNCTION 存储函数名称([参数列表])</span><br><span class="line">RETURNS type [characteristic ...]</span><br><span class="line">BEGIN</span><br><span class="line">	--SQL语句</span><br><span class="line">	RETURN ...;</span><br><span class="line">END;</span><br><span class="line"></span><br><span class="line">characteristic说明:</span><br><span class="line"> + DETERMINISTIC:相同的输入参数总是产生相同的结果</span><br><span class="line"> + NO SQL:不包含SQL语句。</span><br><span class="line"> + READS SQL DATA:包含读取数据的语句，但不包含写入数据的语句。</span><br></pre></td></tr></table></figure>
<h2 id="样例">样例</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 存储函数</span><br><span class="line">-- 计算从1到n的累加</span><br><span class="line">create function fun1(n int)</span><br><span class="line">returns int deterministic </span><br><span class="line">begin</span><br><span class="line">    declare total int default 0;</span><br><span class="line"></span><br><span class="line">    while n &gt; 0 do</span><br><span class="line">        set total := total + n;</span><br><span class="line">        set n := n - 1;</span><br><span class="line">    end while;</span><br><span class="line"></span><br><span class="line">    return total;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">select fun1(100);</span><br></pre></td></tr></table></figure>
<p><strong>注意当未添加 deterministic 会产生如下bug：</strong></p>
<figure>
<img
src="https://wang-nine.cn/images/MySQL06-01%E6%9C%AA%E6%8C%87%E5%AE%9A%E5%8F%82%E6%95%B0%E6%80%A7%E8%B4%A8%E7%9A%84bug.png"
alt="MySQL06-01未指定参数性质的bug" />
<figcaption
aria-hidden="true">MySQL06-01未指定参数性质的bug</figcaption>
</figure>
<p>运行结果：</p>
<figure>
<img
src="https://wang-nine.cn/images/MySQL06-02%E5%AD%98%E5%82%A8%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png"
alt="MySQL06-02存储函数的运行结果" />
<figcaption aria-hidden="true">MySQL06-02存储函数的运行结果</figcaption>
</figure>
<h1 id="注意">注意</h1>
<p><strong>存储函数必须要有返回值，而且参数只能是输入类型的参数，其过程实现完全可以被存储过程所代替。</strong></p>
<p><strong>因此存储函数的使用较少，这里仅做了解。</strong></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL09-视图</title>
    <url>/posts/10411.html</url>
    <content><![CDATA[<p>详细的描述了MySQL中的视图。 <span id="more"></span></p>
<h1 id="视图的简介">视图的简介</h1>
<p>视图(View)是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。
​通俗的讲，视图只保存了查询的SQL逻辑，不保存查询结果。所以我们在创建视图的时候，主要的工作在创建这条SQL查询语句上。</p>
<h1 id="视图的语法">视图的语法</h1>
<h2 id="创建">创建</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE [OR REPLACE] VIEW 视图名称 [(列名列表)] AS SELECT 语句[WITH[CASCADED|LOCAL] CHECK OPTION ]</span><br></pre></td></tr></table></figure>
<h2 id="查询">查询</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW CREATE VIEW 视图名称; --查看创建视图语句</span><br><span class="line">SELECT * FROM 视图名称.......; --查看视图数据</span><br></pre></td></tr></table></figure>
<h2 id="修改">修改</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 方式一</span><br><span class="line">CREATE [OR REPLACE] VIEW 视图名称(列名列表)] AS SELECT语句 [WITH[CASCADED|LOCAL] CHECK OPTION]</span><br><span class="line">-- 方式二</span><br><span class="line">ALTER VIEW 视图名称(列名列表)] AS SELECT语句 [WITH[CASCADED|LOCAL] CHECK OPTION]</span><br></pre></td></tr></table></figure>
<h2 id="删除">删除</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP VIEW [IF EXISTS] 视图名称[视图名称] ...</span><br></pre></td></tr></table></figure>
<h1 id="视图的检查选项">视图的检查选项</h1>
<blockquote>
<p>​ 当使用 WITH CHECK OPTION
子句创建视图时，My5QL会通过视图检查正在更改的每个行，例如插入，更新，删除，以使其符合视图的定义。</p>
<p>​
MySQL允许基于另一个视图创建视图，它还会检查依赖视图中的规则以保持一致性。为了确定检查的范围，mysql
提供了两个选项: CASCADED和LOCAL，默认值为CASCADED。</p>
</blockquote>
<h2 id="cascaded">cascaded</h2>
<figure>
<img src="https://wang-nine.cn/images/MySQL08-01cascaded.png"
alt="MySQL08-01cascaded" />
<figcaption aria-hidden="true">MySQL08-01cascaded</figcaption>
</figure>
<h2 id="local">local</h2>
<figure>
<img src="https://wang-nine.cn/images/MySQL08-02local.png"
alt="MySQL08-02local" />
<figcaption aria-hidden="true">MySQL08-02local</figcaption>
</figure>
<h1 id="视图的更新">视图的更新</h1>
<p>要使视图可更新，视图中的行与基础表中的行之间必须存在一对一的关系。如果视图包含以下任何一项，则该视图不可更新:
1. 聚合函数或窗口函数(SUM()、MIN()、MAX()、COUNT()等) 2. DISTINCT 3.
GROUP BY 4. HAVING 5. UNION 或者 UNION ALL</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL10-锁</title>
    <url>/posts/10412.html</url>
    <content><![CDATA[<p>详细的描述了MySQL中的锁。 <span id="more"></span></p>
<h1 id="概述">概述</h1>
<p>锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源(CPU、RAM、I/O)的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p>
<h1 id="全局锁">全局锁</h1>
<p>全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。
==其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性==</p>
<figure>
<img
src="https://wang-nine.cn/images/MySQL09-01%E5%85%A8%E5%B1%80%E9%94%81.png"
alt="MySQL09-01全局锁" />
<figcaption aria-hidden="true">MySQL09-01全局锁</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flush tables with read lock; -- 加全局锁</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldump [-h192.168.xxx.xxx] -uroot -p123456 databasename &gt; D:/xxx.sql  //数据备份 访问远程加 -h</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unlock table; -- 释放锁</span><br></pre></td></tr></table></figure>
<p>==数据库中加全局锁，是一个比较重的操作，存在以下问题:==</p>
<ol type="1">
<li>如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。</li>
<li>如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog)，会导致主从延迟。</li>
</ol>
<p>在InnoDB引擎中，我们可以在备份时加上参数--single-transaction
参数来完成不加锁的一致性数据备份。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqldump --single-transaction -uroot-p123456 Wang &gt; Wang.sql</span><br></pre></td></tr></table></figure>
<h1 id="表级锁">表级锁</h1>
<pre><code>表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中。</code></pre>
<p>对于表级锁，主要分为以下三类： 1. 表锁 2. 元数据锁（meta
datallock，MDL) 3. 意向锁</p>
<h2 id="表锁">表锁</h2>
<ol type="1">
<li>表共享读锁（read lock）</li>
<li>表独占写锁（wirte lock）</li>
</ol>
<h3 id="语法">语法</h3>
<ol type="1">
<li><p>加锁 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lock tables 表名... read/write</span><br></pre></td></tr></table></figure></p></li>
<li><p>释放锁 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unlock tables / 客户端断开连接</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h3 id="读锁与写锁的特点">读锁与写锁的特点</h3>
<figure>
<img
src="https://wang-nine.cn/images/MySQL09-02%E8%AF%BB%E5%86%99%E9%94%81.png"
alt="MySQL09-02读锁与写锁" />
<figcaption aria-hidden="true">MySQL09-02读锁与写锁</figcaption>
</figure>
<p>==读锁不会阻塞其他客户端的读，但是会阻塞写。写锁既会阻塞其他客户端的读，又会阻塞其他客户端的写。==</p>
<h2 id="元数据锁meta-data-lock-mdl">元数据锁(meta data lock, MDL)</h2>
<p>==MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。主要作用是避免DML与DDL冲突，保证读写的正确性。==</p>
<p>在MySQL5.5中引入了MDL，当对一张表进行增删改查的时候，加MDL读锁(共享);当对表结构进行变更操作的时候，加MDL写锁(排他)。</p>
<table>
<colgroup>
<col style="width: 34%" />
<col style="width: 29%" />
<col style="width: 36%" />
</colgroup>
<thead>
<tr class="header">
<th>对于SQL</th>
<th>锁类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>lock tables xxx read / write</td>
<td>SHARED_READ_ONLY / SHARED_NO_READ_WRITE</td>
<td>/</td>
</tr>
<tr class="even">
<td>select . select ... lock in share mode</td>
<td>SHARE_READ</td>
<td>与SHARED_READ、SHARED_WRITE兼容，与EXCLUSIVE互斥</td>
</tr>
<tr class="odd">
<td>insert . update、delete、select ... for update</td>
<td>SHARED_WRITE</td>
<td>与SHARED_READ、SHARED_WRITE兼容,与EXCLUSIVE互斥</td>
</tr>
<tr class="even">
<td>alter table ...</td>
<td>EXCLUSIVE</td>
<td>与其他的MDL都互斥</td>
</tr>
</tbody>
</table>
<p>查看元数据锁 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select object type,object schema,object_name,lock_type,lock_ duration from performance schema.metadata loacks;</span><br></pre></td></tr></table></figure></p>
<h2 id="意向锁">意向锁</h2>
<p>为了避免 DML
在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。</p>
<h3 id="意向共享锁is">意向共享锁(IS)</h3>
<p>==电语句select ... lock in share mode添加。==</p>
<p>和与表锁共享锁(read)兼容，与表锁排它锁(write）互斥。</p>
<h3 id="意向排他锁ix">意向排他锁(IX)︰</h3>
<p>==由insert、update、delete、select ... for update添加。==</p>
<p>与表锁共享锁(read)及排它锁(write)都互斥。意向锁之间不会互斥。</p>
<h3 id="查看意向锁和行锁加锁情况">查看意向锁和行锁加锁情况</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select object schema,object_name,index_name,lock_type.lock mode,Jock_data from performance schema.data_locks;</span><br></pre></td></tr></table></figure>
<h1 id="行级锁">行级锁</h1>
<p>行级锁，每次操作锁住对应的行数据，锁定粒度最小，发生锁冲突的概率最低，并发度最高，应用在InnoDB引擎中。</p>
<p>InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁。对于行级锁，主要分为以下三类:</p>
<h2 id="行锁record-lock">行锁(Record Lock)</h2>
<p>锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC、RR隔离级别下都支持。</p>
<p>nnoDB实现了以下两种类型的行锁</p>
<h3 id="共享锁s">共享锁(S)</h3>
<p>允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。</p>
<h3 id="排他锁x">排他锁(X)</h3>
<p>允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。</p>
<h3 id="兼容情况">兼容情况</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">锁类型</th>
<th style="text-align: center;">S(共享锁)</th>
<th style="text-align: center;">X(排它锁)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">S(共享锁)</td>
<td style="text-align: center;">兼容</td>
<td style="text-align: center;">冲突</td>
</tr>
<tr class="even">
<td style="text-align: center;">X(排它锁)</td>
<td style="text-align: center;">冲突</td>
<td style="text-align: center;">冲突</td>
</tr>
</tbody>
</table>
<h3 id="加锁情况">加锁情况</h3>
<table>
<colgroup>
<col style="width: 35%" />
<col style="width: 14%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">SQL</th>
<th style="text-align: center;">行锁类型</th>
<th style="text-align: center;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">INSERT ...</td>
<td style="text-align: center;">排他锁</td>
<td style="text-align: center;">自动加锁</td>
</tr>
<tr class="even">
<td style="text-align: left;">UPDATE ...</td>
<td style="text-align: center;">排他锁</td>
<td style="text-align: center;">自动加锁</td>
</tr>
<tr class="odd">
<td style="text-align: left;">DELETE ...</td>
<td style="text-align: center;">排他锁</td>
<td style="text-align: center;">自动加锁</td>
</tr>
<tr class="even">
<td style="text-align: left;">SELECT(正常)</td>
<td style="text-align: center;">不加任何锁</td>
<td style="text-align: center;">/</td>
</tr>
<tr class="odd">
<td style="text-align: left;">SELECT ... LOCK IN SHARE MODE</td>
<td style="text-align: center;">共享锁</td>
<td style="text-align: center;">需要手动在SELECT之后加LOCK IN SHARE
MODE</td>
</tr>
<tr class="even">
<td style="text-align: left;">SELECT ... FOR UPDATE</td>
<td style="text-align: center;">排他锁</td>
<td style="text-align: center;">需要手动在SELECT之后加FOR UPDATE</td>
</tr>
</tbody>
</table>
<h3 id="行锁的注意事项">行锁的注意事项</h3>
<p>默认情况下，InnoDB在REPEATABLE
READ事务隔离级别运行，InnoDB使用next-key锁进行搜索和索引扫描，以防止幻读。</p>
<ul>
<li>针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。</li>
<li>InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时就会升级为表锁。</li>
</ul>
<h3 id="查看意向锁和行锁加锁情况-1">查看意向锁和行锁加锁情况</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select object schema,object_name,index_name,lock_type.lock mode,Jock_data from performance schema.data_locks;</span><br></pre></td></tr></table></figure>
<h2 id="间隙锁gap-lock与临键锁next-key-lock">间隙锁(Gap
Lock)与临键锁(Next-Key Lock)</h2>
<p>锁定索引记录间隙（不含该记录)，确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RRP隔离级别下都支持。</p>
<p>行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持。</p>
<p>默认情况下，InnoDB 在 REPEATABLE
READ事务隔离级别运行，InnoDB使用next-key锁进行搜索和索引扫描，以防止幻读。</p>
<ol type="1">
<li>索引上的等值查询(唯一索引)，给不存在的记录加锁时,优化为间隙锁。</li>
<li>索引上的等值查询(普通索引)，向右遍历时最后一个值不满足查询需求时，next-key
lock退化为间隙锁。</li>
<li>索引上的范围查询(唯一索引) --
会访问到不满足条件的第一个值为止。</li>
</ol>
<p>==注意：间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。==</p>
<h2 id="乐观锁与悲观锁">乐观锁与悲观锁</h2>
<p>乐观锁：（Optimistic
Locking）认为对同一数据的并发操作不会总发生，属于小概率事件，不用每次都对数据上锁，也就是不采用数据库自身的锁机制，而是通过程序来实现。在程序上，我们可以采用版本号机制或者时间戳机制实现。（在程序上进行实现）</p>
<ul>
<li>版本号机制： 设计一个版本字段 version，第一次读的时候，会获取
version
字段的取值。然后对数据进行更新或删除操作时，会执行<code>UPDATE ... SET version=version+1 WHERE version=version</code>。此时如果已经有事务对这条数据进行了更改，修改就不会成功。
（先获取一个版本号，在后续进行更新删除操作时，确认版本号是否正确）</li>
<li>时间戳机制：与版本号机制一样，只不过这里叫做时间戳</li>
</ul>
<p>悲观锁：认为会出现并发操作，使用数据库本身的锁机制</p>
<p>这里可以看到基本的使用场景：</p>
<ol type="1">
<li>乐观锁适合读操作比较多的场景</li>
<li>悲观锁适合写操作比较多的场景</li>
</ol>
<p>解决死锁：乐观锁（治标不治本），MyISAM储存引擎，一次获取所有锁，就不会死锁，大粒度锁；</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL11-InnoDB引擎01-架构</title>
    <url>/posts/10413.html</url>
    <content><![CDATA[<p>详细的描述了MySQL中的InnoDB引擎的架构。 <span id="more"></span></p>
<h1 id="逻辑存储结构">逻辑存储结构</h1>
<figure>
<img
src="https://wang-nine.cn/images/MySQL10-01%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png"
alt="MySQL10-01逻辑存储结构" />
<figcaption aria-hidden="true">MySQL10-01逻辑存储结构</figcaption>
</figure>
<h1 id="架构">架构</h1>
<h2 id="总架构">总架构</h2>
<figure>
<img
src="https://wang-nine.cn/images/MySQL10-02%E6%80%BB%E6%9E%B6%E6%9E%84.png"
alt="MySQL10-02总架构" />
<figcaption aria-hidden="true">MySQL10-02总架构</figcaption>
</figure>
<h2 id="内存结构">内存结构</h2>
<h3 id="缓冲池">缓冲池</h3>
<figure>
<img
src="https://wang-nine.cn/images/MySQL10-03-01%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png"
alt="MySQL10-03-01内存结构" />
<figcaption aria-hidden="true">MySQL10-03-01内存结构</figcaption>
</figure>
<h3 id="更改缓冲区">更改缓冲区</h3>
<figure>
<img
src="https://wang-nine.cn/images/MySQL10-03-02%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png"
alt="MySQL10-03-02内存结构" />
<figcaption aria-hidden="true">MySQL10-03-02内存结构</figcaption>
</figure>
<h3 id="自适应哈希">自适应哈希</h3>
<figure>
<img
src="https://wang-nine.cn/images/MySQL10-03-03%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png"
alt="MySQL10-03-03内存结构" />
<figcaption aria-hidden="true">MySQL10-03-03内存结构</figcaption>
</figure>
<h3 id="日志缓冲区">日志缓冲区</h3>
<figure>
<img
src="https://wang-nine.cn/images/MySQL10-03-04%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png"
alt="MySQL10-03-04内存结构" />
<figcaption aria-hidden="true">MySQL10-03-04内存结构</figcaption>
</figure>
<h2 id="磁盘结构">磁盘结构</h2>
<h3 id="系统表空间与单个表文件空间">系统表空间与单个表文件空间</h3>
<figure>
<img
src="https://wang-nine.cn/images/MySQL10-04-01%E7%A3%81%E7%9B%98%E7%BB%93%E6%9E%84.png"
alt="MySQL10-04-01磁盘结构" />
<figcaption aria-hidden="true">MySQL10-04-01磁盘结构</figcaption>
</figure>
<h3
id="通用表空间与撤销表空间与临时表空间">通用表空间与撤销表空间与临时表空间</h3>
<figure>
<img
src="https://wang-nine.cn/images/MySQL10-04-02%E7%A3%81%E7%9B%98%E7%BB%93%E6%9E%84.png"
alt="MySQL10-04-02磁盘结构" />
<figcaption aria-hidden="true">MySQL10-04-02磁盘结构</figcaption>
</figure>
<h3 id="双写缓冲区与重做日志">双写缓冲区与重做日志</h3>
<figure>
<img
src="https://wang-nine.cn/images/MySQL10-04-03%E7%A3%81%E7%9B%98%E7%BB%93%E6%9E%84.png"
alt="MySQL10-04-03磁盘结构" />
<figcaption aria-hidden="true">MySQL10-04-03磁盘结构</figcaption>
</figure>
<h2 id="后台线程">后台线程</h2>
<figure>
<img
src="https://wang-nine.cn/images/MySQL10-05%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B.png"
alt="MySQL10-05后台线程" />
<figcaption aria-hidden="true">MySQL10-05后台线程</figcaption>
</figure>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL08-触发器</title>
    <url>/posts/10410.html</url>
    <content><![CDATA[<p>详细的描述了MySQL中的触发器。 <span id="more"></span></p>
<h1 id="触发器简介">触发器简介</h1>
<h2 id="简介">简介</h2>
<p>​ 触发器是与表有关的数据库对象，指在 insert / update / delete
之前或之后，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性，日志记录，数据校验等操作。
​使用别名 OLD 和 NEW
来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。</p>
<p>​ 现在触发器还只支持行级触发（影响几行触发几次）</p>
<p>​ 现在触发器不支持语句级触发（执行一条语句触发一次）</p>
<table>
<colgroup>
<col style="width: 21%" />
<col style="width: 78%" />
</colgroup>
<thead>
<tr class="header">
<th>触发器类型</th>
<th>NEW 和 OLD</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>INSERT触发器</td>
<td>NEW表示将要或者已经新增的数据</td>
</tr>
<tr class="even">
<td>UPDATE型触发器</td>
<td>OLD表示修改之前的数据，NEW表示将要或已经修改后的数据</td>
</tr>
<tr class="odd">
<td>DELETE型触发器</td>
<td>OLD表示将要或者已经删除的数据</td>
</tr>
</tbody>
</table>
<h2 id="语法">语法</h2>
<h3 id="创建">创建</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TRIGGER trigger_name</span><br><span class="line">BEFORE/AFTER INSERT/UPDATE/DELETE</span><br><span class="line">ON tbl_name FOR EACH ROW --行级触发器</span><br><span class="line">BEGIN</span><br><span class="line">	trigger_stmt;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>
<h3 id="查看">查看</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW TRIGGERS;</span><br></pre></td></tr></table></figure>
<h3 id="删除">删除</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TRIGGER [schema_name.]Jtrigger_name; --如果没有指定schema_name，默认为当前数据库。</span><br></pre></td></tr></table></figure>
<h3 id="insert-类型触发器样例">INSERT 类型触发器样例</h3>
<p>样例：</p>
<p>通过触发器记录 tb_user
表的数据变更日志，将变更日志插入到日志表user_logs中，包含增加，修改，删除；、、</p>
<p>建表语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table user_logs(</span><br><span class="line">  id int(11) not null auto_increment,</span><br><span class="line">  operation varchar(20) not null comment &#x27;操作类型, insert/update/delete&#x27;,</span><br><span class="line">  operate_time datetime not null comment &#x27;操作时间&#x27;,</span><br><span class="line">  operate_id int(11) not null comment &#x27;操作的ID&#x27;,</span><br><span class="line">  operate_params varchar(500) comment &#x27;操作参数&#x27;,</span><br><span class="line">  primary key(`id`)</span><br><span class="line">)engine=innodb default charset=utf8;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 插入数据时的触发器</span><br><span class="line">create trigger tb_user_insert_trigger</span><br><span class="line">    after insert on tb_user for each row</span><br><span class="line">begin</span><br><span class="line">    insert into user_logs(id, operation, operate_time, operate_id, operate_params) values</span><br><span class="line">    (null, &#x27;insert&#x27;, now(), new.id, concat(&#x27;插入的数据内容为: id = &#x27;, new.id, &#x27; name = &#x27;, new.name, &#x27; phone = &#x27;, new.phone),</span><br><span class="line">     &#x27; email = &#x27;, new.email, &#x27; profession = &#x27;, new.profession);</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">-- 查看触发器指令</span><br><span class="line">show triggers;</span><br><span class="line"></span><br><span class="line">-- 插入数据</span><br><span class="line">insert into tb_user(id, name, phone, email, profession, age, gender, status, createtime)</span><br><span class="line">values (25,&#x27;Wang&#x27;,&#x27;99999999999&#x27;,&#x27;wang-nine@gmail.com&#x27;,&#x27;计科&#x27;,19,&#x27;1&#x27;,&#x27;1&#x27;,now());</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure>
<img
src="https://wang-nine.cn/images/MySQL07-01%E6%9F%A5%E7%9C%8B%E8%A7%A6%E5%8F%91%E5%99%A8.png"
alt="MySQL07-01查看触发器" />
<figcaption aria-hidden="true">MySQL07-01查看触发器</figcaption>
</figure>
<figure>
<img
src="https://wang-nine.cn/images/MySQL07-02insert%E8%A7%A6%E5%8F%91%E5%99%A8.png"
alt="MySQL07-02insert触发器" />
<figcaption aria-hidden="true">MySQL07-02insert触发器</figcaption>
</figure>
<h3 id="update-类型触发器样例">UPDATE 类型触发器样例</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 更新数据时的触发器</span><br><span class="line">create trigger tb_user_update_trigger</span><br><span class="line">    after update on tb_user for each row</span><br><span class="line">begin</span><br><span class="line">    insert into user_logs(id, operation, operate_time, operate_id, operate_params) values</span><br><span class="line">    (null, &#x27;update&#x27;, now(), new.id,</span><br><span class="line">     concat(&#x27;更新前的数据内容为: id = &#x27;, old.id, &#x27; name = &#x27;, old.name, &#x27; phone = &#x27;, old.phone,&#x27; email = &#x27;, old.email, &#x27; profession = &#x27;, old.profession,</span><br><span class="line">     &#x27;更新前的数据内容为: id = &#x27;, new.id, &#x27; name = &#x27;, new.name, &#x27; phone = &#x27;, new.phone,&#x27; email = &#x27;, new.email, &#x27; profession = &#x27;, new.profession));</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">-- 查看触发器指令</span><br><span class="line">show triggers;</span><br><span class="line"></span><br><span class="line">-- 更新数据</span><br><span class="line">update tb_user set age = 99 where id = 25;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure>
<img
src="https://wang-nine.cn/images/MySQL07-03%E6%9F%A5%E7%9C%8B%E8%A7%A6%E5%8F%91%E5%99%A8.png"
alt="MySQL07-03查看触发器" />
<figcaption aria-hidden="true">MySQL07-03查看触发器</figcaption>
</figure>
<figure>
<img
src="https://wang-nine.cn/images/MySQL07-04update%E8%A7%A6%E5%8F%91%E5%99%A8.png"
alt="MySQL07-04update触发器" />
<figcaption aria-hidden="true">MySQL07-04update触发器</figcaption>
</figure>
<h3 id="delete-类型触发器样例">DELETE 类型触发器样例</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 删除数据时的触发器</span><br><span class="line">create trigger tb_user_delete_trigger</span><br><span class="line">    after delete on tb_user for each row</span><br><span class="line">begin</span><br><span class="line">    insert into user_logs(id, operation, operate_time, operate_id, operate_params) values</span><br><span class="line">    (null, &#x27;delete&#x27;, now(), old.id, concat(&#x27;插入的数据内容为: id = &#x27;, old.id, &#x27; name = &#x27;, old.name, &#x27; phone = &#x27;, old.phone,</span><br><span class="line">     &#x27; email = &#x27;, old.email, &#x27; profession = &#x27;, old.profession));</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">-- 查看触发器指令</span><br><span class="line">show triggers;</span><br><span class="line"></span><br><span class="line">-- 删除数据</span><br><span class="line">delete from tb_user where id = 25;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure>
<img
src="https://wang-nine.cn/images/MySQL07-05%E6%9F%A5%E7%9C%8B%E8%A7%A6%E5%8F%91%E5%99%A8.png"
alt="MySQL07-05查看触发器" />
<figcaption aria-hidden="true">MySQL07-05查看触发器</figcaption>
</figure>
<figure>
<img
src="https://wang-nine.cn/images/MySQL07-06delete%E8%A7%A6%E5%8F%91%E5%99%A8.png"
alt="MySQL07-06delete触发器" />
<figcaption aria-hidden="true">MySQL07-06delete触发器</figcaption>
</figure>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL11-InnoDB引擎02-事务原理</title>
    <url>/posts/10414.html</url>
    <content><![CDATA[<p>详细的描述了MySQL中的InnoDB引擎的事务原理。 <span id="more"></span></p>
<h1 id="事务回顾">事务回顾</h1>
<h2 id="事务">事务</h2>
<ul>
<li>事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</li>
</ul>
<h2 id="特性">特性</h2>
<ul>
<li>原子性(Atomicity):事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</li>
<li>一致性(Consistency)
:事务完成时，必须使所有的数据都保持一致状态。</li>
<li>隔离性(lsolation)∶数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</li>
<li>持久性(Durability):事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li>
</ul>
<h1 id="事务原理">事务原理</h1>
<figure>
<img
src="https://wang-nine.cn/images/MySQL10-06%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86.png"
alt="MySQL10-06事务原理" />
<figcaption aria-hidden="true">MySQL10-06事务原理</figcaption>
</figure>
<h2 id="redolog一致性">redolog(一致性)</h2>
<blockquote>
<p>重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性。
该日志文件由两部分组成:重做日志缓冲(redo log
buffer)以及重做日志文件(redo log file)
,前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中，用于在刷新脏页到磁盘,发生错误时,进行数据恢复使用。</p>
</blockquote>
<h2 id="undolog原子性">undolog(原子性)</h2>
<blockquote>
<p>回滚日志，用于记录数据被修改前的信息，作用包含两个:提供回滚和MVCC(多版本并发控制)。
undo log和redo
log记录物理日志不一样，它是逻辑日志。可以认为当delete一条记录时,undo
log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。当执行rollback时，就可以从undo
log中的逻辑记录读取到相应的内容并进行回滚。</p>
<p>Undo log销毁: undo
log在事务执行时产生，事务提交时，并不会立即删除undo
log，因为这些日志可能还用于MVCC。</p>
<p>Undo log存储: undo log采用段的方式进行管理和记录，存放在前面介绍的
rollback segment回滚段中，内部包含1024个undo log segment。</p>
</blockquote>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis01-基础</title>
    <url>/posts/10701.html</url>
    <content><![CDATA[<h1 id="nosql">NoSQL</h1>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 45%" />
<col style="width: 48%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>SQL</th>
<th>NoSQL</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>数据结构</td>
<td>结构化(Structured)</td>
<td>非结构化</td>
</tr>
<tr class="even">
<td>数据关联</td>
<td>关联的(Relational)</td>
<td>无关联的</td>
</tr>
<tr class="odd">
<td>查询方式</td>
<td>SQL查询</td>
<td>非SQL</td>
</tr>
<tr class="even">
<td>事务特性</td>
<td>事务ACID</td>
<td>BASE</td>
</tr>
<tr class="odd">
<td>存储方式</td>
<td>磁盘</td>
<td>内存</td>
</tr>
<tr class="even">
<td>扩展性</td>
<td>垂直</td>
<td>水平</td>
</tr>
<tr class="odd">
<td>使用场景</td>
<td>1）数据结构固定<br>2）相关业务对数据安全性、—致性要求较高</td>
<td>1）数据结构不固定<br>2）对—致性、安全性要求不高<br>3）对性能要求高</td>
</tr>
</tbody>
</table>
<h1 id="redis">Redis</h1>
<p>Redis诞生于2009年全称是Remote Dictionary
Server，远程词典服务器，是一个基于内存的键值型NoSQL数据库。</p>
<p>特征:</p>
<ul>
<li>键值（ key-value）型，value支持多种不同数据结构，功能丰富</li>
<li>单线程，每个命令具备原子性</li>
<li>低延迟，速度快（基于内存、IO多路复用、良好的编码）</li>
<li>支持数据持久化</li>
<li>支持主从集群、分片集群</li>
<li>支持多语言客户端</li>
</ul>
<h1 id="安装与启动">安装与启动</h1>
<p>启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-server redis.conf</span><br></pre></td></tr></table></figure>
<p>查看</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -ef | grep redis</span><br></pre></td></tr></table></figure>
<p>开机自启</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/systemd/system/redis.service</span><br></pre></td></tr></table></figure>
<p>内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=redis-server</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/usr/loca/bin/redis-server /usr/local/src/redis-6.2.6/redis.conf</span><br><span class="line">PrivateTmp=true</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
<p>重载服务器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure>
<p>启动redis</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start redis</span><br></pre></td></tr></table></figure>
<p>查看redis状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl status redis</span><br></pre></td></tr></table></figure>
<p>关闭redis</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop redis</span><br></pre></td></tr></table></figure>
<p>设置开机自启</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable redis</span><br></pre></td></tr></table></figure>
<h1 id="redis客户端">Redis客户端</h1>
<p>包括:</p>
<ul>
<li>命令行客户端</li>
<li>图形化桌面客户端</li>
<li>编程客户端</li>
</ul>
<h2 id="命令行客户端">命令行客户端</h2>
<p>Redis安装完成后就自带了命令行客户端: redis-cli，使用方式如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli [options] [commonds]</span><br></pre></td></tr></table></figure>
<p>其中常见的options有:</p>
<ul>
<li>-h 127.0.0.1:指定要连接的redis节点的IP地址，默认是127.0.0.1</li>
<li>-p 6379:指定要连接的redis节点的端口，默认是6379</li>
<li>-a 123321:指定redis的访问密码</li>
</ul>
<p>其中的commonds就是Redis的操作命令，例如: ping :
与redis服务端做心跳测试，服务端正常会返回 pong 不指定commond时，会进入
redis-cli 的交互控制台:</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL总览</title>
    <url>/posts/10400.html</url>
    <content><![CDATA[<h1 id="mysql01-事务">MySQL01-事务</h1>
<p><a href="https://wang-nine.cn/posts/10401.html">MySQL01-事务</a></p>
<h1 id="mysql02-存储引擎">MySQL02-存储引擎</h1>
<p><a
href="https://wang-nine.cn/posts/10402.html">MySQL02-存储引擎</a></p>
<h1 id="mysql03-索引01-结构">MySQL03-索引01-结构</h1>
<p><a
href="https://wang-nine.cn/posts/10403.html">MySQL03-索引01-结构</a></p>
<h1 id="mysql03-索引02-性能分析">MySQL03-索引02-性能分析</h1>
<p><a
href="https://wang-nine.cn/posts/10404.html">MySQL03-索引02-性能分析</a></p>
<h1 id="mysql03-索引03-使用规则">MySQL03-索引03-使用规则</h1>
<p><a
href="https://wang-nine.cn/posts/10405.html">MySQL03-索引03-使用规则</a></p>
<h1 id="mysql04-sql优化">MySQL04-SQL优化</h1>
<p><a
href="https://wang-nine.cn/posts/10406.html">MySQL04-SQL优化</a></p>
<h1 id="mysql05-存储过程">MySQL05-存储过程</h1>
<p><a
href="https://wang-nine.cn/posts/10407.html">MySQL05-存储过程</a></p>
<h1 id="mysql06-存储函数">MySQL06-存储函数</h1>
<p><a
href="https://wang-nine.cn/posts/10408.html">MySQL06-存储函数</a></p>
<h1 id="mysql07-触发器">MySQL07-触发器</h1>
<p><a
href="https://wang-nine.cn/posts/10409.html">MySQL07-触发器</a></p>
<h1 id="mysql08-视图">MySQL08-视图</h1>
<p><a href="https://wang-nine.cn/posts/10410.html">MySQL08-视图</a></p>
<h1 id="mysql09-锁">MySQL09-锁</h1>
<p><a href="https://wang-nine.cn/posts/10411.html">MySQL09-锁</a></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis02-命令</title>
    <url>/posts/10702.html</url>
    <content><![CDATA[<h1 id="redis数据结构介绍">Redis数据结构介绍</h1>
<p>Redis是一个key-value的数据库，key一般是String类型，不过value的类型多种多样:</p>
<table>
<thead>
<tr class="header">
<th>数据类型</th>
<th>样例</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>String</td>
<td>hello world</td>
<td>基本类型</td>
</tr>
<tr class="even">
<td>Hash</td>
<td>{name: "Jack",age:21}</td>
<td>基本类型</td>
</tr>
<tr class="odd">
<td>List</td>
<td>[A -&gt;B -&gt;C -&gt;C]</td>
<td>基本类型</td>
</tr>
<tr class="even">
<td>Set</td>
<td>{A，B，C}</td>
<td>基本类型</td>
</tr>
<tr class="odd">
<td>SortedSet</td>
<td>{A: 1，B:2，C:3}</td>
<td>基本类型</td>
</tr>
<tr class="even">
<td>GEO</td>
<td>{A:( 120.3, 30.5)}</td>
<td>特殊类型</td>
</tr>
<tr class="odd">
<td>BitMap</td>
<td>0110110101110101011</td>
<td>特殊类型</td>
</tr>
<tr class="even">
<td>HyperLog</td>
<td>0110110101110101011</td>
<td>特殊类型</td>
</tr>
</tbody>
</table>
<h2 id="命令文档">命令文档</h2>
<ul>
<li><p><a
href="https://redis.io/commands">Redis官网命令文档</a></p></li>
<li><p>help <span class="citation"
data-cites="xxxx">@xxxx</span></p></li>
</ul>
<h1 id="通用命令">通用命令</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">help @generic</span><br></pre></td></tr></table></figure>
<p>常用命令</p>
<table>
<colgroup>
<col style="width: 23%" />
<col style="width: 76%" />
</colgroup>
<thead>
<tr class="header">
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>KEYS pattern</td>
<td>查询符和模版的所有key（通常使用通配符模糊匹配）<br>不建议在生产环境上使用（redis单线程，执行此命令则会等待）</td>
</tr>
<tr class="even">
<td>DEL key [key …]</td>
<td>删除一个/多个指定的key</td>
</tr>
<tr class="odd">
<td>EXISTS key [key …]</td>
<td>判断key是否存在</td>
</tr>
<tr class="even">
<td>EXPIRE key seconds</td>
<td>设置一个key的存活时间</td>
</tr>
<tr class="odd">
<td>TTL key</td>
<td>查看key的剩余有效期（-1永久有效）</td>
</tr>
</tbody>
</table>
<h1 id="string">String</h1>
<p>String类型，也就是字符串类型，是Redis中最简单的存储类型。</p>
<p>其value是字符串，不过根据字符串的格式不同，又可以分为3类:</p>
<ul>
<li>string:普通字符串</li>
<li>int:整数类型，可以做自增、自减操作</li>
<li>float:浮点类型，可以做自增、自减操作</li>
</ul>
<p>不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最大空间不能超过512m</p>
<p>常见命令</p>
<table>
<colgroup>
<col style="width: 26%" />
<col style="width: 73%" />
</colgroup>
<thead>
<tr class="header">
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>SET key value</td>
<td>添加或者修改已经存在的一个String类型的键值对</td>
</tr>
<tr class="even">
<td>GET</td>
<td>根据key获取String类型的value</td>
</tr>
<tr class="odd">
<td>MSET</td>
<td>批量添加多个String类型的键值对</td>
</tr>
<tr class="even">
<td>MGET</td>
<td>根据多个key获取多个String类型的value</td>
</tr>
<tr class="odd">
<td>INCR</td>
<td>让一个整型的key自增1（自减，DECR，一般不用，自增负数即可）</td>
</tr>
<tr class="even">
<td>INCRBY</td>
<td>让一个整型的key自增并指定步长，例如: incrby num 2 让num值自增2</td>
</tr>
<tr class="odd">
<td>INCRBYFLOAT</td>
<td>让一个浮点类型的数字自增并指定步长</td>
</tr>
<tr class="even">
<td>SETNX（set not exist）</td>
<td>添加一个String类型的键值对，前提是这个key不存在，否则不执行</td>
</tr>
<tr class="odd">
<td>SETEX（set expire）</td>
<td>添加一个String类型的键值对，并且指定有效期，例如 setex name 10 jack
或者 set name jack ex 10</td>
</tr>
</tbody>
</table>
<h1 id="key的层级结构">Key的层级结构</h1>
<p>Redis没有类似MySQL中的Table的概念，我们该如何区 分不同类型的key呢?
例如，需要存储用户、商品信息到redis，有一个用户id是1，有一个商品id恰好也是1</p>
<p>Redis的key允许有多个单词形成层级结构，多个单词之间用':'隔开，格式如下:</p>
<p>项目名:业务名:类型:id</p>
<p>例如
如果Value是一个Java对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储:</p>
<table>
<thead>
<tr class="header">
<th>KEY</th>
<th>VALUE</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>wang:user:1</td>
<td>{"id":1，"name":"Jack" , "age":21}</td>
</tr>
<tr class="even">
<td>wang:product:1</td>
<td>{"id":1，"name":"小米11"，"price": 4999}</td>
</tr>
</tbody>
</table>
<h1 id="hash类型">Hash类型</h1>
<p>Hash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构</p>
<p>String结构是将对象序列化为JSON字符串后存储，当需要修改对象某个字段时很不方便:</p>
<table>
<thead>
<tr class="header">
<th>KEY</th>
<th>VALUE</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>wang:user:1</td>
<td>{name:”Jack”, age:21}</td>
</tr>
<tr class="even">
<td>wang:user:2</td>
<td>{name:”Rose”, age:18}</td>
</tr>
</tbody>
</table>
<p>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD:</p>
<table>
<thead>
<tr class="header">
<th>KEY</th>
<th>VALUE</th>
<th>VALUE</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td></td>
<td>field</td>
<td>value</td>
</tr>
<tr class="even">
<td>wang:user:1</td>
<td>name</td>
<td>Jack</td>
</tr>
<tr class="odd">
<td></td>
<td>age</td>
<td>21</td>
</tr>
<tr class="even">
<td>wang:user:2</td>
<td>name</td>
<td>Rose</td>
</tr>
<tr class="odd">
<td></td>
<td>age</td>
<td>18</td>
</tr>
</tbody>
</table>
<p>常见命令</p>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr class="header">
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>HSET key field value</td>
<td>添加或者修改hash类型key的field的值</td>
</tr>
<tr class="even">
<td>HGET key field</td>
<td>获取一个hash类型key的field的值</td>
</tr>
<tr class="odd">
<td>HMSET</td>
<td>批量添加多个hash类型key的field的值</td>
</tr>
<tr class="even">
<td>HMGET</td>
<td>批量获取多个hash类型key的field的值</td>
</tr>
<tr class="odd">
<td>HGETALL</td>
<td>获取一个hash类型的key中的所有的field和value</td>
</tr>
<tr class="even">
<td>HKEYS</td>
<td>获取一个hash类型的key中的所有的field</td>
</tr>
<tr class="odd">
<td>HVALS</td>
<td>获取一个hash类型的key中的所有的value</td>
</tr>
<tr class="even">
<td>HINCRBY</td>
<td>让一个hash类型key的字段值自增并指定步长</td>
</tr>
<tr class="odd">
<td>HSETNX</td>
<td>添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</td>
</tr>
</tbody>
</table>
<h1 id="list类型">List类型</h1>
<p>Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。</p>
<p>特征也与LinkedList类似:</p>
<ul>
<li>有序</li>
<li>元素可以重复</li>
<li>插入和删除快</li>
<li>查询速度一般</li>
</ul>
<p>常见命令</p>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 74%" />
</colgroup>
<thead>
<tr class="header">
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>LPUSH key element ...</td>
<td>向列表左侧插入一个或多个元素</td>
</tr>
<tr class="even">
<td>LPOP key</td>
<td>移除并返回列表左侧的第一个元素，没有则返回nil</td>
</tr>
<tr class="odd">
<td>RPUSH key element ...</td>
<td>向列表右侧插入一个或多个元素</td>
</tr>
<tr class="even">
<td>RPOP key</td>
<td>移除并返回列表右侧的第一个元素</td>
</tr>
<tr class="odd">
<td>LRANGE key star end</td>
<td>返回一段角标范围内的所有元素（-1为队尾）</td>
</tr>
<tr class="even">
<td>BLPOP和BRPOP</td>
<td>与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil</td>
</tr>
</tbody>
</table>
<p>如何利用List结构模拟一个栈?</p>
<ul>
<li>入口和出口在同一边</li>
</ul>
<p>如何利用List结构模拟一个队列?</p>
<ul>
<li>入口和出口在不同边</li>
</ul>
<p>如何利用List结构模拟一个阻塞队列?</p>
<ul>
<li>入口和出口在不同边</li>
<li>出队时采用BLPOP或BRPOP</li>
</ul>
<h1 id="set类型">Set类型</h1>
<p>Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，</p>
<p>因此具备与HashSet类似的特征:</p>
<ul>
<li>无序</li>
<li>元素不可重复</li>
<li>查找快</li>
<li>支持交集、并集、差集等功能</li>
</ul>
<p>常见命令</p>
<table>
<thead>
<tr class="header">
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>SADD key member ...</td>
<td>向set中添加一个或多个元素</td>
</tr>
<tr class="even">
<td>SREM key member ...</td>
<td>移除set中的指定元素</td>
</tr>
<tr class="odd">
<td>SCARD key</td>
<td>返回set中元素的个数</td>
</tr>
<tr class="even">
<td>SISMEMBER key member</td>
<td>判断一个元素是否存在于set中</td>
</tr>
<tr class="odd">
<td>SMEMBERS</td>
<td>获取set中的所有元素</td>
</tr>
<tr class="even">
<td>SINTER key1 key2 …</td>
<td>求key1和key2的交集</td>
</tr>
<tr class="odd">
<td>SDIFF key1 key2 …</td>
<td>求key1和key2的差集</td>
</tr>
<tr class="even">
<td>SUNION key1 key2 …</td>
<td>求key1和key2的并集</td>
</tr>
</tbody>
</table>
<h1 id="sortedset类型">SortedSet类型</h1>
<p>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet(红黑树)有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表(SkipList)加
hash表。</p>
<p>SortedSet具备下列特性:</p>
<ul>
<li>可排序</li>
<li>元素不重复</li>
<li>查询速度快</li>
</ul>
<p>因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。</p>
<p>常见命令</p>
<table>
<colgroup>
<col style="width: 32%" />
<col style="width: 67%" />
</colgroup>
<thead>
<tr class="header">
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ZADD key score member</td>
<td>添加一个或多个元素到sorted set，如果已经存在则更新其score值</td>
</tr>
<tr class="even">
<td>ZREM key member</td>
<td>删除sorted set中的一个指定元素</td>
</tr>
<tr class="odd">
<td>ZSCORE key member</td>
<td>获取sorted set中的指定元素的score值</td>
</tr>
<tr class="even">
<td>ZRANK key member</td>
<td>获取sorted set中的指定元素的排名</td>
</tr>
<tr class="odd">
<td>ZCARD key</td>
<td>获取sorted set中的元素个数</td>
</tr>
<tr class="even">
<td>ZCOUNT key min max</td>
<td>统计score值在给定范围内的所有元素的个数</td>
</tr>
<tr class="odd">
<td>ZINCRBY key increment member</td>
<td>让sorted set中的指定元素自增，步长为指定的increment值</td>
</tr>
<tr class="even">
<td>ZRANGE key min max</td>
<td>按照score排序后，获取指定排名范围内的元素</td>
</tr>
<tr class="odd">
<td>ZRANGEBYSCORE key min max</td>
<td>按照score排序后，获取指定score范围内的元素</td>
</tr>
<tr class="even">
<td>ZDIFF、ZINTER、ZUNION</td>
<td>求差集、交集、并集</td>
</tr>
</tbody>
</table>
<ul>
<li>注意:所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可</li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL12-MVCC多版本并发控制</title>
    <url>/posts/10415.html</url>
    <content><![CDATA[<h1 id="基本概念">基本概念</h1>
<ul>
<li>当前读</li>
</ul>
<p>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如:select
... lock in share mode(共享锁)，select ... for
update、update、insert、delete(排他锁)都是一种当前读。</p>
<ul>
<li>快照读</li>
</ul>
<p>简单的select(不加锁）就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。</p>
<p>1.Read Committed:每次select，都生成一个快照读。</p>
<p>2.Repeatable Read:开启事务后第一个select语句才是快照读的地方。</p>
<p>3.erializable:快照读会退化为当前读。</p>
<ul>
<li>MVCC</li>
</ul>
<p>全称Multi-Version Concurrency
Control，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为My5QL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库记录中的三个隐式字段、undo
log日志、readview.</p>
<h1 id="实现原理">实现原理</h1>
<ul>
<li>记录中的隐式字段</li>
</ul>
<table>
<colgroup>
<col style="width: 38%" />
<col style="width: 61%" />
</colgroup>
<thead>
<tr class="header">
<th>隐式字段</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>DB_TRX_ID(database transaction id)</td>
<td>最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID。</td>
</tr>
<tr class="even">
<td>DB_ROLL_PTR(database rollback pointer)</td>
<td>回滚指针，指向这条记录的上一个版本，用于配合undo
log，指向上一个版本。</td>
</tr>
<tr class="odd">
<td>DB_ROW_ID(dataabse row id)</td>
<td>隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段。</td>
</tr>
</tbody>
</table>
<p>可以使用以下命令查看表空间信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ibd2sdi xxx.ibd</span><br></pre></td></tr></table></figure>
<ul>
<li>undo log</li>
</ul>
<p>回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志。</p>
<p>当insert的时候，产生的undo
log日志只在回滚时需要，在事务提交后，可被立即删除。</p>
<p>而update、delete的时候，产生的undo
log日志不仅在回滚时需要，在快照读时也需要，不会立即被删除。</p>
<figure>
<img src="https://wang-nine.cn/images/MySQL12-01undolog.png"
alt="MySQL12-01undolog" />
<figcaption aria-hidden="true">MySQL12-01undolog</figcaption>
</figure>
<ul>
<li>readview</li>
</ul>
<p>ReadView（读视图）是快照读SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务（未提交的)
id。</p>
<p>ReadView中包含了四个核心字段:</p>
<table>
<thead>
<tr class="header">
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>m_ids</td>
<td>当前活跃的事务ID集合</td>
</tr>
<tr class="even">
<td>min_trx_id</td>
<td>最小活跃事务ID</td>
</tr>
<tr class="odd">
<td>max_trx_id</td>
<td>预分配事务ID,当前最大事务ID+1（因为事务ID是自增的）</td>
</tr>
<tr class="even">
<td>creator_trx_id</td>
<td>ReadView创建者的事务ID</td>
</tr>
</tbody>
</table>
<figure>
<img src="https://wang-nine.cn/images/MySQL12-02Readview.png"
alt="MySQL12-02Readview" />
<figcaption aria-hidden="true">MySQL12-02Readview</figcaption>
</figure>
<p>==不同的隔离级别，生成ReadView的时机不同: READ
COMMITTED:在事务中每一次执行快照读时生成ReadView, REPEATABLE
READ:仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView.==</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis03-Jedis</title>
    <url>/posts/10703.html</url>
    <content><![CDATA[<h1 id="jedis">Jedis</h1>
<h2 id="样例程序">样例程序</h2>
<ul>
<li>1.引入依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>2.建立连接</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line"><span class="meta">@BeforeEach</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">//建立连接</span></span><br><span class="line">	jedis = <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;192.168.150.101&quot;</span>，<span class="number">6379</span>);</span><br><span class="line">    <span class="comment">//设置密码</span></span><br><span class="line">	jedis.auth(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    <span class="comment">//选择库</span></span><br><span class="line">	jedis.select(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试String</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">//插入数据，方法名称就是redis命令名称，非常简单</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>); </span><br><span class="line">    System.out.println(<span class="string">&quot;result = &quot;</span> + result);</span><br><span class="line">    <span class="comment">//获取数据</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;name&quot;</span>) ;</span><br><span class="line">	System.out.println(<span class="string">&quot;name = &quot;</span> + name) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>释放资源</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AfterEach</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">//释放资源</span></span><br><span class="line">	<span class="keyword">if</span> (jedis != <span class="literal">null</span>) &#123;</span><br><span class="line">		jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="jedis连接池">Jedis连接池</h2>
<p>Jedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此我们推荐大家使用Jedis连接池代替Jedis的直连方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisConnectionFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//配置连接池</span></span><br><span class="line">        <span class="type">JedisPoolConfig</span> <span class="variable">poolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">        poolConfig.setMaxTotal(<span class="number">8</span>);  <span class="comment">//最大连接数</span></span><br><span class="line">        poolConfig.setMaxIdle(<span class="number">8</span>);   <span class="comment">//最大空闲连接</span></span><br><span class="line">        poolConfig.setMinIdle(<span class="number">0</span>);   <span class="comment">//最小空闲连接</span></span><br><span class="line">        poolConfig.setMaxWaitMillis(<span class="number">1000</span>);  <span class="comment">//没有连接可用的等待时长，默认-1，持续等待</span></span><br><span class="line">        <span class="comment">//创建连接池对象</span></span><br><span class="line">        jedisPool = <span class="keyword">new</span> <span class="title class_">JedisPool</span>(poolConfig, <span class="string">&quot;192.168.72.128&quot;</span>, <span class="number">6379</span>, <span class="number">1000</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title function_">getJedis</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis04-SpringDataRedis</title>
    <url>/posts/10704.html</url>
    <content><![CDATA[<h1 id="springdataredis">SpringDataRedis</h1>
<p>SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis</p>
<p>提供了对不同Redis客户端的整合(Lettuce和Jedis)
提供了RedisTemplate统一API来操作Redis 支持Redis的发布订阅模型
支持Redis哨兵和Redis集群 支持基于Lettuce的响应式编程
支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化
支持基于Redis的JDKCollection实现</p>
<h2 id="springdataredis快速入门">SpringDataRedis快速入门</h2>
<table>
<colgroup>
<col style="width: 42%" />
<col style="width: 23%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th>API</th>
<th>返回值类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>redisTemplate.opsForValue()</td>
<td>ValueOperations</td>
<td>操作String数据类型</td>
</tr>
<tr class="even">
<td>redisTemplate.opsForHash()</td>
<td>HashOperations</td>
<td>操作Hash类型数据</td>
</tr>
<tr class="odd">
<td>redisTemplate.opsForList()</td>
<td>ListOperations</td>
<td>操作List类型数据</td>
</tr>
<tr class="even">
<td>redisTemplate.opsForSet()</td>
<td>SetOperations</td>
<td>操作Set类型数据</td>
</tr>
<tr class="odd">
<td>redisTemplate.opsForZSet()</td>
<td>ZSetOperations</td>
<td>操作SortedSet类型数据</td>
</tr>
<tr class="even">
<td>redisTemplate</td>
<td></td>
<td>通用的命令</td>
</tr>
</tbody>
</table>
<h2 id="使用基于springboot">使用(基于SpringBoot)</h2>
<ul>
<li>1.引入依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Redis依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 连接池依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>2.配置文件</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.72</span><span class="number">.128</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span> <span class="comment"># 最大连接</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span> <span class="comment"># 最大空闲连接</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span> <span class="comment"># 最小空闲连接</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="number">100</span> <span class="comment"># 连接等待时间</span></span><br></pre></td></tr></table></figure>
<ul>
<li>3.注入RedisTemplate</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate redisTemplate;</span><br></pre></td></tr></table></figure>
<ul>
<li>4.编写测试</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//插入一条String类型数据</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        <span class="comment">//读取一条String数据</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">name</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSaveUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//写入数据</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;user:100&quot;</span>, <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Wang&quot;</span>, <span class="number">21</span>));</span><br><span class="line">        <span class="comment">//获取数据</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">o</span> <span class="operator">=</span> (User) redisTemplate.opsForValue().get(<span class="string">&quot;user:100&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;o = &quot;</span> + o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>插入数据出现了问题，序列化出现了问题，变成了字节</p>
<p>缺点：可读性差且占用内存大</p>
<p>改进(自己定义序列化和反序列化)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span> &#123;</span><br><span class="line">        <span class="comment">//创建RedisTemplate对象</span></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//设置连接工厂</span></span><br><span class="line">        template.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="comment">//创建JSON序列化工具</span></span><br><span class="line">        <span class="type">GenericJackson2JsonRedisSerializer</span> <span class="variable">jsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>();</span><br><span class="line">        <span class="comment">//设置Key的序列化</span></span><br><span class="line">        template.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        template.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="comment">//设置Value的序列化</span></span><br><span class="line">        template.setValueSerializer(jsonRedisSerializer);</span><br><span class="line">        template.setHashValueSerializer(jsonRedisSerializer);</span><br><span class="line">        <span class="comment">//返回</span></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了在反序列化时知道对象的类型，JSON序列化器会将类的class类型写入json结果中，存入Redis，会带来额外的内存开销。</p>
<p>为了节省内存空间，我们并不会使用JSON序列化器来处理value，而是统一使用String序列化器，要求只能存储String类型的key和value。当需要存储Java对象时，手动完成对象的序列化和反序列化。</p>
<p>Spring默认提供了一个StringRedisTemplate类，它的key和value的序列化方式默认就是String方式。省去了我们自定义RedisTemplate的过程:</p>
<p>使用StringRedisTemplate和手动序列化和反序列化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisStringTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//插入一条String类型数据</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;string测试&quot;</span>);</span><br><span class="line">        <span class="comment">//读取一条String数据</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">name</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name);<span class="comment">//插入一条String类型数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSaveUser</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Wang-nine&quot;</span>, <span class="number">9</span>);</span><br><span class="line">        <span class="comment">//手动序列化</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> mapper.writeValueAsString(user);</span><br><span class="line">        <span class="comment">//写入数据</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">&quot;user:200&quot;</span>, json);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonUser</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;user:200&quot;</span>);</span><br><span class="line">        <span class="comment">//手动反序列化</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> mapper.readValue(jsonUser, User.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;user1 = &quot;</span> + user1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>==RedisTemplate的两种序列化实践方案:==</p>
<ul>
<li>方案一: 1.自定义RedisTemplate
2.修改RedisTemplate的序列化器为GenericJackson2JsonRedisSerializer</li>
<li>方案二: 1.使用StringRedisTemplate
2.写入Redis时，手动把对象序列化为JSON
3.读取Redis时，手动把读取到的JSON反序列化为对象</li>
</ul>
<p>注意：有关于Hash数据结构的存取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">TestHash</span><span class="params">()</span> &#123;</span><br><span class="line">    stringRedisTemplate.opsForHash().put(<span class="string">&quot;user:400&quot;</span>, <span class="string">&quot;测试300&quot;</span>, <span class="string">&quot;300&quot;</span>);</span><br><span class="line">    stringRedisTemplate.opsForHash().put(<span class="string">&quot;user:400&quot;</span>, <span class="string">&quot;测试400&quot;</span>, <span class="string">&quot;400&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Map&lt;Object, Object&gt; entries = stringRedisTemplate.opsForHash().entries(<span class="string">&quot;user:400&quot;</span>);</span><br><span class="line">    System.out.println(entries);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis05-短信登陆</title>
    <url>/posts/10705.html</url>
    <content><![CDATA[<h1 id="短信登陆">短信登陆</h1>
<h2 id="导入的表格">导入的表格</h2>
<ul>
<li>tb_user:用户表</li>
<li>tb_userLinfo:用户详情表</li>
<li>tb_shop:商户信息表</li>
<li>tb_shop_type:商户类型表</li>
<li>tb_blog:用户日记表(达人探店日记)</li>
<li>tb_follow:用户关注表</li>
<li>tb_voucher:优惠券表</li>
<li>tb_voucher_order:优惠券的订单表</li>
</ul>
<figure>
<img
src="https://wang-nine.cn/images/Redis05-%E7%9F%AD%E4%BF%A1%E7%99%BB%E9%99%86.png"
alt="Redis05-短信登陆" />
<figcaption aria-hidden="true">Redis05-短信登陆</figcaption>
</figure>
<h1 id="基于session实现登陆">基于Session实现登陆</h1>
<figure>
<img src="https://wang-nine.cn/images/Redis05-02Session.png"
alt="Redis05-02Session" />
<figcaption aria-hidden="true">Redis05-02Session</figcaption>
</figure>
<p>1.怎么基于session</p>
<p>2.验证码如何比对</p>
<p>3.是否要将所有的数据存入session？</p>
<p>==集群的session共享问题==</p>
<p>session共享问题:多台Tomcat并不共享session存储空间，当请求切换到不同tomcat服务时导致数据丢失的问题。</p>
<p>session的替代方案应该满足:</p>
<ul>
<li>数据共享</li>
<li>内存存储</li>
<li>kev、value结构(和session一样)</li>
</ul>
<p>使用Redis！</p>
<p>首先每个Tomcat可以去访问Redis，Redis是内存存储的，且Redis就是key，value结构</p>
<p>问题：</p>
<ul>
<li>保存验证码</li>
</ul>
<p>存储在Redis中类型：String，那么key是什么？手机号（确保每个手机号有自己的验证码，不仅可以</p>
<ul>
<li>保存用户信息</li>
</ul>
<p>存储在Redis中类型：Hash，那么key是什么？==手机号（不推荐，放在请求头中，有暴露的风险）
建议随机token==</p>
<p>（保存登录的用户信息，可以使用String结构，以SON字符串来保存，比较直观，</p>
<p>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD，并且内存占用更少）</p>
<ul>
<li>登陆校验</li>
</ul>
<p>不再是sessionid，token才是登录凭着，但是token不是自动存储在浏览器，需要手动返回到浏览器。</p>
<figure>
<img src="https://wang-nine.cn/images/Redis05-03redis.png"
alt="Redis05-03redis" />
<figcaption aria-hidden="true">Redis05-03redis</figcaption>
</figure>
<p>==可以给验证码设置有效期，放在内存满==</p>
<p>==注意像session（默认30min）一样给登陆时间做一个有效期，要不然登陆信息越来越多，最后会把redis装满==</p>
<p>==另一个问题，有效期30min，从登陆开始算起，只要登陆了30min后就会踢出，那么如何访问刷新有效期？拦截器！==</p>
<p>==上个问题可以在prehandle中修改，获取请求头的token，</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">preHandle</span><br><span class="line"></span><br><span class="line">调用时间：Controller方法处理之前</span><br><span class="line"></span><br><span class="line">执行顺序：链式Intercepter情况下，Intercepter按照声明的顺序一个接一个执行</span><br><span class="line"></span><br><span class="line">若返回false，则中断执行，注意：不会进入afterCompletion</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">postHandle</span><br><span class="line"></span><br><span class="line">调用前提：preHandle返回true</span><br><span class="line"></span><br><span class="line">调用时间：Controller方法处理完之后，DispatcherServlet进行视图的渲染之前，也就是说在这个方法中你可以对ModelAndView进行操作</span><br><span class="line"></span><br><span class="line">执行顺序：链式Intercepter情况下，Intercepter按照声明的顺序倒着执行。</span><br><span class="line"></span><br><span class="line">备注：postHandle虽然post打头，但post、get方法都能处理</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">afterCompletion</span><br><span class="line"></span><br><span class="line">调用前提：preHandle返回true</span><br><span class="line"></span><br><span class="line">调用时间：DispatcherServlet进行视图的渲染之后</span><br></pre></td></tr></table></figure>
<p>Redis代替session需要考虑的问题:</p>
<ul>
<li>选择合适的数据结构</li>
<li>选择合适的key</li>
<li>选择合适的存储粒度</li>
</ul>
<p>==拦截器问题==</p>
<p>拦截器拦住了需要登录的路径，若一直访问不需要登陆的网页则不会刷新，怎么办？</p>
<figure>
<img
src="https://wang-nine.cn/images/Redis05-%E6%8B%A6%E6%88%AA%E5%99%A8%E4%BC%98%E5%8C%96.png"
alt="Redis05-拦截器优化" />
<figcaption aria-hidden="true">Redis05-拦截器优化</figcaption>
</figure>
<p>如何控制拦截器顺序？</p>
<p>.order属性</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">    registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">RefreshTokenInterceptor</span>(stringRedisTemplate))</span><br><span class="line">            .addPathPatterns(</span><br><span class="line">                    <span class="string">&quot;/**&quot;</span></span><br><span class="line">            ).order(<span class="number">0</span>);</span><br><span class="line">    registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>())</span><br><span class="line">            .excludePathPatterns(</span><br><span class="line">                    <span class="string">&quot;/shop/**&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;/blog/hot&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;/shop/type/**&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;/upload/**&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;/vocher/**&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;/user/code&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;/user/login&quot;</span></span><br><span class="line">            ).order(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>order越小越先执行</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>SSM01-Spring中的Bean</title>
    <url>/posts/10301.html</url>
    <content><![CDATA[<p>简单的介绍了Spring中的架构以及IOC和DI。 <span id="more"></span></p>
<h1 id="spring-framework架构">Spring FrameWork架构</h1>
<p><strong>Spring
Framework是Spring生态圈中最基础的项目，是其他项目的根基</strong></p>
<p><strong>Spirng FrameWork的架构</strong></p>
<figure>
<img
src="https://wang-nine.cn/images/SSM01-01SpringFrameWork%E6%9E%B6%E6%9E%84.png"
alt="SSM01-01SpringFrameWork架构" />
<figcaption aria-hidden="true">SSM01-01SpringFrameWork架构</figcaption>
</figure>
<h1 id="spring核心概念">Spring核心概念</h1>
<h2 id="ioc-inversion-of-control-控制反转"><strong>IoC ( Inversion of
Control )控制反转</strong></h2>
<blockquote>
<p>使用对象时，由主动new产生对象转换为由<strong>外部</strong>提供对象，此过程中对象创建控制权由程序转移到<strong>外部</strong>，此思想称为控制反转</p>
</blockquote>
<blockquote>
<p>Spring技术对IoC思想进行了实现Spring提供了一个容器，称为IoC容器，用来充当IoC思想中的"<strong>外部</strong>"</p>
</blockquote>
<blockquote>
<p>IoC容器负责对象的创建、初始化等一系列工作，被创建或被管理的对象在IoC容器中统称为Bean</p>
</blockquote>
<h2 id="di-dependency-injection依赖注入"><strong>DI ( Dependency
Injection)依赖注入</strong></h2>
<blockquote>
<p>在容器中建立bean与bean之间的依赖关系的整个过程，称为依赖注入</p>
</blockquote>
<h1 id="ioc入门案例">IoC入门案例</h1>
<blockquote>
<p>思路分析： 1.管理什么? （Service与Dao）
2.如何将被管理的对象告知IoC容器?（配置）
3.被管理的对象交给IoC容器，如何获取到IoC容器?（接口）
4.IoC容器得到后，如何从容器中获取bean ?（接口方法）
5.使用Spring导入哪些坐标?（pom.xml）</p>
</blockquote>
<h2 id="非spring环境下">非Spring环境下</h2>
<p>案例代码如下：</p>
<p>Service层的代码： 接口： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> wang.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实现： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> wang.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> wang.dao.Dao;</span><br><span class="line"><span class="keyword">import</span> wang.dao.impl.DaoImpl;</span><br><span class="line"><span class="keyword">import</span> wang.service.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Dao</span> <span class="variable">dao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DaoImpl</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Service save() ...&quot;</span>);</span><br><span class="line">        dao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>DAO层的代码： 接口： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> wang.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Dao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 实现： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> wang.dao.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> wang.dao.Dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaoImpl</span> <span class="keyword">implements</span> <span class="title class_">Dao</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dao save() ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主函数代码： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> wang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> wang.service.Service;</span><br><span class="line"><span class="keyword">import</span> wang.service.impl.ServiceImpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceImpl</span>();</span><br><span class="line">        service.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果： <img
src="https://wang-nine.cn/images/SSM01-02%E9%9D%9ESpring%E7%8E%AF%E5%A2%83%E6%A0%B7%E4%BE%8B.png"
alt="SSM01-02非Spring环境样例" /></p>
<h2 id="spring环境下">Spring环境下</h2>
<p>别忘记在pom.xml中引入spring-context <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>在resources中创建配置文件（名称：applicationContext.xml）：如图 <img
src="https://wang-nine.cn/images/SSM01-03%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png"
alt="SSM01-03配置文件" /></p>
<p>在配置文件中输入以下的代码 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--导入spring的坐标spring-context，对应版本是5.2.10.RELEASE--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置bean--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--bean标签标示配置bean</span></span><br><span class="line"><span class="comment">    id属性标示给bean起名字</span></span><br><span class="line"><span class="comment">    class属性表示给bean定义类型--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;Dao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;wang.dao.impl.DaoImpl&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;Service&quot;</span> <span class="attr">class</span>=<span class="string">&quot;wang.service.impl.ServiceImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>主函数代码 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> wang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">import</span> wang.service.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取IoC容器</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取Bean</span></span><br><span class="line">        <span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> (Service) ctx.getBean(<span class="string">&quot;Service&quot;</span>);</span><br><span class="line">        service.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此时运行样例与非Spring方式相同如下： <img
src="https://wang-nine.cn/images/SSM01-04Spring%E7%8E%AF%E5%A2%83%E6%A0%B7%E4%BE%8B.png"
alt="SSM01-04Spring环境样例" /></p>
<p><strong>综上：可以分为四步</strong></p>
<blockquote>
<p><strong>1.导入Spring坐标</strong></p>
<p><strong>2.定义Spring管理的类（接口）</strong></p>
<p><strong>3.创建Spring配置文件进行配置</strong></p>
<p><strong>4.初始化IoC容器，从容器中获取Bean（getBean方法）</strong></p>
</blockquote>
<p><strong>问题：业务层中仍然是使用new创建对象，仍然耦合，那么如何解耦合呢？</strong></p>
<h1 id="di入门案例">DI入门案例</h1>
<blockquote>
<p>思路分析： 1.基于IoC管理bean
2.Service使用new形式创建的Dao对象是否保留?（否）
3.Service中需要的Dao对象如何进入到service中?（提供方法）
4.Service与Dao间的关系如何描述?（配置）</p>
</blockquote>
<p>改变Service层实现代码如下 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> wang.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> wang.dao.Dao;</span><br><span class="line"><span class="keyword">import</span> wang.service.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="comment">// 删除业务层以new的方式创建Dao对象</span></span><br><span class="line">    <span class="comment">//private Dao dao = new DaoImpl();</span></span><br><span class="line">    <span class="keyword">private</span> Dao dao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Service save() ...&quot;</span>);</span><br><span class="line">        dao.save();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供对应的set方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDao</span><span class="params">(Dao dao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dao = dao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>修改applicationContext.xml中配置： <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;Service&quot;</span> <span class="attr">class</span>=<span class="string">&quot;wang.service.impl.ServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--7.配置server与dao的关系--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--property标签表示配置当前bean的属性</span></span><br><span class="line"><span class="comment">        name属性表示配置哪一个具体的属性</span></span><br><span class="line"><span class="comment">        ref属性表示参照哪一个bean--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;Dao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
&gt;<strong>注意：name是上述的（private Dao
dao;）语句中的变量名，ref是bean的名字。</strong></p>
<p>运行结果与上述一样： <img
src="https://wang-nine.cn/images/SSM01-05DI.png" alt="SSM01-05DI" /></p>
<p><strong>综上：可以分为三步</strong></p>
<blockquote>
<p>1.<strong>删除以new的形式创建对象的代码</strong></p>
<p>2.<strong>提供对应的Set方法</strong></p>
<p>3.<strong>配置Service与Dao之间的关系</strong></p>
</blockquote>
<p><strong>注意在Bean标签中还可以进行以下的配置：</strong></p>
<p><strong>属性name：定义Bean的别名</strong></p>
<p><strong>属性scope：定义作用范围 singleton（默认，单例）
prototype（非单例）</strong></p>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM02-Spring中Bean的实例化与依赖注入</title>
    <url>/posts/10302.html</url>
    <content><![CDATA[<p>详细的描述了Spring中Bean的实例化与依赖注入。 <span id="more"></span></p>
<h3 id="bean的实例化">Bean的实例化</h3>
<h4 id="构造方法">构造方法</h4>
<p>Spring创建Bean的时候调用无参构造。（有参构造会报错，私有无参也可以，底层使用了反射）</p>
<p>注意：Spring中的报错从下向上看，直到找到有用的信息。</p>
<p>注意：若不存在无参构造方法，会抛出异常：BeanCreationException</p>
<p>添加无参构造后： 运行结果： <img
src="https://wang-nine.cn/images/SSM02-01%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95.png"
alt="SSM02-01构造方法" /></p>
<h4 id="静态工厂">静态工厂</h4>
<p>创建对象不需要自己new，创建一个工厂创建对象达到解耦的效果</p>
<p>样例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> wang.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> wang.dao.Dao;</span><br><span class="line"><span class="keyword">import</span> wang.dao.impl.DaoImpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaoFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Dao <span class="title function_">getDao</span><span class="params">()</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;factory set up ...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置文件添加如下代码： <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;daoFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;wang.factory.DaoFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getDao&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>主函数： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> wang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">import</span> wang.dao.Dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">Dao</span> <span class="variable">dao</span> <span class="operator">=</span> (Dao) ctx.getBean(<span class="string">&quot;daoFactory&quot;</span>);</span><br><span class="line">        dao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：</p>
<figure>
<img
src="https://wang-nine.cn/images/SSM02-02%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82.png"
alt="SSM02-02静态工厂" />
<figcaption aria-hidden="true">SSM02-02静态工厂</figcaption>
</figure>
<h4 id="实例工厂">实例工厂</h4>
<p>工厂代码同上</p>
<p>配置文件修改为如下代码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;daoFactorytemp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;wang.factory.DaoFactory&quot;</span>/&gt;</span>                 <span class="comment">&lt;!-- 创建工厂bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;daoFactory&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;daoFactorytemp&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- factory-bean指定工厂bean --&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>第一行为一个无用的bean，改良后即为第四种方法</strong></p>
<p>主函数不变</p>
<p>运行结果：</p>
<figure>
<img src="https://wang-nine.cn/images/SSM02-03FactoryBean.png"
alt="SSM02-03FactoryBean" />
<figcaption aria-hidden="true">SSM02-03FactoryBean</figcaption>
</figure>
<h4 id="factorybean重要">FactoryBean（重要！）</h4>
<p><strong>在第三种方法存在两个问题</strong>
<strong>一、factory-bean属性使用时会创建一个无用的Bean</strong>
<strong>二、factory-method属性方法名不固定，非动态实现</strong></p>
<p>因此，对此方法做了改良</p>
<p>factory实现一个接口FactoryBean<T></p>
<p>工厂代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> wang.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.FactoryBean;</span><br><span class="line"><span class="keyword">import</span> wang.dao.Dao;</span><br><span class="line"><span class="keyword">import</span> wang.dao.impl.DaoImpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaoFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;Dao&gt; &#123;</span><br><span class="line">    <span class="comment">// 代替原始实例工厂创建对象的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Dao <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 得到Bean的类型</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> Dao.class;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置Bean是否单例子，return true为单例，false为非单例</span></span><br><span class="line">    <span class="comment">// 该方法一般不重写</span></span><br><span class="line">    <span class="comment">/*@Override</span></span><br><span class="line"><span class="comment">    public boolean isSingleton() &#123;</span></span><br><span class="line"><span class="comment">        return true;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置文件修改为如下代码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;daoFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;wang.factory.DaoFactoryBean&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>主函数不变</p>
<p>运行结果：</p>
<figure>
<img src="https://wang-nine.cn/images/SSM02-03FactoryBean.png"
alt="SSM02-03FactoryBean" />
<figcaption aria-hidden="true">SSM02-03FactoryBean</figcaption>
</figure>
<h4 id="补充bean的生命周期">补充：Bean的生命周期</h4>
<h5 id="控制生命周期">控制生命周期</h5>
<h4 id="方法一">方法一：</h4>
<p>控制方法代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> DaoImpl <span class="keyword">implements</span> <span class="title class_">Dao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dao save ... &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dao init ... &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dao destroy ... &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置控制方法：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;Dao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;wang.dao.impl.DaoImpl&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destory&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="方法二">方法二</h4>
<p>实现InitializingBean, DisposableBean接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> DaoImpl <span class="keyword">implements</span> <span class="title class_">Dao</span>, InitializingBean, DisposableBean &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dao save ... &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dao init ... &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dao destroy ... &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="生命周期">生命周期</h5>
<blockquote>
<p><strong>初始化容器</strong> 1.创建对象（内存分配） 2.执行构造方法
3.执行属性注入( set操作） 4.执行bean初始化方法</p>
</blockquote>
<blockquote>
<p><strong>使用bean</strong> 1.行业务操作</p>
</blockquote>
<blockquote>
<p><strong>关闭/销毁容器</strong> 1.执行bean销毁方法</p>
</blockquote>
<p>注：<strong>销毁的时机：</strong>容器关闭前触发bean的销毁
关闭容器方式： 手工关闭容器
ConfigurableApplicationContext接口close（）</p>
<p>操作注册关闭钩子，在虚拟机退出前先关闭容器再退出虚拟机
ConfigurableApplicationcontext接口registerShutdownHook （）操作</p>
<h3 id="依赖注入">依赖注入</h3>
<h4 id="setter注入">setter注入</h4>
<h5 id="引用类型">引用类型</h5>
<p>详情见博客 SSM01-Spring中的Bean &gt; 步骤如下 &gt;
1.在bean中定义引用类型属性并提供可访问的set方法 &gt;
2.配置中使用property标签ref属性注入引用类型对象</p>
<h5 id="简单类型">简单类型</h5>
<blockquote>
<p>步骤如下 1.在bean中定义引用类型属性并提供可访问的set方法
2.配置中使用property标签value属性注入简单类型数据</p>
</blockquote>
<h4 id="构造器注入">构造器注入</h4>
<h5 id="引用类型仅做了解">引用类型（仅做了解）</h5>
<blockquote>
<p>步骤如下 1.在bean中定义引用类型属性并提供可访问的构造方法
2.配置中使用constructor-arg标签ref属性注入引用类型对象</p>
</blockquote>
<h5 id="简单类型-1">简单类型</h5>
<blockquote>
<p>步骤如下 1.在bean中定义引用类型属性并提供可访问的set方法
2.配置中使用property标签value属性注入简单类型数据 注意：
配置中使用constructor-arg标签type属性设置按形参类型注入
配置中使用constructor-arg标签index属性设置按形参位置注入</p>
</blockquote>
<h4
id="依赖注入方式的选择总结自黑马程序员侵删">依赖注入方式的选择（总结自黑马程序员，侵删）</h4>
<p>1.强制依赖使用构造器进行，使用setter注入有概率不进行注入导致null对象出现
2.可选依赖使用setter注入进行，灵活性强
3.Spring框架倡导使用构造器，第三方框架内部大多数采用构造器注入的形式进行数据初始化，相对严谨
4.如果有必要可以两者同时使用，使用构造器注入完成强制依赖的注入，使用setter注入完成可选依赖的注入
5.实际开发过程中还要根据实际情况分析，如果受控对象没有提供setter方法就必须使用构造器注入
6.自己开发的模块推荐使用setter注入</p>
<h4
id="自动装配优先级低于setter注入与构造器注入">自动装配（优先级低于setter注入与构造器注入）</h4>
<p>IoC容器根据bean所依赖的资源在容器中自动查找并注入到bean中的过程称为自动装配</p>
<p>自动装配方式</p>
<h5
id="按类型常用不能对简单类型装配">按类型（常用）（不能对简单类型装配）</h5>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;daoFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;wang.dao.impl.DaoImpl&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意：需要set方法</p>
<p>注意：按类型（byType）时，同类型的应该只有一个bean，否则分不清。</p>
<h5
id="按名称set方法第一个字母改为小写的名称即标椎的变量名">按名称(set方法第一个字母改为小写的名称，即标椎的变量名)</h5>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;daoFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;wang.dao.impl.DaoImpl&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意：因为变量名与byName耦合度高，不建议使用。</p>
<h5 id="按构造方法">按构造方法</h5>
<h4 id="集合注入主要学习格式">集合注入（主要学习格式）</h4>
<p>Dao接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> wang.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DataDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Dao实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> wang.dao.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> wang.dao.DataDao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">DataDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] array;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; set;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Properties properties;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setArray</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.array = array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setList</span><span class="params">(List&lt;String&gt; list)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSet</span><span class="params">(Set&lt;String&gt; set)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.set = set;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMap</span><span class="params">(Map&lt;String, String&gt; map)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.map = map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setProperties</span><span class="params">(Properties properties)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.properties = properties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;遍历数组:&quot;</span> + Arrays.toString(array));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;遍历List&quot;</span> + list);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;遍历Set&quot;</span> + set);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;遍历Map&quot;</span> + map);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;遍历Properties&quot;</span> + properties);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;wang.dao.impl.DataDaoImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--数组注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;array&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>100<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>200<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>300<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--list集合注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>java<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>c++<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>python<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>php<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--set集合注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;set&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>java<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>python<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>java<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>php<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--map集合注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;country&quot;</span> <span class="attr">value</span>=<span class="string">&quot;china&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;province&quot;</span> <span class="attr">value</span>=<span class="string">&quot;shanxi&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;city&quot;</span> <span class="attr">value</span>=<span class="string">&quot;xian&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Properties注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;properties&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;country&quot;</span>&gt;</span>china<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;province&quot;</span>&gt;</span>shanxi<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;city&quot;</span>&gt;</span>xian<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>主函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> wang.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App6</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">DataDao</span> <span class="variable">dataDao</span> <span class="operator">=</span> (DataDao) ctx.getBean(<span class="string">&quot;dataDao&quot;</span>);</span><br><span class="line">        dataDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure>
<img
src="https://wang-nine.cn/images/SSM02-04%E9%9B%86%E5%90%88%E6%B3%A8%E5%85%A5.png"
alt="SSM02-04集合注入" />
<figcaption aria-hidden="true">SSM02-04集合注入</figcaption>
</figure>
<h4 id="第三方资源注入">第三方资源注入</h4>
<h3 id="容器">容器</h3>
<h4 id="两种加载容器的方式">两种加载容器的方式</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>); <span class="comment">//推荐</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemXmlApplicationContext</span>(<span class="string">&quot;D:\\ssm\\ssm\\springtest\\springtest\\src\\main\\resources\\applicationContext.xml&quot;</span>)	<span class="comment">//绝对路径寻找</span></span><br></pre></td></tr></table></figure>
<h4 id="两种获取bean的方式">两种获取bean的方式</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Dao</span> <span class="variable">dao</span> <span class="operator">=</span> (DataDao) ctx.getBean(<span class="string">&quot;dao&quot;</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Dao</span> <span class="variable">dao</span> <span class="operator">=</span> ctx.getBean(<span class="string">&quot;dao&quot;</span>, Dao.class);  <span class="comment">//多个同种类型报错</span></span><br></pre></td></tr></table></figure>
<h4
id="对比applicationcontext和beanfactory">对比ApplicationContext和BeanFactory</h4>
<p>BeanFactory是顶级接口的Bean是延迟加载</p>
<p>ApplicationContext是子接口（常用）也可以延迟加载，在bean中加入参数
lazy-init=“true” 即可</p>
<h4 id="加载第三方bean">加载第三方Bean</h4>
<h4 id="加载properties文件">加载Properties文件</h4>
<p>步骤如下：</p>
<ol type="1">
<li>开启Context命名空间</li>
<li>使用context加载properties文件</li>
<li>使用属性占位符${}读取properties配置文件中的属性</li>
</ol>
<p>样例代码如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">           http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">           http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">           http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">            &quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--步骤--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--1.开启命名空间--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--2.使用context加载properties文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;xxxx.properties&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--3.使用属性占位符$&#123;&#125;读取properties配置文件中的属性--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;xxxx&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;xxxx&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123; 配置中的变量名称 &#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意：加载时可以关闭系统属性，因为系统属性的优先级高于</p>
<p>注意：多个配置文件用逗号隔开</p>
<p>注意：专业的写法加载所有配置文件如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 加载properties文件标准格式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:*.properties&quot;</span> <span class="attr">system-properties-mode</span>=<span class="string">&quot;NEVER&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 从类路径或jar包中搜索并加载properties文件</span></span><br><span class="line"><span class="comment">&lt;context:property-placeholder location=&quot;classpath*:*.properties&quot; system-properties-mode=&quot;NEVER&quot;/&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="总结来自黑马程序员侵删">总结（来自黑马程序员，侵删）</h3>
<h4 id="容器相关">容器相关</h4>
<figure>
<img
src="https://wang-nine.cn/images/SSM02-05%E5%AE%B9%E5%99%A8%E7%9B%B8%E5%85%B3.png"
alt="SSM02-05容器相关" />
<figcaption aria-hidden="true">SSM02-05容器相关</figcaption>
</figure>
<h4 id="bean相关">bean相关</h4>
<figure>
<img
src="https://wang-nine.cn/images/SSM02-06bean%E7%9B%B8%E5%85%B3.png"
alt="SSM02-06bean相关" />
<figcaption aria-hidden="true">SSM02-06bean相关</figcaption>
</figure>
<h4 id="依赖注入相关">依赖注入相关</h4>
<figure>
<img
src="https://wang-nine.cn/images/SSM02-07%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3.png"
alt="SSM02-07依赖注入相关" />
<figcaption aria-hidden="true">SSM02-07依赖注入相关</figcaption>
</figure>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis06-缓存</title>
    <url>/posts/10705.html</url>
    <content><![CDATA[
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>SSM03-Spring的纯注解开发模式</title>
    <url>/posts/10303.html</url>
    <content><![CDATA[<p>详细的描述了Spring中的注解开发。 <span id="more"></span></p>
<h1 id="注解开发定义bean">注解开发定义Bean</h1>
<h2 id="步骤">步骤：</h2>
<h3 id="使用component定义bean">1.使用@Component定义Bean</h3>
<p>以下两种方式都可以定义Bean</p>
<p><span class="citation"
data-cites="Component">@Component</span>(“Bean的名称”)</p>
<p><span class="citation" data-cites="Component">@Component</span></p>
<p>其中第一种方式可以使用 ctx.getBean(“名称”)</p>
<p>其中第二种方式只能使用 ctx.getBean(“类型.class”) 因为没有指定名称</p>
<h3
id="核心配置文件中通过组件扫描加载bean">2.核心配置文件中通过组件扫描加载Bean</h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;wang&quot;</span>/&gt;</span> <span class="comment">&lt;!-- 递归扫描 wang --&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="注意">注意：</h2>
<p>Spring提供@Component注解的三个衍生注解</p>
<blockquote>
<p><span class="citation"
data-cites="controller">@controller</span>：用于表现层bean定义 <span
class="citation"
data-cites="service">@service</span>：用于业务层bean定义. <span
class="citation"
data-cites="Repository">@Repository</span>：用于数据层bean定义</p>
</blockquote>
<p>样例代码：</p>
<p>impl实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> wang.dao.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> wang.dao.Dao;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(&quot;dao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaoImpl</span> <span class="keyword">implements</span> <span class="title class_">Dao</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dao save() ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>xml配置文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">           http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">           http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">           http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">            &quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;wang&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>主函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> wang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">import</span> wang.dao.Dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml.bak&quot;</span>);</span><br><span class="line">        <span class="type">Dao</span> <span class="variable">dao</span> <span class="operator">=</span> (Dao) ctx.getBean(<span class="string">&quot;dao&quot;</span>);</span><br><span class="line">        dao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure>
<img
src="https://wang-nine.cn/images/SSM03-01%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91%E5%AE%9A%E4%B9%89Bean%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png"
alt="SSM03-01注解开发定义Bean运行结果" />
<figcaption
aria-hidden="true">SSM03-01注解开发定义Bean运行结果</figcaption>
</figure>
<h1 id="纯注解开发模式">纯注解开发模式</h1>
<p>Spring3.0升级了纯注解开发模式，使用Java类替代配置文件，开启了Spring快速开发赛道</p>
<p><strong>如何取消配置文件呢，使用一个配置类来代替配置文件</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> wang.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;wang&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<blockquote>
<p><strong><span class="citation"
data-cites="ComponentScan">@ComponentScan</span>("wang")
代替了中间的组件扫描器的功能</strong></p>
<p><strong><span class="citation"
data-cites="Configuration代替了">@Configuration代替了</span> xml
配置文件中的其他配置，如下图：</strong></p>
</blockquote>
<figure>
<img
src="https://wang-nine.cn/images/SSM03-02%E7%BA%AF%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91%E4%BB%A3%E6%9B%BF.png"
alt="SSM03-02纯注解开发代替" />
<figcaption aria-hidden="true">SSM03-02纯注解开发代替</figcaption>
</figure>
<p>注意：ComponentScan({"wang.xxx01", “wang.xxx02”}) 可以扫描多个类</p>
<p>主函数中需要改变一行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br></pre></td></tr></table></figure>
<p>此时删除xml配置文件运行结果相同：</p>
<figure>
<img
src="https://wang-nine.cn/images/SSM03-03%E7%BA%AF%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91%E5%AE%9A%E4%B9%89Bean%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png"
alt="SSM03-03纯注解开发定义Bean运行结果" />
<figcaption
aria-hidden="true">SSM03-03纯注解开发定义Bean运行结果</figcaption>
</figure>
<h1 id="bean的管理">Bean的管理</h1>
<h2 id="bean的作用范围">Bean的作用范围</h2>
<blockquote>
<p><strong><span class="citation"
data-cites="Scope">@Scope</span>(“prototype”)即可更改</strong></p>
</blockquote>
<h2 id="bean的生命周期">Bean的生命周期</h2>
<p>如下代码：</p>
<p>实现类： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> wang.dao.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Scope;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> wang.dao.Dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.PreDestroy;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(&quot;singleton&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaoImpl</span> <span class="keyword">implements</span> <span class="title class_">Dao</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dao save() ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init() ... &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destroy() ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> wang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"><span class="keyword">import</span> wang.config.SpringConfig;</span><br><span class="line"><span class="keyword">import</span> wang.dao.Dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForAnnotation</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">Dao</span> <span class="variable">dao1</span> <span class="operator">=</span> ctx.getBean(Dao.class);</span><br><span class="line">        <span class="type">Dao</span> <span class="variable">dao2</span> <span class="operator">=</span> ctx.getBean(Dao.class);</span><br><span class="line">        System.out.println(dao1);</span><br><span class="line">        System.out.println(dao2);</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意关闭容器或关闭钩子可以看到销毁操作</p>
<p>运行结果如下：</p>
<figure>
<img
src="https://wang-nine.cn/images/SSM03-04bean%E7%9A%84%E7%AE%A1%E7%90%86.png"
alt="SSM03-04bean的管理" />
<figcaption aria-hidden="true">SSM03-04bean的管理</figcaption>
</figure>
<h1 id="注解开发依赖注入">注解开发依赖注入</h1>
<blockquote>
<p><strong><span class="citation"
data-cites="AutoWired">@AutoWired</span></strong> —&gt;
实现了引用类型的注入</p>
</blockquote>
<blockquote>
<p>注意：自动装配基于反射设计创建对象并<strong>暴力反射</strong>对应属性为私有属性初始化数据，因此无需提供setter方法</p>
<p>注意：自动装配建议使用<strong>无参构造方法</strong>创建对象（默认），如果不提供对应构造方法，请提供唯一的构造方法</p>
</blockquote>
<p>样例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> wang.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> wang.dao.Dao;</span><br><span class="line"><span class="keyword">import</span> wang.service.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;dao&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Dao dao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Service save() ...&quot;</span>);</span><br><span class="line">        dao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong><span class="citation"
data-cites="Value">@Value</span>(“变量值”)</strong> —&gt;
实现了简单类型的注入</p>
</blockquote>
<p>简单的样例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;wang&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> string name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Service save() ...&quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>那么为什么不直接将name定义为“wang”呢？为什么还要多此一举呢？</strong></p>
<p>因为可以通过@Value注入properties</p>
<p>在配置类中加入如下注解</p>
<blockquote>
<p><span class="citation"
data-cites="PropertySource">@PropertySource</span>({“xxx.properties”，“xxx.properties”})
<strong>注意：不允许使用通配符 </strong></p>
</blockquote>
<p>此时可以通过@Value(“${ 属性名 }”) 访问properties中的属性</p>
<h1 id="注解开发管理第三方bean">注解开发管理第三方Bean</h1>
<blockquote>
<p><span class="citation" data-cites="Bean">@Bean</span>
表示当前方法的返回值是一个Bean</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">    <span class="comment">//1.定义一个方法获得要管理的对象</span></span><br><span class="line">    <span class="comment">//2.添加@Bean，表示当前方法的返回值是一个bean</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Datasource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(<span class="string">&quot;com.mysq1.jdbc.Driver&quot;</span>);</span><br><span class="line">        ds.setUr1(<span class="string">&quot;jdbc:mysql://localhost:3306/spring_db&quot;</span>);</span><br><span class="line">        ds.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        ds.setPassword(<span class="string">&quot;1234&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写好当前配置文件后，在独立的配置类中导入当前配置类</p>
<blockquote>
<p>方法1.扫描式 <span class="citation"
data-cites="ComponentScan">@ComponentScan</span>({“xxx.service”,
“xxx.dao”, “xxx.config”}) 不推荐</p>
<p>方法2.导入式 <span class="citation"
data-cites="Import">@Import</span>(xxxconfig.class) 推荐，更为清晰</p>
</blockquote>
<h2 id="注入普通类型">注入普通类型：</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;com.mysql.jdbc.Driver&quot;)</span></span><br><span class="line"><span class="keyword">private</span> string driver;</span><br><span class="line"><span class="meta">@value(&quot;jdbc:mysq1://localhost:3306/spring_db&quot;)</span></span><br><span class="line"><span class="keyword">private</span> string url;</span><br><span class="line"><span class="meta">@Value(&quot;root&quot;)</span></span><br><span class="line"><span class="keyword">private</span> string userName;</span><br><span class="line"><span class="meta">@Value(&quot;1234&quot;)</span></span><br><span class="line"><span class="keyword">private</span> string password;</span><br></pre></td></tr></table></figure>
<p><strong>使用@Value注入</strong></p>
<h2 id="注入引用类型">注入引用类型</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Datasource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>(Dao dao);</span><br><span class="line">    System.out.println(dao);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>直接在形参声明即可，自动注入</strong></p>
<h1 id="xml配置对比注解配置">XML配置对比注解配置</h1>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 44%" />
<col style="width: 44%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">功能</th>
<th style="text-align: left;">XML配置</th>
<th style="text-align: left;">注解配置</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">定义Bean</td>
<td style="text-align: left;">bean标签<br> • id属性<br> • class属性</td>
<td style="text-align: left;"><span class="citation"
data-cites="Component&lt;br">@Component&lt;br</span>&gt; • <span
class="citation"
data-cites="Controller&lt;br">@Controller&lt;br</span>&gt; • <span
class="citation" data-cites="Service&lt;br">@Service&lt;br</span>&gt; •
<span class="citation"
data-cites="Repository&lt;br">@Repository&lt;br</span>&gt;<span
class="citation" data-cites="ComponentScan">@ComponentScan</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">设置依赖注入</td>
<td style="text-align: left;">setter注入（set方法）<br> •
引用类型/简单类型<br>构造器注入（构造方法）<br> •
引用类型/简单类型<br>自动装配</td>
<td style="text-align: left;"><span class="citation"
data-cites="AutoWired&lt;br">@AutoWired&lt;br</span>&gt; • <span
class="citation"
data-cites="Qualifier&lt;br">@Qualifier&lt;br</span>&gt;<span
class="citation" data-cites="Value">@Value</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">配置第三方Bean</td>
<td
style="text-align: left;">bean标签<br>静态工厂、实例工厂、FactoryBean</td>
<td style="text-align: left;"><span class="citation"
data-cites="Bean">@Bean</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">作用范围</td>
<td style="text-align: left;">• scope属性</td>
<td style="text-align: left;"><span class="citation"
data-cites="Scope">@Scope</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">生命周期</td>
<td style="text-align: left;">标椎接口<br> • init-method<br> •
destroy-method</td>
<td style="text-align: left;"><span class="citation"
data-cites="PostConstructor&lt;br">@PostConstructor&lt;br</span>&gt;<span
class="citation" data-cites="PreDestroy">@PreDestroy</span></td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM04-Spring整合MyBatis</title>
    <url>/posts/10304.html</url>
    <content><![CDATA[<p>详细的描述了Spring整合myBatis和Spring整合Junit。 <span id="more"></span></p>
<h1 id="spring整合mybatis">Spring整合myBatis</h1>
<p>正常的mybatis核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//----------------------------------------------------------------------------------------------------//</span></span><br><span class="line">        <span class="comment">// 1. 创建SqlSessionFactoryBuilder对象</span></span><br><span class="line">        <span class="type">SqlSessionFactoryBuilder</span> <span class="variable">sqlSessionFactoryBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>();</span><br><span class="line">        <span class="comment">// 2. 加载SqlMapConfig.xml配置文件</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;SqlMapConfig.xml.bak&quot;</span>);</span><br><span class="line">        <span class="comment">// 3. 创建SqlSessionFactory对象</span></span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build(inputStream);</span><br><span class="line"><span class="comment">//---------------------------------  一、初始化SqlSessionFactory对象   ----------------------------------//</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 获取SqlSession</span></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">        <span class="comment">// 5. 执行SqlSession对象执行查询，获取结果User</span></span><br><span class="line">        <span class="type">AccountDao</span> <span class="variable">accountDao</span> <span class="operator">=</span> sqlSession.getMapper(AccountDao.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------------------------  二、获取连接，获取实现   --------------------------------------------//</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Account</span> <span class="variable">ac</span> <span class="operator">=</span> accountDao.findById(<span class="number">2</span>);</span><br><span class="line">        System.out.println(ac);</span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------------------------  三、获取数据层接口   -----------------------------------------------//</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 释放资源</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------------------------  四、关闭连接   ----------------------------------------------------//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么上述的代码需要将那个核心对象放入IoC中进行管理呢</p>
<p><strong>SqlSessionFactory</strong> 最核心</p>
<h2 id="原来的整合方法">原来的整合方法</h2>
<p>xml配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;jdbc.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.itheima.domain&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.itheima.dao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>主函数：</p>
<p>即上述的mybatis核心代码</p>
<p><strong>注意：xml配置与配置类的写法一一对应，原来的配置文件被新的配置类所代替，如下位配置类。</strong></p>
<h2 id="更改后的">更改后的</h2>
<p>配置类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.mybatis.spring.SqlSessionFactoryBean;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.mapper.MapperScannerConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisConfig</span> &#123;</span><br><span class="line">    <span class="comment">//定义bean，SqlSessionFactoryBean，用于产生SqlSessionFactory对象</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactoryBean <span class="title function_">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">SqlSessionFactoryBean</span> <span class="variable">ssfb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">        ssfb.setTypeAliasesPackage(<span class="string">&quot;com.itheima.domain&quot;</span>);</span><br><span class="line">        ssfb.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> ssfb;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义bean，返回MapperScannerConfigurer对象</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MapperScannerConfigurer <span class="title function_">mapperScannerConfigurer</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MapperScannerConfigurer</span> <span class="variable">msc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MapperScannerConfigurer</span>();</span><br><span class="line">        msc.setBasePackage(<span class="string">&quot;com.itheima.dao&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> msc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意在主配置类中添加当前配置类的扫描</p>
<p>注意：第二种方法中 pom.xml 新增两个坐标</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>主函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.itheima.config.SpringConfig;</span><br><span class="line"><span class="keyword">import</span> com.itheima.domain.Account;</span><br><span class="line"><span class="keyword">import</span> com.itheima.service.AccountService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">AccountService</span> <span class="variable">accountService</span> <span class="operator">=</span> ctx.getBean(AccountService.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">Account</span> <span class="variable">ac</span> <span class="operator">=</span> accountService.findById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(ac);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="spring整合junit">Spring整合Junit</h1>
<p>新增依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试样例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.service;</span><br><span class="line"></span><br><span class="line">import com.itheima.config.SpringConfig;</span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.test.context.ContextConfiguration;</span><br><span class="line">import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line">//设置类运行器</span><br><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">//设置Spring环境对应的配置类</span><br><span class="line">@ContextConfiguration(classes = SpringConfig.class)</span><br><span class="line">public class AccountServiceTest &#123;</span><br><span class="line">    //支持自动装配注入bean</span><br><span class="line">    @Autowired</span><br><span class="line">    private AccountService accountService;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testFindById()&#123; System.out.println(accountService.findById(1)); &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testFindAll()&#123; System.out.println(accountService.findAll()); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意两点</p>
<blockquote>
<ul>
<li><p>设置类运行器：<span class="citation"
data-cites="RunWith">@RunWith</span>(SpringJUnit4ClassRunner.class)</p>
<p>设置Spring环境对应的配置类：<span class="citation"
data-cites="ContextConfiguration">@ContextConfiguration</span>(classes =
SpringConfig.class)</p></li>
<li><p>想用什么用@Autowired自动注入即可</p></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM05-Spring中的AOP概念</title>
    <url>/posts/10305.html</url>
    <content><![CDATA[<p>详细的描述了Spring中的AOP概念。 <span id="more"></span></p>
<h1 id="aop简介">AOP简介</h1>
<h2 id="基础概念">基础概念</h2>
<p><strong>AOP(Aspect Oriented
Programming)面向切面编程，一种编程范式，指导开发者如何组织程序结构</strong></p>
<p>​ <strong>OOP(object Oriented Programming)面向对象编程</strong></p>
<p><strong>作用：在不惊动原始设计的基础上为其进行功能增强</strong></p>
<p><strong>Spring理念：无入侵式/无侵入式</strong></p>
<h2 id="核心概念">核心概念</h2>
<ol type="1">
<li><p>连接点 ( JoinPoint
)：程序执行过程中的任意位置，粒度为执行方法、抛出异常、设置变量等</p>
<ul>
<li><p>在SpringAOP中，理解为方法的执行</p></li>
<li><p>切入点 ( Pointcut )：匹配连接点的式子</p>
<ul>
<li>在springAoP中，一个切入点可以只描述一个具体方法，也可以匹配多个方法
<ul>
<li>一个具体方法:
com.itheima.dao包下的BookDao接口中的无形参无返回值的save方法</li>
<li>匹配多个方法:所有的save方法，所有的get开头的方法，所有以Dao结尾的接口中的任意方法，所有带有一个参数的方法</li>
</ul></li>
</ul></li>
</ul></li>
<li><p>通知(Advice) ：在切入点处执行的操作，也就是共性功能</p>
<ul>
<li>在SpringAOP中，功能最终以方法的形式呈现</li>
</ul></li>
<li><p>通知类∶定义通知的类</p></li>
<li><p>切面( Aspect )︰描述通知与切入点的对应关系</p></li>
</ol>
<p>样例（源自黑马程序员，<strong>侵删</strong>）</p>
<figure>
<img src="https://wang-nine.cn/images/SSM04-01AOP%E6%A0%B7%E4%BE%8B.png"
alt="SSM04-01AOP样例" />
<figcaption aria-hidden="true">SSM04-01AOP样例</figcaption>
</figure>
<h1 id="aop入门案例">AOP入门案例</h1>
<p>案例设定:测定接口执行效率 简化设定:在接口执行前输出当前系统时间
开发模式:XML or <strong>注解</strong></p>
<p>思路分析∶</p>
<ol type="1">
<li>导入坐标（ pom.xml )</li>
<li>制作连接点方法（原始操作，Dao接口与实现类）</li>
<li>制作共性功能（通知类与通知)</li>
<li>定义切入点</li>
<li>绑定切入点与通知关系（切面)</li>
</ol>
<p>基础代码样例（源自黑马程序员）：</p>
<ol type="1">
<li>导入坐标</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>切面类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(切入点表达式)&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------------&quot;</span>);</span><br><span class="line">        <span class="type">Long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;<span class="number">10000</span> ; i++) &#123;</span><br><span class="line">            <span class="comment">//调用原始操作</span></span><br><span class="line">            pjp.proceed();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">Long</span> <span class="variable">totalTime</span> <span class="operator">=</span> endTime-startTime;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行万次消耗时间：&quot;</span> + totalTime + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>主配置类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">加上注解 <span class="meta">@EnableAspectJAutoProxy</span></span><br></pre></td></tr></table></figure>
<p>剩余的代码不变，例如Dao接口和实现类，主函数</p>
<p>以上步骤总结：</p>
<ol type="1">
<li>导入AOP坐标</li>
<li>定义dao接口与实现类</li>
<li>定义通知类，制作通知</li>
<li>定义切入点
<strong>说明︰切入点定义依托一个不具有实际意义的方法进行，即无参数，无返回值，方法体无实际逻辑</strong></li>
<li>绑定切入点与通知关系，并指定通知添加到原始连接点的具体执行<strong>位置</strong></li>
<li>定义通知类受Spring容器管理，并定义当前类为切面类，即添加
<strong><span class="citation"
data-cites="Component">@Component</span></strong> 和 <strong><span
class="citation" data-cites="Aspect">@Aspect</span></strong></li>
<li>开启Spring对AOP注解驱动支持，即在主配置类添加 <strong><span
class="citation"
data-cites="EnableAspectJAutoProxy">@EnableAspectJAutoProxy</span></strong></li>
</ol>
<h1 id="aop工作流程">AOP工作流程</h1>
<ol type="1">
<li>Spring容器启动</li>
<li>读取所有切面配置中的切入点</li>
<li>初始化bean，判定bean对应的类中的方法是否匹配到任意切入点
<ul>
<li>匹配失败：创建对象</li>
<li>匹配成功：创建原始对象（<strong>目标对象</strong>）的<strong>代理对象</strong></li>
</ul></li>
<li>获取bean的执行方法
<ul>
<li>获取bean，调用方法并执行，完成操作</li>
<li>获取的bean是代理对象时，根据代理对象的运行模式运行原始方法与增强的内容，完成操作</li>
</ul></li>
</ol>
<ul>
<li>目标对象（Target
）：原始功能去掉共性功能对应的类产生的对象，这种对象是无法直接完成最终工作的</li>
<li>代理（Proxy）：目标对象无法直接完成工作，需要对其进行功能回填，通过原始对象的代理对象实现</li>
</ul>
<h1 id="aop深入">AOP深入</h1>
<h2 id="aop的切入点表达式">AOP的切入点表达式</h2>
<p>切入点∶要进行增强的方法 切入点表达式∶要进行增强的方法的描述方式</p>
<h3 id="语法格式">语法格式</h3>
<p><strong>即可以对接口进行描述，也可以对实现类进行描述</strong></p>
<h4 id="切入点表达式标准格式">切入点表达式标准格式</h4>
<p>动作关键字（访问修饰符
返回值.包名.类/接口名.方法名（参数）异常名)</p>
<blockquote>
<p>execution (public User com.xxx.service.UserService.findById
(int))</p>
</blockquote>
<ul>
<li>动作关键字∶描述切入点的行为动作，例如execution表示执行到指定切入点</li>
<li>访问修饰符：public , private等，可以省略</li>
<li>返回值</li>
<li>包名</li>
<li>类/接口名</li>
<li>方法名</li>
<li>参数</li>
<li>异常名：方法定义中抛出指定异常，可以省略</li>
</ul>
<h4
id="可以使用通配符描述切入点快速描述">可以使用通配符描述切入点，快速描述</h4>
<ul>
<li><p>*
︰单个独立的任意符号，可以独立出现，也可以作为前缀或者后缀的匹配符出现</p>
<blockquote>
<p>execution (public * com.xxx.*.UserService.find*(*))
匹配com.xxx包下的任意包中的UserService类或接口中所有find开头的带有一个参数的方法</p>
</blockquote></li>
<li><p>.. ：多个连续的任意符号，可以独立出现，常用于简化包名与参数的书写
&gt; execution (public User com..UserService.findById (..) ) &gt;
匹配com包下的任意包中的UserService类或接口中所有名称为findByld的方法</p></li>
<li><p>+︰专用于匹配子类类型 execution(* *..*Service+.*(..))</p></li>
</ul>
<h4 id="切入点表达式的书写技巧">切入点表达式的书写技巧</h4>
<ul>
<li>所有代码按照标准规范开发，否则以下技巧全部失效</li>
<li>描述切入点<strong>通常描述接口</strong>，而不描述实现类</li>
<li>访问控制修饰符针对接口开发均采用public描述（<strong>可省略访问控制修饰符描述</strong>）</li>
<li>返回值类型对于增删改类使用精准类型加速匹配，对于查询类使用*通配快速描述</li>
<li><strong>包名</strong>书写<strong>尽量不使用..匹配</strong>，效率过低，常用*做单个包描述匹配，或精准匹配</li>
<li><strong>接口名</strong>/类名书写名称与模块相关的<strong>采用*匹配</strong>，例如UserService书写成*Service，绑定业务层接口名</li>
<li><strong>方法名</strong>书写以<strong>动词进行精准匹配</strong>，名词采用*匹配，例如getByld书写成getBy*,selectAll书写成selectAll</li>
<li>参数规则较为复杂，根据业务方法灵活调整</li>
<li>通常<strong>不使用异常作为匹配规则</strong></li>
</ul>
<h1 id="aop通知类型">AOP通知类型</h1>
<p><strong>AOP通知描述了抽取的共性功能，根据共性功能抽取的位置不同，最终运行代码时要将其加入到合理的位置AOP通知共分为5种类型</strong></p>
<ul>
<li>前置通知 <strong><span class="citation"
data-cites="Before">@Before</span></strong></li>
<li>后置通知 <strong><span class="citation"
data-cites="After">@After</span></strong></li>
<li>环绕通知（<strong>重点</strong>） <strong><span class="citation"
data-cites="Around">@Around</span></strong>
<strong>需要对原始操作进行调用</strong></li>
<li>返回后通知（了解） <strong><span class="citation"
data-cites="AfterReturning">@AfterReturning</span></strong>
正常运行完才会运行</li>
<li>抛出异常后通知（了解） <strong><span class="citation"
data-cites="AfterThrowing">@AfterThrowing</span></strong>
抛出异常才会运行</li>
</ul>
<p>环绕通知对原始操作的调用样例（<strong>注意有返回值时需要返回原始操作的返回值</strong>）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;around before advice ...&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;around after advice ...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong><span class="citation"
data-cites="Around注意事项">@Around注意事项</span></strong></p>
<ol type="1">
<li>环绕通知必须依赖形参ProceedingJoinPoint才能实现对原始方法的调用，进而实现原始方法调用前后同时添加通知</li>
<li>通知中如果未使用ProceedingJoinPoint对原始方法进行调用将跳过原始方法的执行</li>
<li>对原始方法的调用可以不接收返回值，通知方法设置成void即可，如果接收返回值，必须设定为Object类型</li>
<li>原始方法的返回值如果是void类型，通知方法的返回值类型可以设置成void，也可以设置成Object</li>
<li>由于无法预知原始方法运行后是否会抛出异常，因此环绕通知方法必须抛出Throwable对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">signature</span> <span class="variable">signature</span> <span class="operator">=</span> pjp.getsignature();	<span class="comment">//获取代理类和被代理类的信息。</span></span><br><span class="line">system.out.println(signature.getDeclaringTypeName());	<span class="comment">//获取原始方法的类名</span></span><br><span class="line">system.out.println(signature.getName());	<span class="comment">//获取原始方法的方法名</span></span><br></pre></td></tr></table></figure>
<h1 id="aop通知获取数据">AOP通知获取数据</h1>
<h2 id="获取参数">获取参数</h2>
<p>获取切入点方法的参数</p>
<ul>
<li><p>JoinPoint :适用于前置、后置、返回后、抛出异常后通知</p></li>
<li><p>ProceedJointPoint :适用于环绕通知</p></li>
</ul>
<h2 id="获取返回值">获取返回值</h2>
<p>获取切入点方法返回值</p>
<ul>
<li><p>返回后通知</p></li>
<li><p>环绕通知</p></li>
</ul>
<h2 id="获取异常">获取异常</h2>
<p>获取切入点方法运行异常信息</p>
<ul>
<li><p>抛出异常后通知</p></li>
<li><p>环绕通知</p></li>
</ul>
<p>样例代码如下（来自黑马程序员，侵删）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.itheima.dao.BookDao.findName(..))&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//JoinPoint：用于描述切入点的对象，必须配置成通知方法中的第一个参数，可用于获取原始方法调用的参数</span></span><br><span class="line"><span class="comment">//    @Before(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint jp)</span> &#123;</span><br><span class="line">        Object[] args = jp.getArgs();</span><br><span class="line">        System.out.println(Arrays.toString(args));</span><br><span class="line">        System.out.println(<span class="string">&quot;before advice ...&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    @After(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">(JoinPoint jp)</span> &#123;</span><br><span class="line">        Object[] args = jp.getArgs();</span><br><span class="line">        System.out.println(Arrays.toString(args));</span><br><span class="line">        System.out.println(<span class="string">&quot;after advice ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ProceedingJoinPoint：专用于环绕通知，是JoinPoint子类，可以实现对原始方法的调用</span></span><br><span class="line"><span class="comment">//    @Around(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> &#123;</span><br><span class="line">        Object[] args = pjp.getArgs();</span><br><span class="line">        System.out.println(Arrays.toString(args));</span><br><span class="line">        args[<span class="number">0</span>] = <span class="number">666</span>;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ret = pjp.proceed(args);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            t.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置返回后通知获取原始方法的返回值，要求returning属性值必须与方法形参名相同</span></span><br><span class="line">    <span class="meta">@AfterReturning(value = &quot;pt()&quot;,returning = &quot;ret&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">(JoinPoint jp,String ret)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterReturning advice ...&quot;</span>+ret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置抛出异常后通知获取原始方法运行时抛出的异常对象，要求throwing属性值必须与方法形参名相同</span></span><br><span class="line">    <span class="meta">@AfterThrowing(value = &quot;pt()&quot;,throwing = &quot;t&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterThrowing advice ...&quot;</span>+t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM07-SpringMVC的请求与响应</title>
    <url>/posts/10307.html</url>
    <content><![CDATA[<p>详细的描述了SpringMVC中的请求与响应 <span id="more"></span></p>
<h1 id="springmvc概述">SpringMVC概述</h1>
<p>SpringMVC是一种基于Java实现MVC模型的轻量级web框架</p>
<p>优点</p>
<ul>
<li>使用简单，开发便捷（相比于Servlet）</li>
<li>灵活性强</li>
</ul>
<h1 id="样例">样例</h1>
<h2 id="样例代码">样例代码</h2>
<ol type="1">
<li>使用SpringMVC技术需要先导入SpringMIVC坐标与Servlet坐标</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;<span class="number">3.1</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">  &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;<span class="number">5.2</span><span class="number">.10</span>.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>创建SpringMvc控制器类（等同于servlet功能）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.定义Controller</span></span><br><span class="line"><span class="comment">// 2.1 使用Controller定义Bean</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="comment">// 2.2 设置当前操作的访问路径</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line">    <span class="comment">// 2.3 设置当前操作的返回值类型</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user save...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;moudle&#x27; : &#x27;springmvc&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>初始化SpringMVC环境(同Spring环境)，设定SpringMVC加载对应的bean</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3.创建springmvc的配置文件，加载controller对应的Bean</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.wang.controller&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li>初始化Servlet容器，加载SpringMVC环境，并设置SpringMVC技术处理的请求</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 4.定义一个Servlet容器启动的配置类，在里面加载spring的配置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletContainerInitConfig</span> <span class="keyword">extends</span> <span class="title class_">AbstractDispatcherServletInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载springmvc容器配置</span></span><br><span class="line">    <span class="keyword">protected</span> WebApplicationContext <span class="title function_">createServletApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigWebApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigWebApplicationContext</span>();</span><br><span class="line">        ctx.register(SpringMvcConfig.class);</span><br><span class="line">        <span class="keyword">return</span> ctx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置哪些请求归属springmvc处理</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载spring容器配置</span></span><br><span class="line">    <span class="keyword">protected</span> WebApplicationContext <span class="title function_">createRootApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigWebApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigWebApplicationContext</span>();</span><br><span class="line">        ctx.register(SpringConfig.class);</span><br><span class="line">        <span class="keyword">return</span> ctx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述案例中用到的注解说明：</p>
<ul>
<li><span class="citation"
data-cites="Controller">@Controller</span></li>
</ul>
<blockquote>
<p>类注解，放置于SpringMVC控制器定义上方，作用为设定SpringMVC的核心控制器Bean</p>
</blockquote>
<ul>
<li><span class="citation"
data-cites="RequestMapping">@RequestMapping</span></li>
</ul>
<blockquote>
<p>方法注解，放置于SpringMVC控制器方法上方，作用为设定当前控制器方法的请求访问路径</p>
</blockquote>
<ul>
<li><span class="citation"
data-cites="ResponseBody">@ResponseBody</span></li>
</ul>
<blockquote>
<p>方法注解，放置于SpringMVC控制器方法上方，作用为设置当前控制器方法的响应内容为当前返回值，无需解析</p>
</blockquote>
<ul>
<li><span class="citation"
data-cites="ComponentScan">@ComponentScan</span></li>
</ul>
<blockquote>
<p>属性1：excludeFilters：排除扫描路径中加载的bean，需要指定类别(type)与具体项(classes)</p>
<p>属性2：includeFilters：加载指定的bean，需要指定类别(type)与具体项(classes)</p>
</blockquote>
<h2
id="springmvc入门程序开发总结1n">SpringMVC入门程序开发总结（1+N）</h2>
<ul>
<li>一次性工作
<ul>
<li>创建工程，设置服务器，加载工程</li>
<li>导入坐标</li>
<li>创建web容器启动类，加载SpringMVC配置，并设置SpringMVC请求拦截路径</li>
<li>SpringMvc核心配置类（设置配置类，扫描controller包，加载Controller控制器bean）</li>
</ul></li>
<li>多次工作
<ul>
<li>定义处理请求的控制器类</li>
<li>定义处理请求的控制器方法，并配置映射路径（<span class="citation"
data-cites="RequestMapping">@RequestMapping</span>）与返回json数据（<span
class="citation" data-cites="ResponseBody">@ResponseBody</span>）</li>
</ul></li>
</ul>
<h2 id="工作流程">工作流程</h2>
<p><strong>启动服务器初始化过程</strong></p>
<ol type="1">
<li>服务器启动，执行ServletcontainersInitConfig类，初始化web容器</li>
<li>执行createServletApplicationcontext方法，创建了webApplicationContext对象</li>
<li>加载SpringMvcConfig</li>
<li>执行@ComponentScan加载对应的bean</li>
<li>加载UserController，每个@RequestMapping的名称对应一个具体的方法</li>
<li>执行getServletMappings方法，定义所有的请求都通过springMVC</li>
</ol>
<h2 id="单次请求过程">单次请求过程</h2>
<ol type="1">
<li>发送请求localhost/save</li>
<li>web容器发现所有请求都经过SpringMVC，将请求交给SpringMVC处理</li>
<li>解析请求路径/save</li>
<li>由/save匹配执行对应的方法save()</li>
<li>执行save()</li>
<li>检测到有@ResponseBody直接将save()方法的返回值作为响应求体返回给请求方</li>
</ol>
<h2 id="问题">问题</h2>
<p>因为功能不同，如何避免Spring错误的加载到SpringMVC的bean？</p>
<p>加载Spring控制的bean的时候排除掉SpringMVC控制的bean</p>
<p>SpringMIVC相关bean(表现层bean)</p>
<p>Spring控制的bean</p>
<ul>
<li>业务bean (Service)</li>
<li>功能bean (DataSource等)</li>
</ul>
<p>SpringMVC相关bean加载控制</p>
<ul>
<li>SpringMVC加载的bean对应的包均在com.xxx.controller包内</li>
</ul>
<p>Spring相关bean加载控制</p>
<ul>
<li>方式一：Spring加载的bean设定扫描范围为com.xxx，排除掉controller包内的bean</li>
<li>方式二：
Spring加载的bean设定扫描范围为精准范围，例如service包、dao包等</li>
<li>方式三：不区分Spring与SpringMVC的环境，加载到同一个环境中</li>
</ul>
<p>方式一如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(value = &quot;com.wang&quot;,</span></span><br><span class="line"><span class="meta">        excludeFilters = @ComponentScan.Filter(</span></span><br><span class="line"><span class="meta">                type = FilterType.ANNOTATION,</span></span><br><span class="line"><span class="meta">                classes = Controller.class</span></span><br><span class="line"><span class="meta">        ))</span></span><br></pre></td></tr></table></figure>
<p>方式二如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(&#123;&quot;com.wang.service&quot;, &quot;com.wang.dao&quot;&#125;)</span></span><br></pre></td></tr></table></figure>
<p>注意：简化开发代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletContainerInitConfig</span> <span class="keyword">extends</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;SpringConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;SpringMvcConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="请求">请求</h1>
<h2 id="设置请求的映射路径">设置请求的映射路径</h2>
<p>团队多人开发，每人设置不同的请求路径，冲突问题如何解决？</p>
<blockquote>
<p>设置模块名作为请求路径前缀</p>
</blockquote>
<p><span class="citation"
data-cites="RequestMapping">@RequestMapping</span>(“/xxx”)</p>
<blockquote>
<p>当写在类上方时，即为统计设置请求路径的前缀，类方法中的@RequestMapping会自动加上前缀</p>
</blockquote>
<p>PostMan发送get请求和post请求</p>
<p>get请求</p>
<p>普通参数：url地址传参，地址参数名与形参变量名相同，定义形参即可接收参数</p>
<p>post请求</p>
<p>普通参数：form表单post请求传参，表单参数名与形参变量名相同，定义形参即可接收参数</p>
<p>post请求中文乱码问题：</p>
<p>为web容器添加过滤器并指定字符集，Spring-web包中提供了专用的字符过滤器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//乱码处理</span></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">protected</span> Filter[] getServletFilters()&#123;</span><br><span class="line">	<span class="type">CharacterEncodingFilter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CharacterEncodingFilter</span>();</span><br><span class="line">    filter.setEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Filter</span>[](filter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参数种类">参数种类</h2>
<p>若传入的属性名与实体类中的属性名一致，则会自动放入实体类中</p>
<p>样例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//请求参数</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//普通参数：请求参数与形参名称对应即可完成参数传递</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/commonParam&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">commonParam</span><span class="params">(String name ,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;普通参数传递 name ==&gt; &quot;</span>+name);</span><br><span class="line">        System.out.println(<span class="string">&quot;普通参数传递 age ==&gt; &quot;</span>+age);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;common param&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//普通参数：请求参数名与形参名不同时，使用@RequestParam注解关联请求参数名称与形参名称之间的关系</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/commonParamDifferentName&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">commonParamDifferentName</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String userName , <span class="type">int</span> age)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;普通参数传递 userName ==&gt; &quot;</span>+userName);</span><br><span class="line">        System.out.println(<span class="string">&quot;普通参数传递 age ==&gt; &quot;</span>+age);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;common param different name&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//POJO参数：请求参数与形参对象中的属性对应即可完成参数传递</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/pojoParam&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">pojoParam</span><span class="params">(User user)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;pojo参数传递 user ==&gt; &quot;</span>+user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;pojo param&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//嵌套POJO参数：嵌套属性按照层次结构设定名称即可完成参数传递</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/pojoContainPojoParam&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">pojoContainPojoParam</span><span class="params">(User user)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;pojo嵌套pojo参数传递 user ==&gt; &quot;</span>+user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;pojo contain pojo param&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数组参数：同名请求参数可以直接映射到对应名称的形参数组对象中</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/arrayParam&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">arrayParam</span><span class="params">(String[] likes)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;数组参数传递 likes ==&gt; &quot;</span>+ Arrays.toString(likes));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;array param&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//集合参数：同名请求参数可以使用@RequestParam注解映射到对应名称的集合对象中作为数据</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/listParam&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">listParam</span><span class="params">(<span class="meta">@RequestParam</span> List&lt;String&gt; likes)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;集合参数传递 likes ==&gt; &quot;</span>+ likes);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;list param&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//集合参数：json格式</span></span><br><span class="line">    <span class="comment">//1.开启json数据格式的自动转换，在配置类中开启@EnableWebMvc</span></span><br><span class="line">    <span class="comment">//2.使用@RequestBody注解将外部传递的json数组数据映射到形参的集合对象中作为数据</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/listParamForJson&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">listParamForJson</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;String&gt; likes)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;list common(json)参数传递 list ==&gt; &quot;</span>+likes);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;list common for json param&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//POJO参数：json格式</span></span><br><span class="line">    <span class="comment">//1.开启json数据格式的自动转换，在配置类中开启@EnableWebMvc</span></span><br><span class="line">    <span class="comment">//2.使用@RequestBody注解将外部传递的json数据映射到形参的实体类对象中，要求属性名称一一对应</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/pojoParamForJson&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">pojoParamForJson</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;pojo(json)参数传递 user ==&gt; &quot;</span>+user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;pojo for json param&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//集合参数：json格式</span></span><br><span class="line">    <span class="comment">//1.开启json数据格式的自动转换，在配置类中开启@EnableWebMvc</span></span><br><span class="line">    <span class="comment">//2.使用@RequestBody注解将外部传递的json数组数据映射到形参的保存实体类对象的集合对象中，要求属性名称一一对应</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/listPojoParamForJson&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">listPojoParamForJson</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;User&gt; list)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;list pojo(json)参数传递 list ==&gt; &quot;</span>+list);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;list pojo for json param&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//日期参数</span></span><br><span class="line">    <span class="comment">//使用@DateTimeFormat注解设置日期类型数据格式，默认格式yyyy/MM/dd</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/dataParam&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">dataParam</span><span class="params">(Date date,</span></span><br><span class="line"><span class="params">                            <span class="meta">@DateTimeFormat(pattern=&quot;yyyy-MM-dd&quot;)</span> Date date1,</span></span><br><span class="line"><span class="params">                            <span class="meta">@DateTimeFormat(pattern=&quot;yyyy/MM/dd HH:mm:ss&quot;)</span> Date date2)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;参数传递 date ==&gt; &quot;</span>+date);</span><br><span class="line">        System.out.println(<span class="string">&quot;参数传递 date1(yyyy-MM-dd) ==&gt; &quot;</span>+date1);</span><br><span class="line">        System.out.println(<span class="string">&quot;参数传递 date2(yyyy/MM/dd HH:mm:ss) ==&gt; &quot;</span>+date2);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;data param&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<h3 id="普通的形参">普通的形参</h3>
<p>若形参与请求参数名称相同，则会自动绑定</p>
<p><span class="citation"
data-cites="RequestParam">@RequestParam</span></p>
<blockquote>
<p>可以绑定请求参数与处理器方法形参之间的关系</p>
<p>参数：required:是否为必传参数 defaultValue:参数默认值</p>
</blockquote>
<h3 id="pojo参数">Pojo参数</h3>
<p>请求参数名与形参对象属性名相同，定义PO30类型形参即可接收参数</p>
<h3 id="嵌套的pojo参数">嵌套的Pojo参数</h3>
<p>请求参数名与形参对象属性名相同，按照对象层次结构关系即可接收嵌套POJo属性参数</p>
<h3 id="数组参数">数组参数</h3>
<p>请求参数名与形参对象属性名相同且请求参数为多个，定义数组类型形参即可接收参数</p>
<h3 id="集合保存普通参数">集合保存普通参数</h3>
<p>请求参数名与形参集合对象名相同且请求参数为多个，<span
class="citation"
data-cites="RequestParam绑定参数关系">@RequestParam绑定参数关系</span></p>
<h3 id="json-数据参数">json 数据参数</h3>
<p>四个步骤：</p>
<ol type="1">
<li>pom.xml中添加json坐标</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>主配置类中加入注解</li>
</ol>
<p><span class="citation"
data-cites="EnableWebMvc">@EnableWebMvc</span></p>
<blockquote>
<p>开启由json对象装换位对象的功能</p>
</blockquote>
<ol start="3" type="1">
<li>postman中传入参数</li>
<li>在参数前面加上@RequestBody</li>
</ol>
<ul>
<li>json数组</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span><span class="string">&quot;game&quot;</span><span class="punctuation">,</span><span class="string">&quot;music&quot;</span><span class="punctuation">,</span><span class="string">&quot;hobby&quot;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>json对象(Pojo)</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;wang&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">15</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;address&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;province&quot;</span><span class="punctuation">:</span><span class="string">&quot;beijing&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;city&quot;</span><span class="punctuation">:</span><span class="string">&quot;beijing&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>json数组(Pojo)</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;wang&quot;</span><span class="punctuation">,</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">9</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;nine&quot;</span><span class="punctuation">,</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">99</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<h3 id="requestbody与requestparam区别"><span class="citation"
data-cites="RequestBody与">@RequestBody与</span><span class="citation"
data-cites="RequestParam区别">@RequestParam区别</span></h3>
<ul>
<li><p>区别</p>
<ul>
<li><p><span class="citation"
data-cites="RequestParam用于接收url地址传参">@RequestParam用于接收url地址传参</span>，表单传参【application/x-www-form-urlencoded】</p></li>
<li><p><span class="citation"
data-cites="RequestBody用于接收json数据">@RequestBody用于接收json数据</span>【application/json】</p></li>
</ul></li>
<li><p>应用</p>
<ul>
<li>后期开发中，发送json格式数据为主，<span class="citation"
data-cites="RequestBody应用较广">@RequestBody应用较广</span></li>
<li>如果发送非json格式数据，选用@Requestparam接收请求参数</li>
</ul></li>
</ul>
<h2 id="日期格式参数">日期格式参数</h2>
<p><span class="citation"
data-cites="DateTimeFormat">@DateTimeFormat</span>(patter=“yyyy-MM-dd”)</p>
<blockquote>
<p>指定日期的格式</p>
</blockquote>
<h3 id="类型转换器">类型转换器</h3>
<ul>
<li>Convert接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Converter</span>&lt;S, T&gt; &#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    T <span class="title function_">convert</span><span class="params">(S var1)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="响应">响应</h1>
<ul>
<li>响应页面</li>
<li>响应数据
<ul>
<li>文本数据</li>
<li>json数据</li>
</ul></li>
</ul>
<p>样例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//响应页面/跳转页面</span></span><br><span class="line">    <span class="comment">//返回值为String类型，设置返回值为页面名称，即可实现页面跳转</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/toJumpPage&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toJumpPage</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;跳转页面&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;page.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//响应文本数据</span></span><br><span class="line">    <span class="comment">//返回值为String类型，设置返回值为任意字符串信息，即可实现返回指定字符串信息，需要依赖@ResponseBody注解</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/toText&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toText</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;返回纯文本数据&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;response text&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//响应POJO对象</span></span><br><span class="line">    <span class="comment">//返回值为实体类对象，设置返回值为实体类类型，即可实现返回对应对象的json数据，需要依赖@ResponseBody注解和@EnableWebMvc注解</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/toJsonPOJO&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">toJsonPOJO</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;返回json对象数据&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">        user.setAge(<span class="number">15</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//响应POJO集合对象</span></span><br><span class="line">    <span class="comment">//返回值为集合对象，设置返回值为集合类型，即可实现返回对应集合的json数组数据，需要依赖@ResponseBody注解和@EnableWebMvc注解</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/toJsonList&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">toJsonList</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;返回json集合数据&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user1.setName(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        user1.setAge(<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user2.setName(<span class="string">&quot;Jerry&quot;</span>);</span><br><span class="line">        user2.setAge(<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; userList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;User&gt;();</span><br><span class="line">        userList.add(user1);</span><br><span class="line">        userList.add(user2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> userList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span class="citation"
data-cites="ResponseBody">@ResponseBody</span></p>
<blockquote>
<p>方法注解，SpringMVC控制器方法定义上方，设置当前控制器方法响应内容为当前返回值，无需解析</p>
</blockquote>
<p>内部是由类型转换器 HttpMessageConverter 接口发挥作用</p>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM08-REST风格</title>
    <url>/posts/10308.html</url>
    <content><![CDATA[<p>详细的描述了Spring中的REST开发风格 <span id="more"></span></p>
<h1 id="rest简介">REST简介</h1>
<p>REST (Representational state Transfer)，表现形式状态转换</p>
<ul>
<li><p>传统风格资源描述形式</p>
<ul>
<li><p>http://localhost/user/getById?id=1</p></li>
<li><p>http://localhost/user/saveUser</p></li>
</ul></li>
<li><p>REST风格描述形式</p>
<ul>
<li>http://localhost/user/1</li>
<li>http://localhost/user</li>
</ul></li>
<li><p>优点:</p>
<ul>
<li>隐藏资源的访问行为，无法通过地址得知对资源是何种操作</li>
<li>书写简化</li>
</ul></li>
<li><p>按照REST风格访问资源时使用行为动作区分对资源进行了何种操作</p>
<ul>
<li>http://localhost/users 查询全部用户信息 GET(查询)</li>
<li>http://localhost/users/1 查询指定用户信息 GET(查询)</li>
<li>http://localhost/users 添加用户信息 POST(新增/保存)</li>
<li>http://localhost/users 修改用户信息 PUT(修改/更新)</li>
<li>http://localhost/users/1 删除用户信息 DELETE(删除)</li>
</ul></li>
<li><p>根据REST风格对资源进行访问称为 RESTful</p></li>
</ul>
<blockquote>
<p>注意事项
上述行为是约定方式，约定不是规范，可以打破，所以称REST风格，而不是REST规范
描述模块的名称通常使用复数，也就是加s的格式描述，表示此类资源，而非单个资源，例如:
users、books、account..</p>
</blockquote>
<h1 id="样例">样例</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置当前请求方法为POST，表示REST风格中的添加操作</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/users&quot;,method = RequestMethod.POST)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;user save...&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;user save&#x27;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置当前请求方法为DELETE，表示REST风格中的删除操作</span></span><br><span class="line"><span class="comment">//@PathVariable注解用于设置路径变量（路径参数），要求路径上设置对应的占位符，并且占位符名称与方法形参名称相同</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/users/&#123;id&#125;&quot;,method = RequestMethod.DELETE)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">delete</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;user delete...&quot;</span> + id);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;user delete&#x27;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span class="citation"
data-cites="RequestMapping">@RequestMapping</span></p>
<blockquote>
<p>方法注解，SpringMVC控制器方法定义上方，设置当前控制器方法请求访问路径</p>
<ul>
<li>属性
<ul>
<li>value (默认)：请求访问路径</li>
<li>method：http请求动作，标准动作(GET/POST/PUT/DELETE)</li>
</ul></li>
<li>放在类上方时，即设置了公共路径</li>
</ul>
</blockquote>
<p><strong><span class="citation"
data-cites="RequestBody">@RequestBody</span> <span class="citation"
data-cites="RequestParam">@RequestParam</span> <span class="citation"
data-cites="Pathvariable">@Pathvariable</span></strong></p>
<ul>
<li>区别
<ul>
<li><span class="citation"
data-cites="RequestParam用于接收url地址传参或表单传参">@RequestParam用于接收url地址传参或表单传参</span></li>
<li><span class="citation"
data-cites="RequestBody用于接收json数据">@RequestBody用于接收json数据</span></li>
<li><span class="citation"
data-cites="Pathvariable用于接收路径参数">@Pathvariable用于接收路径参数</span>，使用{参数名称}描述路径参数</li>
</ul></li>
<li>应用
<ul>
<li>后期开发中，发送请求参数超过1个时，以json格式为主，<span
class="citation"
data-cites="RequestBody应用较广">@RequestBody应用较广</span></li>
<li>如果发送非json格式数据，选用@RequestParam接收请求参数</li>
<li>采用RESTful进行开发，当参数数量较少时，例如1个，可以采用@PathVariable接收请求路径变量，通常用于传递id值</li>
</ul></li>
</ul>
<p><span class="citation"
data-cites="RestController">@RestController</span></p>
<blockquote>
<p>类注解</p>
<p><span class="citation"
data-cites="RestController">@RestController</span> = <span
class="citation" data-cites="ResponseBody">@ResponseBody</span> + <span
class="citation" data-cites="Controller">@Controller</span></p>
</blockquote>
<p><span class="citation" data-cites="GetMapping">@GetMapping</span>
<span class="citation" data-cites="PostMapping">@PostMapping</span>
<span class="citation" data-cites="PutMapping">@PutMapping</span> <span
class="citation" data-cites="DeleteMapping">@DeleteMapping</span></p>
<blockquote>
<p>方法注解 基于SpringMVC的RESTful开发控制器方法定义上方
设置当前控制器方法请求访问路径与请求动作，每种对应一个请求动作，例如@GetMapping对应GET请求</p>
</blockquote>
<p>注意直接访问页面会404，需要添加访问过滤，本来使用Tomcat负责，现在由SpringMVC拦截，需要放行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcSupport</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurationSupport</span> &#123;</span><br><span class="line">    <span class="comment">//设置静态资源访问过滤，当前类需要设置为配置类，并被扫描加载</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">//当访问/pages/????时候，从/pages目录下查找内容</span></span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/pages/**&quot;</span>).addResourceLocations(<span class="string">&quot;/pages/&quot;</span>);</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/js/**&quot;</span>).addResourceLocations(<span class="string">&quot;/js/&quot;</span>);</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/css/**&quot;</span>).addResourceLocations(<span class="string">&quot;/css/&quot;</span>);</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/plugins/**&quot;</span>).addResourceLocations(<span class="string">&quot;/plugins/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM09-SSM整合</title>
    <url>/posts/10309.html</url>
    <content><![CDATA[<p>详细的描述了Spring中的SSM整合 <span id="more"></span></p>
<h1 id="ssm整合流程">SSM整合流程</h1>
<h2 id="创建工程">1.创建工程</h2>
<h2 id="ssm整合">2.SSM整合</h2>
<ul>
<li>Spring
<ul>
<li>SpringConfig</li>
</ul></li>
<li>MyBatis
<ul>
<li>MybatisConfig</li>
<li>JdbcConfig</li>
<li>Jdbc.properties</li>
</ul></li>
<li>SpringMVC
<ul>
<li>ServletConfig</li>
<li>SpringMVCConfig</li>
</ul></li>
</ul>
<h2 id="功能模块">3.功能模块</h2>
<ul>
<li>表与实体类</li>
<li>dao（接口+自动代理）</li>
<li>service（接口+实现类）</li>
<li>业务层接口测试（整合JUnit）</li>
<li>controller表现层接口测试（PostMan）</li>
</ul>
<h1 id="设计一个简单的图书管理系统">设计一个简单的图书管理系统</h1>
<h2 id="总体思路分析">总体思路分析</h2>
<h3 id="spring整合mybatis">Spring整合MyBatis</h3>
<ul>
<li>配置
<ul>
<li>SpringConfig</li>
<li>JDBCConfig、jdbc.properties</li>
<li>MyBatisconfig</li>
</ul></li>
<li>模型
<ul>
<li>Book</li>
</ul></li>
<li>数据层标准开发
<ul>
<li>BookDao</li>
</ul></li>
<li>业务层标准开发
<ul>
<li>BookService</li>
<li>BookServiceImpl</li>
</ul></li>
<li>测试接口 BookServiceTest</li>
<li>事务处理
<ul>
<li>在SpringConfig中开启注解式事务驱动@EnableTransactionManagement</li>
<li>在JdbcConfig中添加事务管理器PlatformTransactionManager</li>
<li>在业务层接口上添加Spring事务管理</li>
</ul></li>
</ul>
<h3 id="spring整合springmvc">Spring整合SpringMVC</h3>
<ul>
<li>Web配置类（详见SSM07样例代码4）</li>
<li>SpringMVC配置类 SpringMVCConfig</li>
<li>基于Restful的Controller开发</li>
</ul>
<h1 id="样例代码以及测试如下">样例代码以及测试如下</h1>
<h2 id="程序框架">程序框架</h2>
<figure>
<img
src="https://wang-nine.cn/images/SSM09-01%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6.png"
alt="SSM09-01程序框架" />
<figcaption aria-hidden="true">SSM09-01程序框架</figcaption>
</figure>
<h2
id="mysql数据库的设计简单设计样例较为简单用于测试">MySQL数据库的设计（简单设计，样例较为简单，用于测试）</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create database ssm_db default charset utf8mb4;</span><br><span class="line"></span><br><span class="line">use ssm_db;</span><br><span class="line"></span><br><span class="line">create table tbl_book (</span><br><span class="line">    id int not null auto_increment comment &#x27;id&#x27;,</span><br><span class="line">    type varchar(20) not null comment &#x27;种类&#x27;,</span><br><span class="line">    name varchar(50) not null comment &#x27;书名&#x27;,</span><br><span class="line">    description varchar(255) not null comment &#x27;简介&#x27;,</span><br><span class="line">    primary key (id)</span><br><span class="line">) COMMENT=&#x27;商品表&#x27;;</span><br><span class="line"></span><br><span class="line">begin;</span><br><span class="line">   insert into tbl_book(type, name, description) values (&#x27;计算机理论&#x27;, &#x27;Spring实战第一版&#x27;, &#x27;Spring经典教程1&#x27;);</span><br><span class="line">   insert into tbl_book(type, name, description) values (&#x27;计算机理论&#x27;, &#x27;Spring实战第二版&#x27;, &#x27;Spring经典教程2&#x27;);</span><br><span class="line">   insert into tbl_book(type, name, description) values (&#x27;计算机理论&#x27;, &#x27;Spring实战第三版&#x27;, &#x27;Spring经典教程3&#x27;);</span><br><span class="line">   insert into tbl_book(type, name, description) values (&#x27;计算机理论&#x27;, &#x27;Spring实战第四版&#x27;, &#x27;Spring经典教程4&#x27;);</span><br><span class="line">   insert into tbl_book(type, name, description) values (&#x27;计算机理论&#x27;, &#x27;Spring实战第五版&#x27;, &#x27;Spring经典教程5&#x27;);</span><br><span class="line">   insert into tbl_book(type, name, description) values (&#x27;计算机理论&#x27;, &#x27;Spring实战第六版&#x27;, &#x27;Spring经典教程6&#x27;);</span><br><span class="line">   insert into tbl_book(type, name, description) values (&#x27;计算机理论&#x27;, &#x27;Spring实战第七版&#x27;, &#x27;Spring经典教程7&#x27;);</span><br><span class="line">   insert into tbl_book(type, name, description) values (&#x27;计算机理论&#x27;, &#x27;Spring实战第八版&#x27;, &#x27;Spring经典教程8&#x27;);</span><br><span class="line">   insert into tbl_book(type, name, description) values (&#x27;计算机理论&#x27;, &#x27;Spring实战第九版&#x27;, &#x27;Spring经典教程9&#x27;);</span><br><span class="line">   insert into tbl_book(type, name, description) values (&#x27;市场营销&#x27;, &#x27;市场营销第一版&#x27;, &#x27;市场营销教程1&#x27;);</span><br><span class="line">   insert into tbl_book(type, name, description) values (&#x27;市场营销&#x27;, &#x27;市场营销第二版&#x27;, &#x27;市场营销教程2&#x27;);</span><br><span class="line">   insert into tbl_book(type, name, description) values (&#x27;市场营销&#x27;, &#x27;市场营销第三版&#x27;, &#x27;市场营销教程3&#x27;);</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>
<p><strong>详细的代码放到了github，网址如下，需要自取：</strong></p>
<p><a
href="https://github.com/Wang-nine/smallLibraryManagementSystem">小型的SSM图书管理系统</a></p>
<p><strong>简单的使用postman对其中的增删改查功能进行了测试</strong></p>
<figure>
<img
src="https://wang-nine.cn/images/SSM09-02postman%E6%B5%8B%E8%AF%95.png"
alt="SSM09-02postman测试" />
<figcaption aria-hidden="true">SSM09-02postman测试</figcaption>
</figure>
<h1
id="具体代码如下较为冗长用于本人复习和调试">具体代码如下（较为冗长，用于本人复习和调试）</h1>
<h2 id="config模块">Config模块</h2>
<h3 id="jdbcconfig">JdbcConfig</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wang.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.DataSourceTransactionManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.PlatformTransactionManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        dataSource.setDriverClassName(driver);</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">// 2.事务管理器</span></span><br><span class="line">    <span class="keyword">public</span> PlatformTransactionManager <span class="title function_">transactionManager</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">DataSourceTransactionManager</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>();</span><br><span class="line">        ds.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="mybatisconfig">MybatisConfig</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wang.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.SqlSessionFactoryBean;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.mapper.MapperScannerConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactoryBean <span class="title function_">sqlSessionFactoryBean</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="type">SqlSessionFactoryBean</span> <span class="variable">factoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">        factoryBean.setDataSource(dataSource);</span><br><span class="line">        factoryBean.setTypeAliasesPackage(<span class="string">&quot;com.wang.domain&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> factoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MapperScannerConfigurer <span class="title function_">mapperScannerConfigurer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MapperScannerConfigurer</span> <span class="variable">msc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MapperScannerConfigurer</span>();</span><br><span class="line">        msc.setBasePackage(<span class="string">&quot;com.wang.dao&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> msc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="servletconfig">ServletConfig</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wang.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletConfig</span> <span class="keyword">extends</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;SpringConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;SpringMvcConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="springconfig">SpringConfig</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wang.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Import;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.PropertySource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.EnableTransactionManagement;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.wang.service&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="meta">@Import(&#123;JdbcConfig.class, MybatisConfig.class&#125;)</span></span><br><span class="line"><span class="comment">// 1.开启注解式事务驱动</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="springmvcconfig">SpringMVCConfig</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wang.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.EnableWebMvc;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.wang.controller&quot;)</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="controller表现层">Controller（表现层）</h2>
<h3 id="bookcontroller">BookController</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wang.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.wang.domain.Book;</span><br><span class="line"><span class="keyword">import</span> com.wang.service.BookService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/books&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookController</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Autowired</span></span><br><span class="line">        <span class="keyword">private</span> BookService bookService;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@PostMapping</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> Book book)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> bookService.save(book);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@PutMapping</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">update</span><span class="params">(<span class="meta">@RequestBody</span> Book book)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> bookService.update(book);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">delete</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> bookService.delete(id);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> Book <span class="title function_">getById</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> bookService.getById(id);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@GetMapping</span></span><br><span class="line">        <span class="keyword">public</span> List&lt;Book&gt; <span class="title function_">getAll</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> bookService.getAll(      );</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="dao持久层持久层">dao（持久层/持久层）</h2>
<h3 id="bookdao">BookDao</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wang.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.wang.domain.Book;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Delete;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Insert;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Select;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Update;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="meta">@Insert(&quot;insert into ssm_db.tbl_book(type, name, description) values (#&#123;type&#125;, #&#123;name&#125;, #&#123;description&#125;)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Book book)</span>;</span><br><span class="line">    <span class="meta">@Update(&quot;update ssm_db.tbl_book set type=#&#123;type&#125;, name=#&#123;name&#125;, description=#&#123;description&#125; where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Book book)</span>;</span><br><span class="line">    <span class="meta">@Delete(&quot;delete from ssm_db.tbl_book where id=#&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span>;</span><br><span class="line">    <span class="meta">@Select(&quot;select * from ssm_db.tbl_book where id=#&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Book <span class="title function_">getById</span><span class="params">(Integer id)</span>;</span><br><span class="line">    <span class="meta">@Select(&quot;select * from ssm_db.tbl_book&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Book&gt; <span class="title function_">getAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="service业务层">Service（业务层）</h2>
<h3 id="bookservice">BookService</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wang.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.wang.domain.Book;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Wang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> book</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">save</span><span class="params">(Book book)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> book</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">update</span><span class="params">(Book book)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据id删除</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">delete</span><span class="params">(Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据id查找</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Book <span class="title function_">getById</span><span class="params">(Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找全部</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Book&gt; <span class="title function_">getAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="bookserviceimpl">BookServiceImpl</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wang.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.wang.dao.BookDao;</span><br><span class="line"><span class="keyword">import</span> com.wang.domain.Book;</span><br><span class="line"><span class="keyword">import</span> com.wang.service.BookService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">save</span><span class="params">(Book book)</span> &#123;</span><br><span class="line">        bookDao.save(book);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">update</span><span class="params">(Book book)</span> &#123;</span><br><span class="line">        bookDao.update(book);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">delete</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        bookDao.delete(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Book <span class="title function_">getById</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bookDao.getById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Book&gt; <span class="title function_">getAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bookDao.getAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="domain实体类">Domain（实体类）</h2>
<h3 id="book">Book</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wang.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Book</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Book</span><span class="params">(Integer id, String type, String name, String description)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.description = description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> type</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setType</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> description</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> description</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDescription</span><span class="params">(String description)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.description = description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Book&#123;id = &quot;</span> + id + <span class="string">&quot;, type = &quot;</span> + type + <span class="string">&quot;, name = &quot;</span> + name + <span class="string">&quot;, description = &quot;</span> + description + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="测试类">测试类</h2>
<h3 id="bookservicetest">BookServiceTest</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> wang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.wang.config.SpringConfig;</span><br><span class="line"><span class="keyword">import</span> com.wang.domain.Book;</span><br><span class="line"><span class="keyword">import</span> com.wang.service.BookService;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class )</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = SpringConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookService bookService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetById</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> bookService.getById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetAll</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Book&gt; books = bookService.getAll();</span><br><span class="line">        System.out.println(books);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="pom.xml">pom.xml</h2>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>SSMtest<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>SSMtest Maven Webapp<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">port</span>&gt;</span>80<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">path</span>&gt;</span>/<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM06-Spring中的事务</title>
    <url>/posts/10306.html</url>
    <content><![CDATA[<p>详细的描述了Spring中的事务概念。 <span id="more"></span></p>
<h1 id="事务的简介">事务的简介</h1>
<p>事务作用：在数据层保障一系列的数据库操作同成功同失败
Spring事务作用：在数据层或业务层保障一系列的数据库操作同成功同失败</p>
<p>如何开启事务管理？</p>
<p>步骤如下：</p>
<ol type="1">
<li>在业务层接口上添加Spring事务管理</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">xxxxx</span> &#123;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> xxx &#123;</span><br><span class="line">        代码体</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意事项</strong>：
Spring注解式事务通常添加在业务层接口中而不会添加到业务层实现类中，降低耦合
注解式事务可以添加到业务方法上表示当前方法开启事务，也可以添加到接口上表示当前接口所有方法开启事务</p>
<ol start="2" type="1">
<li>设置事务管理器</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> PlatformTransactionManager <span class="title function_">transactionManager</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">	<span class="type">DataSourceTransactionManager</span> <span class="variable">ptm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>();</span><br><span class="line">    ptm.setDataSource(dataSource);</span><br><span class="line">	<span class="keyword">return</span> ptm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li><p>在主配置类中开启事务型驱动</p>
<p>添加如下注解：</p></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableTransactionmanagement</span></span><br></pre></td></tr></table></figure>
<h1 id="spring事务角色">Spring事务角色</h1>
<p>事务角色</p>
<h2 id="事务管理员">事务管理员</h2>
<p>发起事务方，在Spring中通常指代业务层开启事务的方法</p>
<h2 id="事务协调员">事务协调员</h2>
<p>加入事务方，在Spring中通常指代数据层方法，也可以是业务层方法</p>
<h1 id="事务属性">事务属性</h1>
<table>
<colgroup>
<col style="width: 24%" />
<col style="width: 28%" />
<col style="width: 46%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">属性</th>
<th style="text-align: center;">作用</th>
<th style="text-align: center;">实例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">readOnly</td>
<td style="text-align: center;">设置是否为只读事务</td>
<td style="text-align: center;">readOnly = true 只读事务</td>
</tr>
<tr class="even">
<td style="text-align: center;">timeout</td>
<td style="text-align: center;">设置事务的超过时间</td>
<td style="text-align: center;">timeout = -1 永不超时</td>
</tr>
<tr class="odd">
<td style="text-align: center;">rollbackFor</td>
<td style="text-align: center;">设置事务回滚异常(class)</td>
<td style="text-align: center;">rollbackFor =
(NullPointException.class)</td>
</tr>
<tr class="even">
<td style="text-align: center;">rollbackForClassName</td>
<td style="text-align: center;">设置事务回滚异常(String)</td>
<td style="text-align: center;">同上格式为字符串</td>
</tr>
<tr class="odd">
<td style="text-align: center;">noRollbackFor</td>
<td style="text-align: center;">设置事务不回滚异常(class)</td>
<td style="text-align: center;">noRollbackFor =
(NullPointException.class)</td>
</tr>
<tr class="even">
<td style="text-align: center;">noRollbackForClassName</td>
<td style="text-align: center;">设置事务不回滚异常(String)</td>
<td style="text-align: center;">同上格式为字符串</td>
</tr>
<tr class="odd">
<td style="text-align: center;">propagation</td>
<td style="text-align: center;">设置事务传播行为</td>
<td style="text-align: center;">…</td>
</tr>
</tbody>
</table>
<p><strong>事务传播行为</strong>：事务协调员对事务管理员所携带事务的处理态度</p>
<figure>
<img
src="https://wang-nine.cn/images/SSM05-01%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA.png"
alt="SSM05-01事务传播行为" />
<figcaption aria-hidden="true">SSM05-01事务传播行为</figcaption>
</figure>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM09-SSM整合深入</title>
    <url>/posts/10310.html</url>
    <content><![CDATA[<p>详细的描述了Spring中的SSM整合深入 <span id="more"></span></p>
<h1 id="ssm整合深入">SSM整合深入</h1>
<h2 id="表现层与前端数据协议">表现层与前端数据协议</h2>
<ul>
<li><p>前端接收数据格式—创建结果模型类，封装数据到data属性中（操作的结果）</p></li>
<li><p>前端接收数据格式—封装操作结果到code属性中（操作的结果：true还是false）</p></li>
<li><p>前端接收数据格式—封装特殊消息到message(msg)属性中（给用户看的）</p></li>
</ul>
<p>综上，设计一个统一数据返回结果类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> Object data;</span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Result类中的字段并不是固定的，可以根据需要自行增减提供若干个构造方法，方便操作</p>
</blockquote>
<p>针对Code也可以设计一个返回结果编码类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wang.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">SAVE_OK</span> <span class="operator">=</span> <span class="number">20011</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">DELETE_OK</span> <span class="operator">=</span> <span class="number">20021</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">UPDATE_OK</span> <span class="operator">=</span> <span class="number">20031</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">GET_OK</span> <span class="operator">=</span> <span class="number">20041</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">SAVE_ERR</span> <span class="operator">=</span> <span class="number">20010</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">DELETE_ERR</span> <span class="operator">=</span> <span class="number">20020</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">UPDATE_ERR</span> <span class="operator">=</span> <span class="number">20030</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">GET_ERR</span> <span class="operator">=</span> <span class="number">20040</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="ssm异常处理器">SSM异常处理器</h2>
<ul>
<li>出现异常现象的常见位置与常见诱因如下:
<ul>
<li>框架内部抛出的异常:因使用不合规导致</li>
<li>数据层抛出的异常:因外部服务器故障导致（例如:服务器访问超时）</li>
<li>业务层抛出的异常:因业务逻辑书写错误导致（例如:遍历业务书写操作，导致索引异常等）</li>
<li>表现层抛出的异常:因数据收集、校验等规则导致（例如:不匹配的数据类型间导致异常）</li>
<li>工具类抛出的异常:因工具类书写不严谨不够健壮导致（例如:必要释放的连接长期未释放等）</li>
</ul></li>
</ul>
<p>问题如下</p>
<p>1.各个层级均出现异常，异常处理代码书写在哪一层？</p>
<p>==所有的异常均抛出到表现层进行处理== 向上抛到表现层</p>
<p>2.表现层处理异常，每个方法中单独书写，代码书写量巨大且意义不强，如何解决?</p>
<p>AOP思想</p>
<p>实现代码与杂项4-项目中的全局异常处理器相同：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 全局异常处理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span>      <span class="comment">//捕获所有的异常</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">ex</span><span class="params">(Exception ex)</span> &#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> Result.error(<span class="string">&quot;对不起，操作失败，请联系管理员&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/posts/0.html</url>
    <content><![CDATA[<h1 id="基础案例">基础案例</h1>
<p>==极其精简化了dao层的书写==</p>
<p>==先引入mp起步依赖==</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>==导入实体类和表==</p>
<p>==定义数据接口继承BaseMapper<泛型>即可==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="curd和分页">CURD和分页</h1>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 41%" />
<col style="width: 47%" />
</colgroup>
<thead>
<tr class="header">
<th>功能</th>
<th>自定义接口</th>
<th>MP接口</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>新增</td>
<td>boolean save(T t)</td>
<td>int insert(T t)</td>
</tr>
<tr class="even">
<td>删除</td>
<td>boolean delete(int id)</td>
<td>int deleteById(Serializable id)</td>
</tr>
<tr class="odd">
<td>修改</td>
<td>boolean update(T t)</td>
<td>int updateById(T t)</td>
</tr>
<tr class="even">
<td>根据id查询</td>
<td>T getById(int id)</td>
<td>T selectById (Serializable id)</td>
</tr>
<tr class="odd">
<td>查询全部</td>
<td>List<T> getAll()</td>
<td>List<T> selectList()</td>
</tr>
<tr class="even">
<td>分页查询</td>
<td>PageInfo<T> getAll(int page, int size)</td>
<td>IPage<T> selectPage(IPage<T> page)</td>
</tr>
<tr class="odd">
<td>按条件查询</td>
<td>List<T> getAll(Condition condition)</td>
<td>IPage<T> selectPage(wrapper<T> querywrapper)</td>
</tr>
</tbody>
</table>
<p>==自动动态SQL==</p>
<p>样例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MybatisplusApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSave</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;Wang&quot;</span>);</span><br><span class="line">        user.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        user.setAge(<span class="number">9</span>);</span><br><span class="line">        user.setTel(<span class="string">&quot;116483477&quot;</span>);</span><br><span class="line">        userDao.insert(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testDelete</span><span class="params">()</span> &#123;</span><br><span class="line">        userDao.deleteById(<span class="number">1L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testUpdate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setId(<span class="number">1L</span>);</span><br><span class="line">        user.setName(<span class="string">&quot;Wang-nine&quot;</span>);</span><br><span class="line">        userDao.updateById(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testGetById</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userDao.selectById(<span class="number">1L</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找全部</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testGetAll</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;User&gt; users = userDao.selectList(<span class="literal">null</span>);</span><br><span class="line">        System.out.println(users);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分页查询</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testGetByPage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">IPage</span> <span class="variable">page</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Page</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        userDao.selectPage(page, <span class="literal">null</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;当前页码值：&quot;</span> + page.getCurrent());</span><br><span class="line">        System.out.println(<span class="string">&quot;每页页码值：&quot;</span> + page.getSize());</span><br><span class="line">        System.out.println(<span class="string">&quot;一共多少页：&quot;</span> + page.getPages());</span><br><span class="line">        System.out.println(<span class="string">&quot;一共多少条：&quot;</span> + page.getTotal());</span><br><span class="line">        System.out.println(<span class="string">&quot;数据：&quot;</span> + page.getRecords());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>==对于分页查询，开启拦截器和输出日志==</p>
<p>拦截器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MpConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1.定义mp拦截器</span></span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">mybatisPlusInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        <span class="comment">//2.添加具体的拦截器</span></span><br><span class="line">        mybatisPlusInterceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>());</span><br><span class="line">        <span class="keyword">return</span> mybatisPlusInterceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置日志输出</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure>
<p>==条件查询==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按条件查询</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testGetByCondition</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//第一种方法</span></span><br><span class="line">    <span class="type">QueryWrapper</span> <span class="variable">qw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>();</span><br><span class="line">    <span class="comment">//查询小于18岁的</span></span><br><span class="line">    qw.lt(<span class="string">&quot;age&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    List&lt;User&gt; users = userDao.selectList(qw);</span><br><span class="line">    System.out.println(users);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二种方法，lambda表达式</span></span><br><span class="line">    QueryWrapper&lt;User&gt; qw1 = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>();</span><br><span class="line">    qw1.lambda().lt(User::getAge, <span class="number">18</span>);</span><br><span class="line">    List&lt;User&gt; users1 = userDao.selectList(qw);</span><br><span class="line">    System.out.println(users1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三种方法，lambda表达式</span></span><br><span class="line">    LambdaQueryWrapper&lt;User&gt; lqw = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;User&gt;();</span><br><span class="line">    lqw.lt(User::getAge, <span class="number">18</span>);</span><br><span class="line">    List&lt;User&gt; users2 = userDao.selectList(lqw);</span><br><span class="line">    System.out.println(users2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//链式编程</span></span><br><span class="line">    LambdaQueryWrapper&lt;User&gt; lqw1 = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    lqw1.lt(User::getAge, <span class="number">30</span>).or().gt(User::getAge, <span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断为空</span></span><br><span class="line">    <span class="comment">//其弊端，判断年龄上下限，需要新来一个类继承一下user同时自己扩展一个age2</span></span><br><span class="line">    <span class="comment">//模拟页面传递的数据，万一age2为空之类的情况</span></span><br><span class="line">    <span class="type">UserQuery</span> <span class="variable">uq</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserQuery</span>();</span><br><span class="line">    uq.setAge(<span class="number">10</span>);</span><br><span class="line">    uq.setAge2(<span class="number">30</span>);</span><br><span class="line">    lqw.lt(<span class="literal">null</span> != uq.getAge2(), User::getAge, uq.getAge2());</span><br><span class="line">    lqw.gt(<span class="literal">null</span> != uq.getAge(), User::getAge, uq.getAge());</span><br><span class="line">   	...查询语句...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>==查询投影，非常麻烦，不如自己写==</p>
<figure>
<img
src="https://wang-nine.cn/images/SSM12-01%E6%9F%A5%E8%AF%A2%E6%8A%95%E5%BD%B1.png"
alt="SSM12-01查询投影" />
<figcaption aria-hidden="true">SSM12-01查询投影</figcaption>
</figure>
<p>==对于其余的复杂查询，例如&gt; = between like null in group
order等，强烈建议自己写mysql语句，不要再去学习复杂的API了==</p>
<p>==实在想学，可以查看它的官方文档==</p>
<p>==字段名称映射(均为熟悉注解)==</p>
<ul>
<li>名称不一致</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableField(value = &quot;数据库字段名&quot;)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>存在数据库未定义属性</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableField(exist = false)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>设定不可查询的字段权限，设定不参与查询</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableField(select = false)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>表名与实体类名不一致</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableName(&quot;表名&quot;)</span></span><br></pre></td></tr></table></figure>
<p>全局配置表名前缀</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">	<span class="attr">global-config:</span></span><br><span class="line">		<span class="attr">db-config:</span></span><br><span class="line">			<span class="attr">table-prefix:</span> <span class="string">tbl_</span></span><br></pre></td></tr></table></figure>
<p>==id生成策略(均为属性注解)==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableId(value = 数据库主键名称, type = 策略)</span></span><br></pre></td></tr></table></figure>
<p>策略：IdType.AUTO 自增 NONE无策略 INPUT自己输入 ASSIGN_ID雪花算法
ASSIGN_UUIDuuid</p>
<figure>
<img src="https://wang-nine.cn/images/SSM12-02ID.png"
alt="SSM12-02ID" />
<figcaption aria-hidden="true">SSM12-02ID</figcaption>
</figure>
<p>也可在yaml中全局配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">	<span class="attr">global-config:</span></span><br><span class="line">		<span class="attr">db-config:</span></span><br><span class="line">			<span class="attr">id-type:</span> <span class="string">assign_id</span></span><br></pre></td></tr></table></figure>
<p>==多数据操作==</p>
<p>样例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Long&gt; ids = Arrays.asList(<span class="keyword">new</span> <span class="title class_">Long</span>[]&#123;<span class="number">2</span>, <span class="number">3</span>&#125;);</span><br><span class="line">userDao.deleteBatchIds(ids);	<span class="comment">//删除</span></span><br><span class="line">userDao.selectBatchIds(ids);	<span class="comment">//查询</span></span><br></pre></td></tr></table></figure>
<p>==逻辑删除==</p>
<p>通用配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">	<span class="attr">global-config:</span></span><br><span class="line">		<span class="attr">db-config:</span></span><br><span class="line">			<span class="attr">logic-delete-field:</span> <span class="string">deleted</span></span><br><span class="line">			<span class="attr">logic-not-delete-value:</span> <span class="number">0</span></span><br><span class="line">			<span class="attr">logic-delete-value:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>==乐观锁：比如秒杀（可以解决2000个一下的并发问题）==</p>
<p>新增一个字段并加上下述注解</p>
<p>属性注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Version</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MpConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1.定义mp拦截器</span></span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">mybatisPlusInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        <span class="comment">//2.添加具体的拦截器</span></span><br><span class="line">        mybatisPlusInterceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>());</span><br><span class="line">        <span class="comment">//3.添加乐观锁拦截器</span></span><br><span class="line">        mybatisPlusInterceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">OptimisticLockerInnerInterceptor</span>());</span><br><span class="line">        <span class="keyword">return</span> mybatisPlusInterceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>SSM总览</title>
    <url>/posts/10300.html</url>
    <content><![CDATA[<h1 id="ssm01-spring中的bean">SSM01-Spring中的Bean</h1>
<p><a
href="https://wang-nine.cn/posts/10301.html">SSM01-Spring中的Bean</a></p>
<h1
id="ssm02-spring中bean的实例化与依赖注入">SSM02-Spring中Bean的实例化与依赖注入</h1>
<p><a
href="https://wang-nine.cn/posts/10302.html">SSM02-Spring中Bean的实例化与依赖注入</a></p>
<h1 id="ssm03-spring的纯注解开发模式">SSM03-Spring的纯注解开发模式</h1>
<p><a
href="https://wang-nine.cn/posts/10303.html">SSM03-Spring的纯注解开发模式</a></p>
<h1 id="ssm04-spring整合mybatis">SSM04-Spring整合MyBatis</h1>
<p><a
href="https://wang-nine.cn/posts/10304.html">SSM04-Spring整合MyBatis</a></p>
<h1 id="ssm05-spring中的aop概念">SSM05-Spring中的AOP概念</h1>
<p><a
href="https://wang-nine.cn/posts/10305.html">SSM05-Spring中的AOP概念</a></p>
<h1 id="ssm06-spring中的事务">SSM06-Spring中的事务</h1>
<p><a
href="https://wang-nine.cn/posts/10306.html">SSM06-Spring中的事务</a></p>
<h1 id="ssm07-springmvc的请求与响应">SSM07-SpringMVC的请求与响应</h1>
<p><a
href="https://wang-nine.cn/posts/10307.html">SSM07-SpringMVC的请求与响应</a></p>
<h1 id="ssm08-rest风格">SSM08-REST风格</h1>
<p><a
href="https://wang-nine.cn/posts/10308.html">SSM08-REST风格</a></p>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud01-微服务简介</title>
    <url>/posts/10601.html</url>
    <content><![CDATA[<p>简单的介绍了SpringCloud中的微服务技术栈。 <span id="more"></span></p>
<h1 id="微服务技术栈">微服务技术栈</h1>
<figure>
<img
src="https://wang-nine.cn/images/SpringCloud01-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E6%A0%88.png"
alt="SpringCloud01-微服务技术栈" />
<figcaption aria-hidden="true">SpringCloud01-微服务技术栈</figcaption>
</figure>
<ul>
<li><p>微服务拆分，形成微服务集群</p></li>
<li><p>注册中心：拉取活注册服务信息（记录微服务的ip端口等，微服务调用关系访问注册中心获得对方信息）</p></li>
<li><p>配置中心：拉取配置信息（统一的管理所有微服务的配置，实现配置的热更新）</p></li>
<li><p>服务网关组件：身份校验，将请求路由到服务，可以进行负载均衡</p></li>
<li><p>分布式缓存：实现高并发</p></li>
<li><p>分布式搜索：进行复杂的搜索</p></li>
<li><p>消息队列：异步通信，提高服务并发</p></li>
<li><p>分布式日志服务：统计整个集群的日志，统一存储，统计进行分析</p></li>
<li><p>系统监控链路追踪：实时监控整个集群中每个节点的运行状态，一旦出现问题可以快速定位异常所在</p></li>
<li><p>自动化部署（Jenkins）</p></li>
<li><p>打包（Docker） kuebernetes RANCHER</p></li>
</ul>
<h1 id="微服务简介">微服务简介</h1>
<h2 id="单体架构">单体架构</h2>
<p>将业务的所有功能集中在一个项目中开发，打成一个包部署。</p>
<p>优点：</p>
<ul>
<li><p>架构简单</p></li>
<li><p>部署成本低</p></li>
</ul>
<p>缺点：</p>
<ul>
<li>耦合度高</li>
</ul>
<h2 id="分布式架构">分布式架构</h2>
<p>根据业务功能对系统进行拆分，每个业务模块作为独立项目开发，称为一个服务。</p>
<p>优点：</p>
<ul>
<li>降低服务耦合</li>
<li>有利于服务升级拓展</li>
</ul>
<p>缺点：</p>
<ul>
<li>服务治理
<ul>
<li>服务拆分粒度？</li>
<li>服务集群地址如何维护？</li>
<li>服务之间如何实现远程调用？</li>
<li>服务健康状态如何感知？</li>
</ul></li>
</ul>
<h2 id="微服务架构特征">微服务架构特征</h2>
<p>微服务是一种经过良好架构设计的分布式架构方案，微服务架构特征：</p>
<ul>
<li>单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责，避免重复业务开发</li>
<li>面向服务：微服务对外暴露业务接口</li>
<li>自治：团队独立、技术独立、数据独立、部署独立</li>
<li>隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题</li>
</ul>
<h2 id="微服务结构">微服务结构</h2>
<p>技术框架</p>
<ul>
<li><p>SpringCloud</p></li>
<li><p>Dubbo</p></li>
<li><p>SpringCloudAlibaba</p></li>
</ul>
<p>差异对比</p>
<table>
<colgroup>
<col style="width: 17%" />
<col style="width: 23%" />
<col style="width: 29%" />
<col style="width: 29%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">Dubbo</th>
<th style="text-align: center;">SpringCloud</th>
<th style="text-align: center;">SpringCloudAlibaba</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">注册中心</td>
<td style="text-align: center;">zookeeper、Redis</td>
<td style="text-align: center;">Eureka、Consul</td>
<td style="text-align: center;">Nacos、Eureka</td>
</tr>
<tr class="even">
<td style="text-align: center;">服务远程调用</td>
<td style="text-align: center;">Dubbo协议</td>
<td style="text-align: center;">Feign(http协议)</td>
<td style="text-align: center;">Dubbo、Feign</td>
</tr>
<tr class="odd">
<td style="text-align: center;">配置中心</td>
<td style="text-align: center;">无</td>
<td style="text-align: center;">SpringCloudConfig</td>
<td style="text-align: center;">SpringCloudConfig、Nacos</td>
</tr>
<tr class="even">
<td style="text-align: center;">服务网关</td>
<td style="text-align: center;">无</td>
<td style="text-align: center;">SpringCloudGateway、Zuul</td>
<td style="text-align: center;">SpringCloudGateway、Zuul</td>
</tr>
<tr class="odd">
<td style="text-align: center;">服务监控和保护</td>
<td style="text-align: center;">Dubbo-admin，功能弱</td>
<td style="text-align: center;">Hystrix</td>
<td style="text-align: center;">Sentinel</td>
</tr>
</tbody>
</table>
<h2 id="springcloud">SpringCloud</h2>
<p>SpringCloud是目前国内使用最广泛的微服务框架。</p>
<p>SpringCloud基于SpringBoot</p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud03-Eureka</title>
    <url>/posts/10603.html</url>
    <content><![CDATA[<p>简单的介绍了SpringCloud中的注册中心Eureka。 <span id="more"></span></p>
<h1 id="提供者与消费者">提供者与消费者</h1>
<ul>
<li><p>服务提供者:一次业务中，被其它微服务调用的服务。（提供接口给其它微服务）</p></li>
<li><p>服务消费者:一次业务中，调用其它微服务的服务。（调用其它微服务提供的接口）</p></li>
<li><p>提供者与消费者角色其实是相对的</p></li>
<li><p>一个服务可以同时是服务提供者和服务消费者</p></li>
</ul>
<h1 id="eureka注册中心">Eureka注册中心</h1>
<p>服务调用出现的问题</p>
<ul>
<li><p>服务消费者该如何获取服务提供者的地址信息?</p>
<blockquote>
<p>服务提供者启动时向eureka注册自己的信息</p>
<p>eureka保存这些信息</p>
<p>消费者根据服务名称向eureka拉取提供者信息</p>
</blockquote></li>
<li><p>如果有多个服务提供者，消费者该如何选择?</p>
<blockquote>
<p>服务消费者利用负载均衡算法，从服务列表中挑选一个</p>
</blockquote></li>
<li><p>消费者如何感知服务提供者健康状态?</p>
<blockquote>
<p>服务提供者会每隔30秒向EurekaServer发送心跳请求，报告健康状态eureka会更新记录服务列表信息，心跳不正常会被剔除消费者就可以拉取到最新的信息</p>
</blockquote></li>
</ul>
<p>解决URL的硬编码问题</p>
<h2 id="eureka的作用">Eureka的作用</h2>
<figure>
<img src="https://wang-nine.cn/images/SpringCloud03-Eureka.png"
alt="SpringCloud03-Eureka.png" />
<figcaption aria-hidden="true">SpringCloud03-Eureka.png</figcaption>
</figure>
<p>在Eureka架构中，微服务角色有两类:</p>
<ul>
<li>EurekaServer:服务端，注册中心
<ul>
<li>记录服务信息</li>
<li>心跳监控</li>
</ul></li>
<li>EurekaClient:客户端
<ul>
<li>Provider:服务提供者，例如案例中的user-service
<ul>
<li>注册自己的信息到EurekaServer</li>
<li>每隔30秒向EurekaServer发送心跳</li>
</ul></li>
<li>consumer:服务消费者，例如案例中的order-service
<ul>
<li>根据服务名称从EurekaServer拉取服务列表</li>
<li>基于服务列表做负载均衡，选中一个微服务后发起远程调用</li>
</ul></li>
</ul></li>
</ul>
<h2 id="eureka远程调用">Eureka远程调用</h2>
<h3 id="搭建eurekaserver">搭建EurekaServer</h3>
<p>搭建EurekaServer服务步骤如下:</p>
<ul>
<li><p>1.创建项目，引入spring-cloud-starter-netflix-eureka-server的依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>2.编写启动类，添加@EnableEarekaServer注解</p></li>
<li><p>3.添加application.yml文件，编写下面的配置:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">	<span class="attr">port:</span> <span class="number">10086</span> <span class="comment"># 服务端口</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">application:</span></span><br><span class="line">		<span class="attr">name:</span> <span class="string">eurekaserver</span> <span class="comment"># Eureka服务名称</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">	<span class="attr">client:</span></span><br><span class="line">		<span class="attr">service-url:</span> <span class="comment"># Eureka的地址信息</span></span><br><span class="line">			<span class="attr">defaultzone:</span> <span class="string">http://127.0.0.1:10086/eureka/</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="注册微服务">注册微服务</h3>
<p>将user-service服务注册到EurekaServer步骤如下:</p>
<ul>
<li><p>1.在user-service项目引入spring-cloud-starter-netflix-eureka-client的依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>2.在application.yml文件，编写下面的配置:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">application:</span></span><br><span class="line">		<span class="attr">name:</span> <span class="string">userservice</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">	<span class="attr">client:</span></span><br><span class="line">		<span class="attr">service-url:</span></span><br><span class="line">			<span class="attr">defaultZone:</span> <span class="string">http:/</span> <span class="string">/127.0.0.1:10086/eureka/</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="在order-service完成服务拉取">在order-service完成服务拉取</h3>
<ul>
<li>1.修改OrderService的代码，修改访问的url路径，用服务名代替ip、端口：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://userservice/user/&quot;</span> + order.getUserId();</span><br></pre></td></tr></table></figure>
<ul>
<li>2.在order-service项目的启动类OrderApplication的RestTemplate添加<strong>负载均衡</strong>注解：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结">总结</h1>
<ul>
<li>1.搭建EurekaServer
<ul>
<li>引入eureka-server依赖</li>
<li>添加@EnableEurekaServer注解</li>
<li>在application.yml中配置eureka地址</li>
</ul></li>
<li>2.服务注册
<ul>
<li>引入eureka-client依赖</li>
<li>在application.yml中配置eureka地址</li>
</ul></li>
<li>3.服务发现
<ul>
<li>引入eureka-client依赖</li>
<li>在application.yml中配置eureka地址</li>
<li>给RestTemplate添加@LoadBalanced注解</li>
<li>用服务提供者的服务名称远程调用</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud02-服务拆分</title>
    <url>/posts/10602.html</url>
    <content><![CDATA[<p>简单的介绍了SpringCloud中的服务拆分。 <span id="more"></span></p>
<h1 id="服务拆分">服务拆分</h1>
<p>注意事项：</p>
<ul>
<li>1.不同微服务，不要重复开发相同业务</li>
<li>2.微服务数据独立，不要访问其它微服务的数据库</li>
<li>3.微服务可以将自己的业务暴露为接口，供其它微服务调用</li>
</ul>
<h1 id="远程调用">远程调用</h1>
<p>如何进行远程调用呢，让其中一个微服务发起http请求，返回需要的数据即可</p>
<p>步骤：</p>
<ul>
<li>1.注册RestTemplate</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个RestTemplate并且注入Spring容器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>2.利用RestTemplate发起http请求</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">restTemplate.getForObject(url, User.class);	<span class="comment">//自动反序列化为json数据</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud04-Ribbon负载均衡</title>
    <url>/posts/10604.html</url>
    <content><![CDATA[<p>简单的介绍了SpringCloud中的Ribbon负载均衡。 <span id="more"></span></p>
<h1 id="负载均衡原理">负载均衡原理</h1>
<h2 id="负载均衡流程">负载均衡流程</h2>
<p>Ribbon拦截请求寻找Eureka返回服务列表，进行负载均衡</p>
<figure>
<img
src="https://wang-nine.cn/images/SpringCloud04-01%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%B5%81%E7%A8%8B.png"
alt="SpringCloud04-01负载均衡流程" />
<figcaption aria-hidden="true">SpringCloud04-01负载均衡流程</figcaption>
</figure>
<h2 id="负载均衡策略">负载均衡策略</h2>
<p>IRule</p>
<table>
<colgroup>
<col style="width: 29%" />
<col style="width: 70%" />
</colgroup>
<thead>
<tr class="header">
<th>内置负载均衡规则类</th>
<th>规则描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>RoundRobinRule</td>
<td>简单轮询服务列表来选择服务器。它是Ribbon默认的负载均衡规则。</td>
</tr>
<tr class="even">
<td>AvailabilityFilteringRule</td>
<td>对以下两种服务器进行忽略:
(1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加。(2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了AvailabilityFilteringRule规则的客户端也会将其忽略。并发连接数的上限，可以由客户端的<clientName>.<clientConfigNameSpace>.ActiveConnectionsLimit属性进行配置。</td>
</tr>
<tr class="odd">
<td>weightedResponseTimeRule</td>
<td>为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。</td>
</tr>
<tr class="even">
<td>ZoneAvoidanceRule</td>
<td>以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询。</td>
</tr>
<tr class="odd">
<td>BestAvailableRule</td>
<td>忽略哪些短路的服务器，并选择并发数较低的服务器。</td>
</tr>
<tr class="even">
<td>RandomRule</td>
<td>随机选择一个可用的服务器。</td>
</tr>
<tr class="odd">
<td>RetryRule</td>
<td>重试机制的选择逻辑。</td>
</tr>
</tbody>
</table>
<h2 id="调整负载均衡策略">调整负载均衡策略</h2>
<p>通过定义IRule实现可以修改负载均衡规则，有两种方式:</p>
<ul>
<li>1.代码方式:在order-service中的OrderApplication类中，定义一个新的IRule:==全局生效==</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> IRule <span class="title function_">randomRule</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RandomRule</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>2
配置文件方式:在order-service的application.yml文件中，添加新的配置也可以修改规则:==某个微服务范围生效==</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">userservice:</span></span><br><span class="line">	<span class="attr">ribbon:</span></span><br><span class="line">		<span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span> <span class="comment">#负载均衡规则</span></span><br></pre></td></tr></table></figure>
<h2 id="饥饿加载">饥饿加载</h2>
<p>Ribbon默认是采用懒加载，即第一次访问时才会去创建LoadBalanceClient，请求时间会很长。而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">	<span class="attr">eager-load:</span></span><br><span class="line">		<span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启饥饿加载</span></span><br><span class="line">		<span class="attr">clients:</span> <span class="string">userservice</span> <span class="comment"># 指定对userservice这个服务饥饿加载</span></span><br><span class="line">			<span class="bullet">-</span> <span class="string">userservice1</span></span><br><span class="line">			<span class="bullet">-</span> <span class="string">userservice2</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud02-服务拆分</title>
    <url>/posts/10602.html</url>
    <content><![CDATA[<p>简单的介绍了SpringCloud中的Nacos。 <span id="more"></span></p>
<h1 id="nacos注册中心">Nacos注册中心</h1>
<h2 id="启动">启动</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">startup.cmd -m standalone</span><br></pre></td></tr></table></figure>
<h2 id="注册与发现">注册与发现</h2>
<p>由于SpringCloud Commons定义了统一的接口规范</p>
<p>所以只需要改变引入的依赖和地址即可</p>
<h2 id="nacos服务分级存储模型">Nacos服务分级存储模型</h2>
<p>服务-&gt;集群-&gt;实例</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">cloud:</span></span><br><span class="line">		<span class="attr">nacos:</span></span><br><span class="line">			<span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># nacos服务端地址</span></span><br><span class="line">			<span class="attr">discovery:</span></span><br><span class="line">				<span class="attr">cluster-name:</span> <span class="string">HZ</span> <span class="comment">#配置集群名称，也就是机房位置，例如:HZ，杭州</span></span><br></pre></td></tr></table></figure>
<h3
id="那么如何设置orderservice也进行集群属性配置使得远程调用可以优先调用本地的集群">那么如何设置orderservice也进行集群属性配置使得远程调用可以优先调用本地的集群</h3>
<ul>
<li>1.修改order-service中的application.yml，设置集群</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">cloud:</span></span><br><span class="line">		<span class="attr">nacos:</span></span><br><span class="line">			<span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># nacos服务端地址</span></span><br><span class="line">			<span class="attr">discovery:</span></span><br><span class="line">				<span class="attr">cluster-name:</span> <span class="string">HZ</span> <span class="comment"># 配置集群名称，也就是机房位置，例如:HZ，杭州</span></span><br></pre></td></tr></table></figure>
<ul>
<li>2.在order-service中设置负载均衡的IRule为NacosRule，这个规则会优先寻找与自己同集群的服务</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">userservice:</span></span><br><span class="line">	<span class="attr">ribbon:</span></span><br><span class="line">		<span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.alibaba.cloud.nacos.ribbon.NacosRule</span> <span class="comment"># 负载均衡规则</span></span><br></pre></td></tr></table></figure>
<ul>
<li>3.注意将user-service的权重都设置为1</li>
</ul>
<p>==Nacos负载均衡的策略：先访问本地的集群，在本地的集群内随机负载均衡==</p>
<h3
id="那么如何进行根据权重负载均衡呢">那么如何进行根据权重负载均衡呢</h3>
<p>Nacos提供了权重配置来控制访问的频次</p>
<p>在Nacos页面进行权重配置即可</p>
<p>权重为0即为停止访问，可以用来停机进行版本升级，再小量的提升权重，放入小部分用户进行测试，若无问题则调整群众，进行一个平滑的升级</p>
<h2 id="nacos的环境隔离-namespace">Nacos的环境隔离-namespace</h2>
<figure>
<img
src="https://wang-nine.cn/images/SpringCloud05-01Nacos%E7%8E%AF%E5%A2%83%E9%9A%94%E7%A6%BB.png"
alt="SpringCloud05-01Nacos环境隔离" />
<figcaption
aria-hidden="true">SpringCloud05-01Nacos环境隔离</figcaption>
</figure>
<p>修改命名空间：修改order-service的application.yml，添加namespace:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">cloud:</span></span><br><span class="line">		<span class="attr">nacos:</span></span><br><span class="line">			<span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># nacos服务端地址</span></span><br><span class="line">			<span class="attr">discovery:</span></span><br><span class="line">				<span class="attr">cluster-name:</span> <span class="string">HZ</span> <span class="comment"># 配置集群名称，也就是机房位置，例如:HZ，杭州</span></span><br><span class="line">				<span class="attr">namespace:</span> <span class="string">492a7d5d-237b-46a1-a99a-fa8e98e4b0f9</span> <span class="comment">#命名空间，填ID</span></span><br></pre></td></tr></table></figure>
<p>Nacos环境隔离</p>
<ul>
<li>namespace用来做环境隔离</li>
<li>每个namespace都有唯一id</li>
<li>不同namespace下的服务不可见</li>
</ul>
<h1 id="nacos注册中心细节">Nacos注册中心细节</h1>
<figure>
<img
src="https://wang-nine.cn/images/SpringCloud05-02Nacos%E7%BB%86%E8%8A%82.png"
alt="SpringCloud05-02Nacos细节" />
<figcaption aria-hidden="true">SpringCloud05-02Nacos细节</figcaption>
</figure>
<p>非临时实例：yml中的discovery:ephemeral: false</p>
<p>1.Nacos与eureka的共同点</p>
<ul>
<li>都支持服务注册和服务拉取</li>
<li>都支持服务提供者心跳方式做健康检测</li>
</ul>
<p>2.Nacos与Eureka的区别</p>
<ul>
<li>Nacos支持服务端主动检测提供者状态:临时实例采用心跳模式，非临时实例采用主动检测模式</li>
<li>临时实例心跳不正常会被剔除，非临时实例则不会被剔除</li>
<li>Nacos支持服务列表变更的消息推送模式，服务列表更新更及时</li>
<li>Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式;Eureka采用AP方式</li>
</ul>
<h1 id="nacos配置管理">Nacos配置管理</h1>
<h2 id="统一配置管理">统一配置管理</h2>
<p>需求：</p>
<ul>
<li>配置更改热更新</li>
</ul>
<p>如何管理：Nacos表单填写配置名称</p>
<ul>
<li>Data ID: 配置文件的id:[服务名称]-[profile].[后缀名]</li>
<li>Group：分组：默认即可</li>
<li>格式：建议yaml</li>
</ul>
<p>有个问题：Nacos的地址存于application.yml
，如何先读取到naocs地址呢？</p>
<p>有个bootstrap.yml优先级高于本低的配置文件，写在其中即可</p>
<figure>
<img
src="https://wang-nine.cn/images/SpringCloud05-03Nacos%E9%85%8D%E7%BD%AE%E8%AF%BB%E5%8F%96.png"
alt="SpringCloud05-03Nacos配置读取" />
<figcaption
aria-hidden="true">SpringCloud05-03Nacos配置读取</figcaption>
</figure>
<p>==配置步骤如下==</p>
<ul>
<li>1.引入Nacos的配置管理客户端依赖:</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- nacos配置管理依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>2.在userservice中的resource目录添加一个bootstrap.yml文件，这个文件是引导文件，优先级高于application.yml:</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">application:</span></span><br><span class="line">		<span class="attr">name :</span> <span class="string">userservice</span> <span class="comment">#服务名称</span></span><br><span class="line">	<span class="attr">profiles:</span></span><br><span class="line">		<span class="attr">active:</span> <span class="string">dev</span> <span class="comment">#开发环境，这里是dev</span></span><br><span class="line">	<span class="attr">cloud:</span></span><br><span class="line">		<span class="attr">nacos:</span></span><br><span class="line">			<span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos地址</span></span><br><span class="line">			<span class="attr">config:</span></span><br><span class="line">				<span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment">#文件后缀名</span></span><br></pre></td></tr></table></figure>
<p>中间的三项配置即为Data ID</p>
<p>==将配置交给Nacos管理的步骤==</p>
<ul>
<li>1.在Nacos中添加配置文件</li>
<li>在微服务中引入nacos的config依赖</li>
<li>在微服务中添加bootstrap.yml，配置nacos地址、当前环境、服务名称、文件后缀名。这些决定了程序启动时去nacos读取哪个文件</li>
</ul>
<p>==如何进行热更新==</p>
<figure>
<img
src="https://wang-nine.cn/images/SpringCloud05-04Nacos%E7%83%AD%E6%9B%B4%E6%96%B001.png"
alt="SpringCloud05-04Nacos热更新01" />
<figcaption
aria-hidden="true">SpringCloud05-04Nacos热更新01</figcaption>
</figure>
<figure>
<img
src="https://wang-nine.cn/images/SpringCloud05-04Nacos%E7%83%AD%E6%9B%B4%E6%96%B002.png"
alt="SpringCloud05-04Nacos热更新02" />
<figcaption
aria-hidden="true">SpringCloud05-04Nacos热更新02</figcaption>
</figure>
<p>Nacos配置更改后，微服务可以实现热更新，方式:</p>
<p>通过@Value注解注入，结合@RefreshScope来刷新</p>
<p>通过@ConfigurationProperties注入</p>
<p>自动刷新注意事项:</p>
<ul>
<li>不是所有的配置都适合放到配置中心，维护起来比较麻烦</li>
<li>建议将一些关键参数，需要运行时调整的参数放到nacos配置中心，一般都是自定义配置</li>
</ul>
<p>==共享配置==</p>
<p>微服务会从nacos读取的配置文件:
[服务名]-[spring.profile.active].yaml，环境配置[服务名].yaml，默认配置，多环境共享
优先级: [服务名]-[环境].yaml &gt;[服务名].yaml &gt;本地配置</p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>博客搭建教程总览</title>
    <url>/posts/10000.html</url>
    <content><![CDATA[<h3 id="hexobutterfly主题博客搭建01">Hexo+Butterfly主题博客搭建01</h3>
<p><a
href="https://wang-nine.cn/posts/10001.html">Hexo+Butterfly主题博客搭建01</a></p>
<h3 id="hexobutterfly主题博客搭建02">Hexo+Butterfly主题博客搭建02</h3>
<p><a
href="https://wang-nine.cn/posts/10002.html">Hexo+Butterfly主题博客搭建02</a></p>
<h3 id="hexobutterfly主题博客搭建03">Hexo+Butterfly主题博客搭建03</h3>
<p><a
href="https://wang-nine.cn/posts/10003.html">Hexo+Butterfly主题博客搭建03</a></p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/posts/2.html</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>博客更新文档</title>
    <url>/posts/1.html</url>
    <content><![CDATA[<p>[toc]</p>
<h3 id="新增或修改的文件结构">新增或修改的文件结构</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root</span><br><span class="line">│</span><br><span class="line">├─_config.yml(修改)</span><br><span class="line">│</span><br><span class="line">├─_config.butterfly.yml(修改)</span><br><span class="line">│</span><br><span class="line">└─themes</span><br><span class="line">    └─butterfly</span><br><span class="line">        ├─layout</span><br><span class="line">        │   ├─includes</span><br><span class="line">        │	│	├─custom</span><br><span class="line">        │	│	│	└─switch.pug(明暗切换动画)</span><br><span class="line">        │	│	│</span><br><span class="line">        │	│	├─header</span><br><span class="line">        │	│	│	└─menu_item.pug(修改，添加子菜单栏居中)</span><br><span class="line">        │	│	│</span><br><span class="line">        │   │   ├─wedget</span><br><span class="line">        │   │   │   ├─card_calendar.pug(新增写作日历)</span><br><span class="line">        │	│	│	├─card_webinfo.pug(新增写作日历)</span><br><span class="line">        │	│	│	└─index.pug(修改，添加写作日历)</span><br><span class="line">		│	│	│</span><br><span class="line">        │	│	└─rightside.pug(黑暗模式一图流)</span><br><span class="line">        │	│	</span><br><span class="line">        │	│	</span><br><span class="line">        │   ├─head.pug(新增，引入昼夜切换)	</span><br><span class="line">        │	├─rightside.pug(修改，昼夜切换)</span><br><span class="line">        │   └─sliderbar.pug</span><br><span class="line">        └─source</span><br><span class="line">            ├─css</span><br><span class="line">            │   ├─_layout</span><br><span class="line">            │   │   ├─calendar.styl(新增日历样式)</span><br><span class="line">            │   │   ├─footer.styl(修改，删除底部蓝条)</span><br><span class="line">            │   │   └─switch.styl(新增，明暗切换样式)</span><br><span class="line">            │   ├─custom</span><br><span class="line">            │   │   ├─background.css(黑暗模式一图流配置)</span><br><span class="line">            │	│	├─fontface.css(字体样式)</span><br><span class="line">            │	│	├─header_beautify.css(子菜单美化)</span><br><span class="line">            │	│	├─slideshow.css</span><br><span class="line">            │	│	├─starlight.css(星光背景)</span><br><span class="line">            │	│	└─twikoo_beautify(Twikoo评论美化)</span><br><span class="line">            │	├─FangZhengKaiTiJianTi-1.ttf(字体美化)</span><br><span class="line">            │	│</span><br><span class="line">            │   └─img(新增，主题图片)</span><br><span class="line">            │   </span><br><span class="line">            └─js</span><br><span class="line">            	└─custom</span><br><span class="line">            		├─foot.js(页脚修改)</span><br><span class="line">            		├─jquery.js(页脚修改支持)</span><br><span class="line">            		├─sakura.js(樱花背景动效)</span><br><span class="line">            		├─snow.js(雪花背景动效)</span><br><span class="line">            		├─snowflake.js(雪花背景动效)</span><br><span class="line">            		├─switch.js(切换明暗模式)</span><br><span class="line">            		└─universe.js(星空背景)</span><br></pre></td></tr></table></figure>
<h3 id="注意abbrlink">注意：abbrlink</h3>
<h4 id="开头为博客搭建相关">100 开头为博客搭建相关</h4>
<h4 id="开头为javase相关">101 开头为JavaSE相关</h4>
<h4 id="开头为-javaweb相关">102 开头为 JavaWeb相关</h4>
<h4 id="开头为ssm相关">103 开头为ssm相关</h4>
<h4 id="开头为mysql相关">104 开头为MySQL相关</h4>
<h4 id="开头为htmlcss相关">105开头为HTML+CSS相关</h4>
<h4 id="开头为springcloud相关">106开头为SpringCloud相关</h4>
<h4 id="开头为redis相关">107开头为Redis相关</h4>
<h4 id="开头为杂项">2 开头为杂项</h4>
<h4 id="开头为刷题笔记">9开头为刷题笔记</h4>
<h3 id="更新日志">更新日志</h3>
<h4 id="section">2023-05-18</h4>
<h5 id="更新相关">更新相关</h5>
<ul>
<li>无</li>
</ul>
<h5 id="bug相关">bug相关</h5>
<ul>
<li>无</li>
</ul>
<h5 id="杂项">杂项</h5>
<ul>
<li>初步创建github仓库，安装了nodejs和hexo，初始化了hexo博客</li>
</ul>
<h4 id="section-1">2023-05-19</h4>
<h5 id="更新相关-1">更新相关</h5>
<ul>
<li>无</li>
</ul>
<h5 id="bug相关-1">bug相关</h5>
<ul>
<li>无</li>
</ul>
<h5 id="杂项-1">杂项</h5>
<p>采用next主题，进行了主题优化</p>
<h4 id="section-2">2023-05-20</h4>
<h5 id="更新相关-2">更新相关</h5>
<ul>
<li>无</li>
</ul>
<h5 id="bug相关-2">bug相关</h5>
<ul>
<li>无</li>
</ul>
<h5 id="杂项-2">杂项</h5>
<p>放弃使用next主题，改用butterfly主题</p>
<h4 id="section-3">2023-05-21</h4>
<h5 id="更新相关-3">更新相关</h5>
<ul>
<li>无</li>
</ul>
<h5 id="bug相关-3">bug相关</h5>
<ul>
<li>无</li>
</ul>
<h5 id="杂项-3">杂项</h5>
<p>计划将博客迁移到腾讯云上，购买了腾讯云服务器与域名，申请了ssl证书，在等待24小时后进行备案</p>
<h4 id="section-4">2023-05-22</h4>
<h5 id="更新相关-4">更新相关</h5>
<ul>
<li>无</li>
</ul>
<h5 id="bug相关-4">bug相关</h5>
<ul>
<li>无</li>
</ul>
<h5 id="杂项-4">杂项</h5>
<p>进行备案，同时将空闲的服务器制作成了饥荒游戏的服务器</p>
<h4 id="section-5">2023-05-23</h4>
<h5 id="更新相关-5">更新相关</h5>
<ul>
<li>无</li>
</ul>
<h5 id="bug相关-5">bug相关</h5>
<ul>
<li>无</li>
</ul>
<h5 id="杂项-5">杂项</h5>
<p>备案验证</p>
<h4 id="section-6">2023-05-24</h4>
<h5 id="更新相关-6">更新相关</h5>
<ul>
<li><p>主题优化，更改了博客的背景样式包括不同页面的背景，底部角标如运行时间等，背景透明度</p></li>
<li><p>添加了樱花特效与雪花特效，选择了樱花特效</p></li>
<li><p>添加了评论系统</p></li>
<li><p>添加了文章随机封面</p></li>
<li><p>更改了代码块显示</p></li>
<li><p>添加了本地搜索功能</p></li>
<li><p>修改了头像以及主页封面等</p></li>
<li><p>添加了文章版权信息</p></li>
<li><p>更改了图片放大查看</p></li>
<li><p>添加了相关文章功能</p></li>
<li><p>更改了侧边栏显示</p></li>
<li><p>更改了公告栏设置</p></li>
<li><p>更改了toc目录</p></li>
<li><p>更改了鼠标点击效果</p></li>
<li><p>更改了打字效果</p></li>
<li><p>更改了footer背景</p></li>
<li><p>添加了字数统计功能</p></li>
<li><p>更改了分享功能</p></li>
<li><p>更新了懒加载功能</p></li>
<li><p>在iconfont中添加了自定义图标</p></li>
</ul>
<h5 id="bug相关-6">bug相关</h5>
<ul>
<li>无</li>
</ul>
<h5 id="杂项-6">杂项</h5>
<ul>
<li>无</li>
</ul>
<h4 id="section-7">2023-05-25</h4>
<h5 id="更新相关-7">更新相关</h5>
<ul>
<li>无</li>
</ul>
<h5 id="bug相关-7">bug相关</h5>
<ul>
<li>无</li>
</ul>
<h5 id="杂项-7">杂项</h5>
<p>备案成功，一整天在尝试将自己的博客由github迁移到腾讯云上，晚上成功，博客进行了cdn加速，在国内的访问速度也非常快了</p>
<h4 id="section-8">2023-05-26</h4>
<h5 id="更新相关-8">更新相关</h5>
<ul>
<li>让域名被百度引擎收录</li>
<li>添加了博客日历功能</li>
<li>git贡献日历（已经删除）</li>
</ul>
<h5 id="bug相关-8">bug相关</h5>
<ul>
<li>晚上发现博客更新后会出现cname失效的bug，在dns解析页面删除了存储桶的解析后bug解决（花了一晚上。。）</li>
</ul>
<h5 id="杂项-8">杂项</h5>
<ul>
<li>知道了腾讯云CDN加速需要收费，不过收费较为便宜</li>
</ul>
<h4 id="section-9">2023-05-27</h4>
<h5 id="更新相关-9">更新相关</h5>
<ul>
<li>添加了博客搜索功能</li>
<li>更新了评论功能，绑定了域名，新增部署，创建了定时任务，设置了安全域名</li>
<li>更新了评论功能，绑定了qq邮箱，绑定授权码</li>
<li>添加了评论回复显示身份功能</li>
<li>Valine评论功能废弃（改用Twikwoo。。。）</li>
</ul>
<h5 id="bug相关-9">bug相关</h5>
<ul>
<li><p>发现错误，baidu_url_submit配置的count过大，即git命令行出现{“error”:400,”message”:”over
quota”}代码，更改count为20后无错误</p></li>
<li><p><strong>上述错误仍然出现，不知道什么原因。</strong></p></li>
<li><p>遇到了严重问题，github.io跳转失败，CDN加速无法添加A记录？（失败，github自带CDN加速，而自己的网站已经开启了CDN加速，除非使用子域名解决CNAME冲突？以后有需求再说吧，目前是国内wang-nine.cn访问，国外wang-nine.github.io）</p></li>
</ul>
<h5 id="杂项-9">杂项</h5>
<ul>
<li>尝试更新valine，接入自己的域名，但是卡在了部署证书这一步，在论坛反应后等待</li>
<li>晚上发现已绑定（奇怪。）尝试更新评论系统吧</li>
<li>卡在了魔改valine的这一步，彻底放弃了，尝试更新更好的twikoo评论系统</li>
</ul>
<h4 id="section-10">2023-05-28</h4>
<h5 id="更新相关-10">更新相关</h5>
<ul>
<li>更新twikoo评论功能</li>
<li>MongoDB申请存储管理挂载twikoo评论(暂时不予采用)</li>
<li>腾讯云开发赠送学生免费6个月(采用腾讯云开发对twikoo评论进行配置)</li>
<li>新增公式支持功能</li>
</ul>
<h5 id="bug相关-10">bug相关</h5>
<ul>
<li>无</li>
</ul>
<h5 id="杂项-10">杂项</h5>
<ul>
<li>无</li>
</ul>
<h4 id="section-11">2023-05-29</h4>
<h5 id="更新相关-11">更新相关</h5>
<ul>
<li>更新Twikoo评论样式美化(在D:)</li>
<li>更新了分离搜索栏与菜单栏</li>
<li>更新了顶栏常驻</li>
<li>更新了文档支持公式</li>
</ul>
<h5 id="bug相关-11">bug相关</h5>
<ul>
<li>顶部导航栏居中出了问题</li>
<li>xxxxxxxxxx57 1package com.itheima.aop;2​3import
org.aspectj.lang.JoinPoint;4import
org.aspectj.lang.ProceedingJoinPoint;5import
org.aspectj.lang.annotation.<em>;6import
org.springframework.stereotype.Component;7​8import
java.util.Arrays;9​10@Component11<span class="citation"
data-cites="Aspect12public">@Aspect12public</span> class MyAdvice {13  
 <span class="citation"
data-cites="Pointcut">@Pointcut</span>("execution(</em>
com.itheima.dao.BookDao.findName(..))")14    private void pt(){}15​16  
 //JoinPoint：用于描述切入点的对象，必须配置成通知方法中的第一个参数，可用于获取原始方法调用的参数17//
  <span class="citation" data-cites="Before">@Before</span>("pt()")18  
 public void before(JoinPoint jp) {19        Object[] args =
jp.getArgs();20        System.out.println(Arrays.toString(args));21    
   System.out.println("before advice ..." );22   }23​24//   <span
class="citation" data-cites="After">@After</span>("pt()")25    public
void after(JoinPoint jp) {26        Object[] args = jp.getArgs();27    
   System.out.println(Arrays.toString(args));28      
 System.out.println("after advice ...");29   }30​31  
 //ProceedingJoinPoint：专用于环绕通知，是JoinPoint子类，可以实现对原始方法的调用32//
  <span class="citation" data-cites="Around">@Around</span>("pt()")33  
 public Object around(ProceedingJoinPoint pjp) {34        Object[] args
= pjp.getArgs();35        System.out.println(Arrays.toString(args));36  
     args[0] = 666;37        Object ret = null;38        try {39        
   ret = pjp.proceed(args);40       } catch (Throwable t) {41          
 t.printStackTrace();42       }43        return ret;44   }45​46  
 //设置返回后通知获取原始方法的返回值，要求returning属性值必须与方法形参名相同47
   <span class="citation"
data-cites="AfterReturning">@AfterReturning</span>(value =
"pt()",returning = "ret")48    public void afterReturning(JoinPoint
jp,String ret) {49        System.out.println("afterReturning advice
..."+ret);50   }51​52  
 //设置抛出异常后通知获取原始方法运行时抛出的异常对象，要求throwing属性值必须与方法形参名相同53
   <span class="citation"
data-cites="AfterThrowing">@AfterThrowing</span>(value = "pt()",throwing
= "t")54    public void afterThrowing(Throwable t) {55      
 System.out.println("afterThrowing advice ..."+t);56   }57}java</li>
<li>子菜单栏居中出了问题</li>
</ul>
<h5 id="杂项-11">杂项</h5>
<ul>
<li>无</li>
</ul>
<h4 id="section-12">2023-05-30</h4>
<h5 id="更新相关-12">更新相关</h5>
<ul>
<li>实现了子菜单栏居中的效果</li>
<li>删除了顶栏常驻效果</li>
<li>删除了分离搜索栏和菜单栏</li>
<li>将博客的字体改为了楷体</li>
<li>更新了博客中文章双栏显示（失败）</li>
<li>美化了博客中双栏显示的效果（失败）</li>
<li>修复了双栏显示后页码不居中的bug（失败）</li>
<li>增加了轮播图的功能（在文章配置中添加swiper_index属性，越大越先出现）</li>
</ul>
<h5 id="bug相关-12">bug相关</h5>
<ul>
<li>阅读量和评论数一直加载中（已解决）</li>
</ul>
<h5 id="杂项-12">杂项</h5>
<ul>
<li>无</li>
</ul>
<h4 id="section-13">2023-05-31</h4>
<h5 id="更新相关-13">更新相关</h5>
<ul>
<li>取消了日历功能（取消）（加上了）</li>
<li>增加了夜晚模式下的流星背景特效</li>
<li>增加了首页轮播图</li>
<li>增加了一图流</li>
<li>增加了日夜切换动画</li>
<li>增加了首页轮播图</li>
</ul>
<h5 id="bug相关-13">bug相关</h5>
<ul>
<li>首页透明度bug（使用一图流解决）</li>
<li>黑夜模式首页背景不同bug（使用一图流解决）</li>
<li>封面不加载</li>
</ul>
<h5 id="杂项-13">杂项</h5>
<ul>
<li>无</li>
</ul>
<h4 id="section-14">2023-06-01</h4>
<h5 id="更新相关-14">更新相关</h5>
<ul>
<li>无</li>
</ul>
<h5 id="bug相关-14">bug相关</h5>
<ul>
<li>博客第二页未更新（重新在cos中上传即可）</li>
</ul>
<h5 id="杂项-14">杂项</h5>
<ul>
<li>无</li>
</ul>
<h4 id="section-15">2023-06-02</h4>
<h5 id="更新相关-15">更新相关</h5>
<ul>
<li>删除了轮播图</li>
</ul>
<h5 id="bug相关-15">bug相关</h5>
<ul>
<li>无</li>
</ul>
<h5 id="杂项-15">杂项</h5>
<ul>
<li>无</li>
</ul>
<h4 id="section-16">2023-06-03</h4>
<h5 id="更新相关-16">更新相关</h5>
<ul>
<li>无</li>
</ul>
<h5 id="bug相关-16">bug相关</h5>
<ul>
<li>无</li>
</ul>
<h5 id="杂项-16">杂项</h5>
<ul>
<li>无</li>
</ul>
<h4 id="section-17">2023-06-24</h4>
<h5 id="更新相关-17">更新相关</h5>
<ul>
<li>无</li>
</ul>
<h5 id="bug相关-17">bug相关</h5>
<ul>
<li>直接gitbash上传四件套可以解决博客第二页未更新bug</li>
</ul>
<h5 id="杂项-17">杂项</h5>
<ul>
<li>无</li>
</ul>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>后端</title>
    <url>/posts/999999999.html</url>
    <content><![CDATA[<p>[toc]</p>
<h4
id="请你说说java的特点和优点为什么要选择java">1.请你说说Java的特点和优点,为什么要选择Java</h4>
<blockquote>
<ul>
<li><p>Java语言的特点是：一次编译，到处运行，即平台无关性；是纯粹的面向对象的语言。</p></li>
<li><p>JAVA语言的优点有：内置的类库简化了开发人员的设计工作；具有较好的安全性和健壮性；开发人员不需要对内存的使用进行管理。</p></li>
<li><p>选择JAVA的原因是：使用范围很广，安卓操作系统的应用软件目前大部分还是使用JAVA语言编写。</p></li>
</ul>
</blockquote>
<h4
id="请你说说java基本数据类型和引用类型">2.请你说说Java基本数据类型和引用类型</h4>
<blockquote>
<p>Java的数据类型分为基本数据类型和引用数据类型两大类。
基本数据类型共有八大类,这八大数据类型又可分为四小类,分别是整数类型（byte/short/int/long）、浮点类型（float、double）、字符类型（char）和布尔类型（boolean）。其中,int是最常用的整数类型,double是最为常用的浮点类型,除了布尔类型之外的其他7个类型,都可以看做是数字类型,它们相互之间可以进行类型转换。
引用类型包括数组、类、接口类型,还有一种特殊的null类型,所谓引用数据类型就是对一个对象的引用,对象包括实例和数组两种。</p>
<p>8种基本数据类型的变量的值存放在栈内存，有char(16位),byte(8位),short(16位),int(32位)，long(64位)float(32位),double(64位),boolean。
引用类型的变量存放引用地址，堆内存才是真正的值。类，接口，数组,string等为引用类型。</p>
</blockquote>
<h4
id="请你说一下抽象类和接口的区别">3.请你说一下抽象类和接口的区别</h4>
<blockquote>
<p>相同点：</p>
<ul>
<li>1、两者都不能实例化；</li>
<li>2、可以拥有抽象方法。</li>
</ul>
<p>区别：</p>
<ul>
<li>1、抽象类定义的关键字是abstract
class，接口定义的关键字是interface；</li>
<li>2、属性上，抽象类可以有静态变量、常量和成员变量，接口只能有常量；</li>
<li>3、抽象方法可以有普通方法，而接口在 JDK1.8
之前只能有抽像方法（1.8之后，增加了静态方法和默认方法）；</li>
<li>4、抽象方法可以有构造方法，接口不可以有构造方法。</li>
<li>5、一个类只能单继承一个父类，而一个接口可以继承多个父接口，同时，一个类可以实现多个接口却没有实现多个父类这一说法；</li>
<li>6、抽象方法在业务编程上更像一个模板，有自己的功能，同时也可以有优化补充的多种形式，而接口更像是一种规范和要求，实现就要按照要求来进行。</li>
</ul>
</blockquote>
<h4 id="请你说一下final关键字">4.请你说一下final关键字</h4>
<blockquote>
<p>final可以修饰类，方法，变量。 final修饰类，该类不可被继承。
final修饰方法，该方法不能被重写。
final修饰变量，如果是基本变量则值不能再改变，如果是引用变量则引用地址不能改变，但值可以改变。</p>
</blockquote>
<h4 id="说说static修饰符的用法">5.说说static修饰符的用法</h4>
<blockquote>
<p>Java类中包含了成员变量、方法、构造器、初始化块和内部类（包括接口、枚举）5种成员,static关键字可以修饰除了构造器外的其他4种成员。static关键字修饰的成员被称为类成员。类成员属于整个类,不属于单个对象。
static关键字有一条非常重要的规则,即类成员不能访问实例成员,因为类成员属于类的,类成员的作用域比实例成员的作用域更大,很容易出现类成员初始化完成时,但实例成员还没被初始化,这时如果类成员访问实力成员就会引起大量错误。
加分回答
static修饰的部分会和类同时被加载。被static修饰的成员先于对象存在,因此,当一个类加载完毕,即使没有创建对象也可以去访问被static修饰的部分。
静态方法中没有this关键词,因为静态方法是和类同时被加载的,而this是随着对象的创建存在的。静态比对象优先存在。也就是说,静态可以访问静态,但静态不能访问非静态而非静态可以访问静态。</p>
</blockquote>
<h4
id="请你说说string类以及new-string和使用字符串直接量">6.请你说说String类,以及new
string和使用字符串直接量</h4>
<blockquote>
<p>String类被final修饰，所以不能被继承。创建String对象时可以使用字符串直接量，如String
str="1abc", 另一种String str=new
String("1abc"),前者使用常量池来管理，后者先判断常量池中是否已存在此字符串，不存在就也在常量池创建，再在堆内存创建一个新的对象，因此后者开销更大。</p>
</blockquote>
<h4
id="stringstringbufferstringbuilder有什么区别">7.String、StringBuffer、Stringbuilder有什么区别</h4>
<blockquote>
<p>StringBuilder和StringBuffer非常类似，均代表可变的字符序列，而且方法也一样</p>
<p>String:不可变字符序列，效率低，但是复用率高。</p>
<p>StringBuffer:可变字符序列、效率较高(增删)、线程安全</p>
<p>StringBuilder:可变字符序列、效率最高、线程不安全</p>
</blockquote>
<h4 id="请你说说与equals的区别">8.请你说说==与equals()的区别</h4>
<blockquote>
<p>== 比较基本数据类型时，比较的是两个数值是否相等；
比较引用类型是，比较的是对象的内存地址是否相等。 equals()
没有重写时，Object默认以==来实现，即比较两个对象的内存地址是否相等；重写以后，按照对象的内容进行比较</p>
</blockquote>
<h4
id="请你说说hashcode和equals的区别为什么重写equals就要重写hashcod">9.请你说说hashCode()和equals()的区别,为什么重写equals()就要重写hashcod()</h4>
<blockquote>
<p>得分点 hashCode()用途,equals()用途,hashCode()、equals()约定</p>
<ul>
<li>1、hashCode()：获取哈希码，equals()：比较两个对象是否相等。</li>
<li>2、二者两个约定：如果两个对象相等，它们必须有相同的哈希码；若两个对象的哈希码相同，他们却不一定相等。也就是说,equals()比较两个对象相等时hashCode()一定相等，hashCode()相等的两个对象equqls()不一定相等。</li>
<li>3、加分回答：由于hashCode()与equals()具有联动关系，equals()重写时，hashCode()进行重写，使得这两个方法始终满足相关的约定。</li>
</ul>
</blockquote>
<h4 id="请你讲一下java-8的新特性">10.请你讲一下Java 8的新特性</h4>
<blockquote>
<p>得分点 Lambda表达式、Java8对接口的改进</p>
<ul>
<li>1、Lambda表达式：可将功能视为方法参数，或者将代码视为数据。使用
Lambda 表达式，可以更简洁地表示单方法接口（称为功能接口）的实例。</li>
<li>2、方法引用：提供了非常有用的语法，可直接引用已有Java类或对象（实例）的方法或构造器。与Lambda联合使用,方法引用可以使语言的构造更紧凑简洁,减少冗余代码。</li>
<li>3、对接口进行了改进：允许在接口中定义默认方法，默认方法必须使用default修饰。</li>
<li>4、Stream API：新添加的Stream
API（java.util.stream）支持对元素流进行函数式操作。Stream API 集成在
Collections API 中,可以对集合进行批量操作，例如顺序或并行的 map-reduce
转换。</li>
<li>5、Date Time API：加强对日期与时间的处理。</li>
</ul>
</blockquote>
<h4
id="介绍一下包装类的自动拆装箱与自动装箱">11.介绍一下包装类的自动拆装箱与自动装箱</h4>
<blockquote>
<p>得分点 包装类的作用,应用场景</p>
<ul>
<li>1、自动装箱、自动拆箱是JDK1.5提供的功能。</li>
<li>2、自动装箱：把一个基本类型的数据直接赋值给对应的包装类型；</li>
<li>3、自动拆箱是指把一个包装类型的对象直接赋值给对应的基本类型；</li>
<li>4、通过自动装箱、自动拆箱功能，简化基本类型变量和包装类对象之间的转换过程</li>
</ul>
</blockquote>
<h4 id="请你说说java的异常处理机制">12.请你说说Java的异常处理机制</h4>
<blockquote>
<ul>
<li>1、异常处理机制让程序具有容错性和健壮性,程序运行出现状况时,系统会生成一个Exception对象来通知程序</li>
<li>2、处理异常的语句由try、catch、finally三部分组成。try块用于包裹业务代码,catch块用于捕获并处理某个类型的异常,finally块则用于回收资源。</li>
<li>3、如果业务代码发生异常,系统创建一个异常对象,并将其提交给JVM,由JVM寻找可以处理这个异常的catch块,并将异常对象交给这个catch块处理。如果JVM没有找到，运行环境终止,Java程序退出。</li>
<li>4、Java也允许程序主动抛出异常。当业务代码中,判断某项错误的条件成立时,可以使用throw关键字向外抛出异常</li>
</ul>
</blockquote>
<h4 id="说说你对面向对象的理解">13.说说你对面向对象的理解</h4>
<blockquote>
<ul>
<li>1、面向对象三大基本特征：封装、继承、多态。</li>
<li>2、封装：将对象的状态信息隐藏在对象内部，不允许外部程序直接访问对象内部信息，让外部程序通过该类提供的方法来实现对内部信息的操作和访问,提高了代码的可维护性；</li>
<li>3、继承：实现代码复用的重要手段,通过extends实现类的继承，实现继承的类被称为子类，被继承的类称为父类；</li>
<li>4、多态的实现离不开继承,在设计程序时,我们可以将参数的类型定义为父类型。在调用程序时根据实际情况,传入该父类型的某个子类型的实例,这样就实现了多态。</li>
</ul>
<p>多态实现的三个条件：1.需要有继承关系的存在。 2. 需要有方法的重写。 3.
需要有父类的引用指向子类对象。</p>
</blockquote>
<h4
id="请你说说重载和重写的区别构造方法能不能重写">14.请你说说重载和重写的区别,构造方法能不能重写</h4>
<blockquote>
<p>重写和重载的区别：</p>
<ul>
<li>1.重载发生在同一类中，而重写发生在子类中。</li>
<li>2.重载要求方法名相同，参数列表，返回值，访问修饰符都可以不同。重写要求方法名相同，参数列表相同，返回值类型要小于等于父类的方法，抛出的异常要小于等于父类方法抛出的异常，访问修饰符权限大于等于父类方法的访问修饰符权限。</li>
<li>3.final，private修饰的方法不能重写，构造方法也不能重写。</li>
</ul>
<p>构造方法不能重写。因为构造方法需要和类保持同名,而重写的要求是子类方法要和父类方法保持同名。如果允许重写构造方法的话,那么子类中将会存在与类名不同的构造方法,这与构造方法的要求是矛盾的。</p>
</blockquote>
<h4 id="请介绍一下访问修饰符">15.请介绍一下访问修饰符</h4>
<blockquote>
<p>Java中的访问修饰符有四种，分别为private,default,protected,public。</p>
<ul>
<li>private：类中被private修饰的只能在被当前类的内部访问</li>
<li>default：类中被default修饰的只能在当前类和当前类所在包的其他类访问</li>
<li>protected：类中被protected修饰的可以被当前类和当前类所在的包的其他类以及子类访问</li>
<li>public：类中被public修饰的能被当前项目下的所有类访问。</li>
</ul>
</blockquote>
<h4 id="请你说说泛型泛型擦除">16.请你说说泛型、泛型擦除</h4>
<blockquote>
<ul>
<li>1.泛型：Java在jdk1.5引入了泛型，在没有泛型之前，每次从集合中读取的对象都必须进行类型转换，如果在插入对象时，类型出错，那么在运行时转换处理的阶段就出错；在提出泛型之后就可以明确的指定集合接受哪些对象类型，编译器就能知晓并且自动为插入的代码进行泛化，在编译阶段告知是否插入类型错误的对象，程序会变得更加安全清晰。</li>
<li>2.泛型擦除：Java泛型是伪泛型，因为Java代码在编译阶段，所有的泛型信息会被擦除，Java的泛型基本上都是在编辑器这个层次上实现的，在生成的字节码文件中是不包含泛型信息的，使用泛型的时候加上的类型，在编译阶段会被擦除掉，这个过程称为泛型擦除。</li>
</ul>
</blockquote>
<h4 id="请说说你对反射的了解">17.请说说你对反射的了解</h4>
<blockquote>
<p>在程序运行期间动态的获取对象的属性和方法的功能叫做反射。</p>
<p>它能够在程序运行期间，对于任意一个类，都能知道它所有的方法和属性，对于任意一个对象，都能知道他的属性和方法。</p>
<p>获取Class对象的三种方式：getClass(); xx.class;
Class.forName("xxx");</p>
<p>反射的优缺点：</p>
<ul>
<li>优点：运行期间能够动态的获取类，提高代码的灵活性。</li>
<li>缺点：性能比直接的Java代码要慢很多。</li>
<li>应用场景：spring的xml配置模式，以及动态代理模式都用到了反射。</li>
</ul>
</blockquote>
<h4 id="请你说说多线程">18.请你说说多线程</h4>
<blockquote>
<p>进程是操作系统资源调度的基本单位，线程是处理器任务调度和执行的基本单位，一个进程可以创建多个线程，每个线程有自己独立的程序计数器，本地方法栈和虚拟机栈，线程之间共享进程的堆和方法区。线程之间是通过时间片算法来争夺CPU的执行权的。</p>
<ul>
<li>多线程的优点：当一个线程进入阻塞或者等待状态时，其他的线程可以获取CPU的执行权，提高了CPU的利用率。</li>
<li>多线程的缺点：可能产生死锁；频繁的上下文切换可能会造成资源的浪费；在并发编程中如果因为资源的限制，多线程串行执行，可能速度会比单线程更慢。</li>
</ul>
</blockquote>
<blockquote>
<p>死锁四个条件：</p>
<p>（1） 互斥条件：一个资源每次只能被一个进程使用。</p>
<p>（2）
请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</p>
<p>（3）
不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。</p>
<p>（4）
循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</p>
</blockquote>
<h4 id="说说线程的创建方式">19.说说线程的创建方式</h4>
<blockquote>
<p>创建线程有三种方式，分别是继承Thread类，实现Runnable接口，实现Callable接口</p>
<ul>
<li><p>继承Thread类之后我们需要重写run()方法，方法中是我们希望这个线程执行什么操作，再创建对象的实例，通过实例对象的start())方法开启这个线程</p></li>
<li><p>实现runnable接口之后，我们需要实现run()方法，方法中同样写我们需要执行的操作，然后将实现了接口的类作为参数创建一个Thread对象，通过这个对象的start方法开启线程</p></li>
<li><p>实现Callable之后，需要实现call()方法，方法中写我们需要的操作，然后创建实现接口类的对象，将对象作为参数创建FurtureTask对象，再将task对象作为参数创建thread对象，调用start方法开启线程，还可以使用task对象的get方法获取返回值。他们的区别是前二者不能获取返回值，callable接口可以获得返回值，一般在实际使用中，更多使用实现接口的方式开启线程，因为接口不会占用类的继承位置</p></li>
</ul>
</blockquote>
<h4 id="说说线程的状态">20.说说线程的状态</h4>
<blockquote>
<ul>
<li>1：新建态(NEW)：当一个线程被创建成功后，但并没有执行它的start方时处于该状态</li>
<li>2：就绪态(RUNNABLE)：一个线程执行了start方法进入就绪态开始竞争cpu调度权但还没有竞争到以完成它的任务</li>
<li>3：运行态：一个线程对象获取到了cpu的资源调度权，并进入允许态开始完成它的任务</li>
<li>4：阻塞态(BLOCKED)：若一个运行中的线程存在同步操作，此时锁被其他线程占用，该线程就会进入阻塞态等待获取锁</li>
<li>5：限期等待(TIMED
WAITING)：正在运行的线程执行了Thread.spleep()方法或者设置了timeout的wait()方法，join方法等进入一定时间的等待，系统自动唤醒。</li>
<li>6：不限期等待(WAITING)：正在运行的线程执行了未设置timeout的wait方法或join方法进入等待，只有通过其他线程使用interrupt()或notify方法对其进行唤醒。</li>
<li>7：死亡态(TEMINATED)：线程成功执行完毕或执行中抛出异常中断了线程会进入死亡态。</li>
</ul>
</blockquote>
<h4 id="说说wait和sleep的区别">21.说说wait()和sleep()的区别</h4>
<blockquote>
<ul>
<li>1.所属的类型不同 -
wait()是Object类的实例方法,调用该方法的线程将进入WAITING状态。 -
sleep()是Thread类的静态方法,调用该方法的线程将进入TIMED_WTING状态。</li>
<li>2.对锁的依赖不同 -
wait()依赖于synchronized锁,通过监视器进行调用,调用后线程会释放锁。 -
sleep()不依赖于任何锁,所以在调用后它也不会释放锁</li>
<li>3.返回的条件不同 -
调用wait()进入等待状态的线程,需要由notify()/notifyAll()唤醒,从而返回。 -
调用sleep()进入超时等待的线程,需要在超时时间到达后自动返回。</li>
</ul>
</blockquote>
<h4 id="说说怎么保证线程安全">22.说说怎么保证线程安全</h4>
<blockquote>
<p>线程的安全主要是原子性、可见性、有序性三个问题。</p>
<ul>
<li>1、可见性：可见性问题是由处理器核心的缓存导致的,每个核心均有各自的缓存,而这些缓存均要与内存进行同步，volatile在多处理器开发中保证了共享变量的“可见性”</li>
<li>2、原子性：一个或者多个操作在CPU执行的过程中不被中断的特性。线程切换可能造成原子性问题。synchronized关键字可以解决原子性、有序性和可见性问题，同时lock和Atomic开头的类也可以解决原子性问题</li>
<li>3、有序性：程序执行的顺序按照代码的顺序执行，编译优化可能造成这个问题。volatile关键字通过禁止指令重排来解决有序性问题</li>
</ul>
</blockquote>
<h4 id="说说你了解的线程同步方式">23.说说你了解的线程同步方式</h4>
<blockquote>
<p>java主要通过加锁的方式实现线程同步：主要有两种方式：synchronized关键字和lock接口。</p>
<ul>
<li>synchronized可以加在三个不同的位置，对应着三种不同范围，区别是锁对象的不同：
<ul>
<li>1.加在实例方法上，锁的就是当前的实例。</li>
<li>2.加在静态方法和类上，锁的就是当前整个类。</li>
<li>3.加在代码块上，锁的就是代码块里面的内容。我们应该合理的选择锁的对象。</li>
</ul></li>
<li>lock锁接口除了支持上述功能外，还支持了响应中断，超时机制，阻塞队列等。</li>
</ul>
</blockquote>
<h4 id="说说你了解的线程通信方式">24.说说你了解的线程通信方式</h4>
<h4 id="说说java中常用的锁及原理">25.说说Java中常用的锁及原理</h4>
<blockquote>
<p>synchronized关键字和lock锁接口：</p>
<ul>
<li>synchronized关键字底层采用java对象头来存储锁信息的。</li>
<li>lock锁接口是基于AQS实现的。AQS内部定义一个先进先出的队列实现锁的同步，同时还定义了同步状态来记录锁信息。</li>
</ul>
</blockquote>
<h4
id="synchronized和lock有什么区别">26.synchronized和Lock有什么区别</h4>
<blockquote>
<ul>
<li>synchronized是同步锁，可以修饰静态方法、普通方法和代码块。修饰静态方法时锁住的是类对象，修饰普通方法时锁住的是实例对象。当一个线程获取锁时，其他线程想要访问当前资源只能等当前线程释放锁。</li>
<li>synchronized是java的关键字，Lock是一个接口。</li>
<li>synchronized可以作用在代码块和方法上，Lock只能用在代码里。</li>
<li>synchronized在代码执行完或出现异常时会自动释放锁，Lock不会自动释放，需要在finally中释放。</li>
<li>synchronized会导致线程拿不到锁一直等待，Lock可以设置获取锁失败的超时时间。</li>
<li>synchronized无法获知是否获取锁成功，Lock则可以通过tryLock判断是否加锁成功。</li>
</ul>
</blockquote>
<h4 id="说说synchronize的用法及原理">27.说说synchronize的用法及原理</h4>
<blockquote>
<p>synchronized可以修饰静态方法、普通方法、代码块。
能够保证同一个时刻只有一个线程执行该段代码，保证线程安全。
在执行完或者出现异常时自动释放锁。
synchronized作用在代码块时，它的底层是通过monitorenter、monitorexit指令来实现的。</p>
</blockquote>
<h4 id="说说你对aqs的理解">28.说说你对AQS的理解</h4>
<blockquote>
<p>1、AQS队列同步器,用来构建锁的基础框架,Lock实现类都是基于AQS实现的。
2、AQS是基于模板方法模式进行设计的,所以锁的实现需要继承AQS并重写它指定的方法。
3、AQS内部定义了一个FIFO的队列来实现线程的同步,同时还定义了同步状态来记录锁的信息。
4、AQS的模板方法,将管理同步状态的逻辑提炼出来形成标准流程,这些方法主要包括：独占式获取同步状态、独占式释放同步状态、共享式获取同步状态、共享式释放同步状态</p>
</blockquote>
<h4 id="说说你对线程池的理解">29.说说你对线程池的理解</h4>
<blockquote>
<p>ThreadPoolExecutor构造器： public ThreadPoolExecutor（int
corePoolSize int maximumPoolSize, long keepAliveTIme, TimeUnit unit,
BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory,
RejectedExecutionHandler handler)
参数一：指定线程池的线程数量（核心线程）：corePoolsize -----&gt;
不能小于0 参数二：指定线程池可支持的最大线程数：maximumPoolSize
------&gt; 最大数量&gt;=核心线程数量
参数三：指定临时线程的最大存活时间：keepAliveTime ------&gt; 不能小于0
参数四：存活时间的单位（秒，分，时，天）：unit ------&gt; 时间单位
参数五：指定任务队列：workQueue ------&gt; 不能为null
参数六：指定用那个线程工厂创建线程：threadFactory ------&gt; 不能为null
参数七：指定线程忙，任务忙的时候，新任务来了怎么办，即拒绝策略：handler
------&gt; 不能为null</p>
<p><strong>（重要！！！）注意两点：</strong>
<strong>临时线程什么时候创建：新任务提交时发现核心线程都在忙，任务队列满，还可以创建临时线程时才会创建。</strong>
<strong>什么时候开始拒绝任务：核心线程和临时线程都在忙，任务队列都满，新任务过来会拒绝。</strong></p>
<p>拒绝策略：</p>
<table>
<colgroup>
<col style="width: 38%" />
<col style="width: 61%" />
</colgroup>
<thead>
<tr class="header">
<th>策略</th>
<th>详解</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ThreadPoolExecutor.AbortPolicy</td>
<td>丢弃任务抛出RejectedExecutionException异常</td>
</tr>
<tr class="even">
<td>ThreadPoolExecutor.DiscardPolicy</td>
<td>丢弃任务不抛出异常（不推荐）</td>
</tr>
<tr class="odd">
<td>ThreadPoolExecutor.DiscardOldestPolicy</td>
<td>抛弃等待最久的任务并把当前任务加入队列</td>
</tr>
<tr class="even">
<td>ThreadPoolExecutor.CallerRunsPolicy</td>
<td>由主线程负责调用的run()方法绕过线程池直接执行，即来新任务主线程亲自服务</td>
</tr>
</tbody>
</table>
</blockquote>
<h4 id="说说volatile的用法及原理">?30.说说volatile的用法及原理</h4>
<blockquote>
<p>1.修饰被不同线程访问和修改的变量
2.被其修饰的变量，系统每次用到它时都是直接从对应的内存中提取，而不会利用缓存（如寄存器），所有线程在任何时候所看到变量的值都是相同的
3.volatile不能保证操作的原子性，因此不能代替synchronized
4.能不使用就尽量不要使用</p>
</blockquote>
<h4 id="说说你对threadlocal的理解">?31.说说你对ThreadLocal的理解</h4>
<blockquote>
<p>ThreadLocal即线程变量，它用于共享变量在多线程中的隔绝，即每个线程都有一个该变量的副本彼此互不影响也就不需要同步机制了，实现原理：每个Thread对象中都有一个ThreadLocal类的内部类ThreadLocalMap对象，他是一个键值形式的容器，以ThreadLocal对象的get和set方法来存取共享变量值，原理时：以ThreadLocal对象作为key来存取共享变量值。一个ThreadLocal用完后必须remove，否则会造成内存泄漏。</p>
</blockquote>
<h4 id="请你说说juc">?32.请你说说JUC</h4>
<blockquote>
<p>JUC是java.util.concurrent的缩写，这个包中包含了支持并发操作的各种工具。</p>
<p>1.原子类：遵循比较和替换原则。可以用于解决单个变量的线程安全问题。</p>
<p>2.锁：与Synchronized类似，在包含synchronized所有功能的基础上，还支持超时机制，响应中断机制，主要用于解决多个变量的线程安全问题。</p>
<p>3.线程池：可以更方便的管理线程，同时避免重复开线程和杀线程带来的消耗，效率高。</p>
<p>4.并发容器：例如ConcurrentHashMap，支持多线程操作的并发集合，效率更快。</p>
</blockquote>
<h4 id="java哪些地方使用了cas">?33.Java哪些地方使用了CAS</h4>
<blockquote>
<p>1、CAS 比较并交换,比较典型的使用场景有原子类、AQS、并发容器。
2、AQS：在向同步队列的尾部追加节点时,它首先会以CAS的方式尝试一次,如果失败则进入自旋状态,并反复以CAS的方式进行尝试。
3、并发容器：以ConcurrentHashMap为例,它的内部多次使用了CAS操作。在初始化数组时,以CAS的方式修改初始化状态,避免多个线程同时进行初始化。在执行put方法初始化头节点时,它会以CAS的方式将初始化好的头节点设置到指定槽的首位,避免多个线程同时设置头节点。</p>
</blockquote>
<h4 id="请说说你对java集合的了解">34.请说说你对Java集合的了解</h4>
<blockquote>
<p>java中的集合类主要都有Collection和Map这两个接口派生而出，其中Collection又派生出List,Set,Queue。所有的集合类都是List,set,queue,map这四个接口的实现类。其中，list代表有序的，可重复的数据集合；set代表无序的，不可重复的数据集合，queue代表先进先出的队列；map是具有映射关系的集合。最常用的实现类又ArrayList,LinkedList,HashMap,TreeMap,HashSet,TreeSet,ArrayQueue。</p>
</blockquote>
<h4 id="你知道哪些线程安全的集合">35.你知道哪些线程安全的集合？</h4>
<blockquote>
<p>java.util包中的集合类大部分都是非线程安全的，例如：ArrayList/LinkedList/HashMap等等，但也有少部分是线程安全的，像是Vector和Hashtable，它们属于很古老的API了，是基于Synchronized实现的，性能很差，在实际的开发中不常用。一般可以使用collections工具类中的syncheronizedXxx()方法将非线程安全的集合包装成线程安全的类。在java5之后可以使用concurrent包提供的大量的支持并发访问的集合类，例如ConcurrentHashMap/CopyOnWriteArrayList等</p>
</blockquote>
<h4 id="请你说说hashmap底层原理">36.请你说说HashMap底层原理</h4>
<blockquote>
<p>在1.8之前，HashMap的底层是数组加链表，在1.8之后是数组+链表+红黑树；
它的put流程是：基于哈希算法来确定元素位置，当我们向集合存入数据时，他会计算传入的key的哈希值，并利用哈希值取绝对值再根据集合长度取余来确定元素的位置，如果这个位置已经存在其他元素了，就会发生哈希碰撞，则hashmap就会通过链表将这些元素组织起来，如果链表的长度达到8时，就会转化为红黑树，从而提高查询速度。
扩容机制：HashMap中数组的默认初始容量为16，当达到默认负载因子0.75时，会以2的指数倍进行扩容。
Hashmap时非线程安全的，在多线程环境下回产生循环死链，因此在多线程环境下建议使用ConcurrentHashMap。</p>
</blockquote>
<h4
id="请你说说hashmap和hashtable的区别">37.请你说说HashMap和Hashtable的区别</h4>
<blockquote>
<ul>
<li>1.Hashtable在实现Map接口时保证了线程安全性，而HashMap则是非线程安全的。所以Hashtable的性能不如HashMap,因为为了保证线程它牺牲了一些性能。</li>
<li>2.Hashtable不允许存入null，无论是以null作为key或value,都会引发异常但，HashMap是允许的。Hashtable是很古老的API，性能不好，不推荐使用，要在多线程下使用ConcurrrntHashMap,它不但保证了线程安全，也通过降低锁的粒度提高了并发访问时的性能</li>
</ul>
</blockquote>
<h4
id="hashmap是线程安全的吗如果不是该如何解决">38.HashMap是线程安全的吗？如果不是该如何解决</h4>
<blockquote>
<p>HashMap不是线程安全的，在添加数据的时候，会根据key和value计算出在底层数组中的位置，然后封装成entrey对象插入，但由于HashMap并没有做对应的线程安全处理，所以如果恰好两个线程同时操作的话，就有点会将其中一个数据覆盖掉，这不符合要求。
那么解决方法就是说，你可以在操作这个HashMap的时候手动的上锁，可以通过Lock也可以通过synchronized关键字。当然我更推荐直接使用java已经提供了的ConcurrentHashMap，其内部使用了Lock来解决线程安全问题，并且底层结构也进行了一些变动，上锁的时候只会锁对应下标的元素，不会对其他位置造成影响，即保证了线程安全，又保证了性能。</p>
</blockquote>
<h4 id="请你说说concurrenthashmap">39.请你说说ConcurrentHashMap</h4>
<blockquote>
<p>ConcurrentHashMap是一个线程安全的集合，它的底层是数组+链表/红黑树构成的。
在1.7的时候采用segment数组+hashEntry的方式实现的，lock加在Segment的上面，在size计算的时候，首先是不加锁的，最多计算三次，前后两次的结果是相同的话那么结果就是准确的，如果不一样的话，那么就加锁，重新计算。
在1.8的时候废弃了这种算法，采用Synchronized+CAS+Node来保证并发安全的进行，使用一个volatile类型的变量baseCount来记录元素的个数，集合每次增加或者删除的时候，basecount就会通过addCount()来对baseCunt产生相应的变化，最后得到元素的个数。
初始值为16,每次扩容都是之前的二倍，不支持null值和null为key</p>
</blockquote>
<h4 id="说说你对arraylist的理解">40.说说你对ArrayList的理解</h4>
<blockquote>
<p>arraylist在jdk7.0的时候，创建容器的时候会在底层创建一个长度为10的object数组，在jdk8.0的时候，在创建容器的时候底层并不会立刻创建，只有在第一次调用add方法的时候才会创建一个长度为10的数组，默认情况下，扩容为原来容量的1.5倍，同时将原有数组中的值复制到新的数组中，并且arraylist属于有序的，可重复的集合，提供了iterator方法，增强了迭代能力。</p>
</blockquote>
<h4
id="请你说说arraylist和linkedlist的区别">41.请你说说ArrayList和LinkedList的区别</h4>
<blockquote>
<ul>
<li>1.ArrayList的实现是基于数组,LinkedList的实现是基于双向链表。</li>
<li>2.对于随机访问ArrayList要优于LinkedList,ArrayList可以根据下标以O(1)时间复杂度对元素进行随机访问,而LinkedList的每一个元素都依靠地址指针和它后一个元素连接在一起,查找某个元素的时间复杂度是O(N)。</li>
<li>3.对于插入和删除操作,LinkedList要优于ArrayList,因为当元素被添加到LinkedList任意位置的时候,不需要像ArrayList那样重新计算大小或者是更新索引</li>
<li>4.LinkedList比ArrayList更占内存,因为LinkedList的节点除了存储数据,还存储了两个引用,一个指向前一个元素,一个指向后一个元素。</li>
</ul>
</blockquote>
<h4 id="请你说说list与set的区别">42.请你说说List与Set的区别</h4>
<blockquote>
<p>list和set都是接口collection的子接口，list代表有序的可重复的集合，每个元素都有对应的顺序索引，可以通过索引来访问指定位置的集合元素。而set表示无序，不可重复的集合元素。但是它有支持排序的实现类treeset，treeset可以确保元素处于排序状态，并支持自然排序和定制排序两种方式，treeset是非线程安全的，内部元素的值不能为null</p>
</blockquote>
<h4 id="请你说说bionioaio">?43.请你说说BIO、NIO、AIO</h4>
<blockquote>
<p>BIO是阻塞IO，当用户线程发送请求后会一直阻塞知道内核将数据准备；NIO是非阻塞IO，用户线程发送请求后，可以做其他工作，并不断询问内核数据，但在数据复制阶段，用户线程依然属于阻塞状态。BIO和NIO都属于同步IO。AIO是异步IO，当用户线程发送请求后，内核会返回一个回调函数，但该回调函数不包含数据，之后用户线程可以去处理其他操作，当数据准备好后，内核会将数据发送给用户线程，而不必像同步IO中用户线程自己去读取。BIO只能处理一个请求，NIO可以处理多个请求。IO多路复用在NIO的基础上加入了事件机制，将用户请求注册到多路复用器上，然后监视是否有IO事件发生，如果有，会通知用户线程，IO多路复用的方式主要有select、poll、epoll。</p>
</blockquote>
<h4 id="请你说说io多路复用">?44.请你说说IO多路复用</h4>
<blockquote>
<p>IO多路复用指的是单个线程能够同时完成对多个IO事件的监听处理。linux提供了select、poll和epoll三种多路复用方式。本质上是利用内核缓存fd描述文件，并内核完成对文件描述符的监听操作。selec是将所用文件描述符的集合从用户态拷贝到内核空间，底层采用的是数组。poll和select相似，主要区别是poll底层使用的是链表，所以其能够监听的文件描述符不受限制。但是这两种方法都需要多次的内核与用户空间的复制拷贝，并且用户空间还需要在O(N)的时间复杂度下对描述符进行遍历才具体知道哪一个文件描述符发生了事件。epoll在内核开辟空间底层采用红黑树，用户可以直接在内核创建需要需要关注的文件描述的节点，当事件发送内核将对应文件描述符直接存入队列并将其返回到用户空间。epoll这种方式可以减少每次调用时从用户空间复制到内核的操作，并且因为内核返回的发送事件描述符的队列，可以减少每次轮询的操作，使得在O(1)的时间复杂度就能找到发送事件的描述符。</p>
</blockquote>
<h4 id="请你讲一下java-nio">?45.请你讲一下Java NIO</h4>
<blockquote>
<p>NIO弥补了原来同步阻塞IO的不足，它在标准Java代码中提供了高速的、面向块的IO。通过定义包含数据的类，以及通过以块的形式处理这些数据。NIO包含三个核心的组件：Buffer（缓冲区）、Channel（通道）、Selector（多路复用器）。Buffer是一个对象，它包含一些写入或者要读出的数据。在读取数据时，它是直接读到缓冲区中的。在写入数据时，写入到缓冲区中，任何时候访问NIO中的数据，都是通过缓冲区进行操作。Channel是一个通道，可以通过它的读取和写入数据，它就像自来水管一样，网络数据通过Channel读取和写入。通道和流的不同之处在于通道是双向的，流只是在一个方向上移动而且通道可以用于读、写或者同时读写。Selector会不断地轮询注册在其上的Channel，如果某个Channel上面有心的TCP连接接入、读和写事件，这个Channel就处于就绪状态，会被Selector轮询出来，然后通过SelectionKey可以获取就绪Channel的集合，进行后续的IO操作</p>
</blockquote>
<h4 id="简单说下你对jvm的了解">46.简单说下你对JVM的了解</h4>
<blockquote>
<p>JVM是Java语言跨平台的关键，Java在虚拟机层面隐藏了底层技术的复杂性以及机器与操作系统的差异性。运行程序的物理机千差万别，而JVM则在千差万别的物理机上面简历了统一的运行平台，实现了在任意一台JVM上编译的程序，都能在任何其他JVM正常运行。
JVM由三部分组成：类加载子系统、执行引擎和执行时数据区。</p>
<ul>
<li>1）类加载子系统：可以根据指定的全限定名来载入类或接口。</li>
<li>2）执行引擎：负责执行那些包含在被载入类的方法中的指令。</li>
<li>3）当程序运行时，JVM需要内存来存储许多内容，例如：字节码、对象、参数、返回值、局部变量、运算的中间结果等，JVM会把这些东西都存储到运行时数据区中，以便于管理。而运行时数据区又可以分为方法区、堆、虚拟机栈、本地方法栈、程序计数器。</li>
</ul>
</blockquote>
<h4 id="说说你了解的jvm内存模型">47.说说你了解的JVM内存模型</h4>
<blockquote>
<p>JVM由三部分组成：类加载子系统、执行引擎、运行时数据区
1、类加载子系统：可以根据指定的全限定名来载入类或接口。
2、执行引擎：负责执行那些包含在被载入类的方法中的指令。
3、运行时数据区：分为方法区、堆、虚拟机栈、本地方法栈、程序计数器。当程序运行时,JVM需要内存来存储许多内容,例如：字节码、对象、参数、返回值、局部变量、运算的中间结果等,把这些东西都存储到运行时数据区中,以便于管理。</p>
</blockquote>
<h4 id="说说java运行时数据区">48.说说Java运行时数据区</h4>
<blockquote>
<p>Java运行时数据区由五部分组成：程序计数器、Java栈、本地方法栈、Java堆和方法区。程序计数器控制着程序下一步的执行，如循环、分值判断等，Java栈保存着方法运行时的数据结构，方法的调用和结束对应着一个帧栈的入栈和出栈，本地方法栈与Java栈作用类似，其作用对象是本地方法，Java堆中存储new的对象，也是垃圾回收的重要管理区域，方法区中保存着全局变量、静态变量等。方法区和Java堆是线程共享的，而程序计数器和Java栈是线程私有的。</p>
</blockquote>
<h4 id="说说jvm的垃圾回收机制">49.说说JVM的垃圾回收机制</h4>
<blockquote>
<p>JVM的垃圾回收机制是遵循分代收集理论进行设计的，主要分为四种收集方式：</p>
<ul>
<li>1.新生代收集，目标为新生代的垃圾收集。</li>
<li>2.老年代收集：目标为老年代的垃圾收集，目前只有CMS收集器会有这种行为。</li>
<li>3.混合收集：目标为整个新生代及部分老年代的垃圾收集，目前只有G1收集器会有这种行为。</li>
<li>4.整堆收集：目标为整个方法区和堆的垃圾收集。</li>
<li>常见的垃圾回收算法包括：标记清除算法：缺点：内存碎片化，优点：速度快。</li>
<li>标记复制算法：缺点占用内存大，优点：内存连续。</li>
<li>标记整理算法：优点：内存连续，缺点：整理效率低。</li>
</ul>
</blockquote>
<h4 id="说说jvm的垃圾回收算法">50.说说JVM的垃圾回收算法</h4>
<blockquote>
<ul>
<li>1.引用计数法，每次赋值时均要维护引用计数器且计数器本身也有一定的消耗，较难处理循环引用，一般不采用这种方式</li>
<li>2.复制算法，将内存分为两块，每次只使用其中一块，当这块内存用完，就将还活着的对象复制到另外一块上面，效率高且没有碎片，但是需要双倍的空间，年轻代中使用复制算法</li>
<li>3.标记-清除，先标记要清除的对象，然后统一回收这些对象，不需要额外的空间，但是需要两次扫描耗时严重并且会产生内存碎片</li>
<li>4.标记-整理，标记存活对象，然后将标记的存活对象按内存地址依次排序，清除边界外未标记的对象，没有内存碎片，但是需要移动对象。老年代一般用标记-清除和标记-整理的混合实现</li>
</ul>
</blockquote>
<h4 id="说说gc的可达性分析">51.说说GC的可达性分析</h4>
<blockquote>
<p>可达性分析算法用于判断对象是否可以被回收，程序通过GC
Roots中的对象为起点，以类之间的引用关系简历引用链，最终形成一个类似于数据结构中森林的一个结果，不存在与森林中的对象便是需要被回收的对象。这里的GC
Roots主要包括线程栈中引用的变量，本地方法栈中引用的变量，方法区中的静态引用对象，常量池中的常量引用对象和被锁引用的对象。对一个对象真正的宣告回收需要经历两次标记过程，如果一个对象不再引用链上就会对它进行第一次标记，并判断它是否重新了finalize方法，若未重新或finalize方法已经被执行过了则会直接回收对象，否则会创建一个F-queue队列来存储这些对象，并启动一个低优先级的Finalizer线程去执行它们的finalize方法。第二次标记，稍后收集器会对队列中的对象进行可达性分析并标记，若仍然存在标记则表明该对象没有通过finalize方法实现自救则直接回收，否则对象复活。任何对象的finalize方法都只能被调用一次。</p>
</blockquote>
<h4 id="请你说说java的四种引用方式">52.请你说说Java的四种引用方式</h4>
<blockquote>
<p>java中的四种引用方式分别是：1，强引用，以new关键字创建的引用都是强引用，被强引用引用的对象永远都不会被回收。2，软引用：以SoftRererenc引用对象，被弱引用引用的对象只有在内存空间不足时会被垃圾回收。3，弱引用，以WeakReference引用对象，被弱引用引用的对象一定会被回收，它只能存活到下一次垃圾回收。4，虚引用：以PhantomReference引用对象，一个对象被引用引用后不会有任何影响，也无法通过该引用来获取该对象，只是其再被垃圾回收时会收到一个系统通知。</p>
</blockquote>
<h4 id="请你讲下cms垃圾回收器">53.请你讲下CMS垃圾回收器</h4>
<blockquote>
<p>CMS垃圾收集器采用标记清除算法，使用多线程实现，所以它的应用场景一般为服务端系统的老年代。它是一个以达到在垃圾回收期间用户线程低停顿为目标的垃圾收集器。CMS垃圾收集器垃圾回收分为四个阶段：1，初始标记：只对与GCRoots有直接关键的对象进行可达性分析的标记。2，并发标记：标记整个GCRoots引用链中的对象，与用户线程并发执行。3，重新标记：用于更新在并发标记过程中被复活的对象。4，并发清除：清除标记阶段判断的已死亡的对象。该流程与用户线程并发执行。缺点：1，它使用标记清除算***导致内存碎片化，2，会产生在并发清除阶段的浮动垃圾，只有到下一次垃圾回收时才会被清除。</p>
</blockquote>
<h4 id="请你讲下g1垃圾回收器">54.请你讲下G1垃圾回收器</h4>
<blockquote>
<p>G1回收器是一个多线程，可以同时收集新生代和老年代的一个垃圾收集器。G1将整个堆内存区域划分为多个大小相等的region，追踪每个Region可以回收对象的大小和预估时间，并以region为单位进行垃圾收集并获取每个region的收集效率和收集收益，通过一张优先级表对其进行维护。
G1可以设置垃圾回收的预期停顿时间（STW）。
G1的年轻代和老年代空间并不是固定的，当现有年轻代分区占满时，JVM会分配新的空闲Region加入到年轻代空间，老年代也是如此。
G1 GC的回收过程中有内存整理，理论上不会产生内存碎片！
G1垃圾收集器垃圾回收主要包括四个流程：1，初始标记
2，并发标记（类似于CMS） 3，最终标记
4，并发筛选回收：根据优先级表选择分区进行垃圾回收，用户线程不停顿。</p>
</blockquote>
<h4 id="说说类加载机制">55.说说类加载机制</h4>
<blockquote>
<p>类加载的过程中首先判断这个是否被加载过，如果没有被加载过，那么调用类加载器进行加载，判读这个类是否符合规范，如果不符合就抛出异常，加载成功就会生成class对象。
接下来是链接过程，分为三步：准备，验证，准备，解析。
验证：确保文件符合规范，不会危害虚拟机自身的安全，对文件格式，字节码，元数据，符号引用进行验证。
准备:为类变量分配初始空间以及默认初始值，即零值。这里不会为实例变量分配，类变量分配在方法区中，实例变量跟随对象分配在堆中，final修饰的在编译期间就分配了，在准备阶段会显式的初始化。
解析：将常量池内的直接引用转为直接引用的过程。
链接过程完成之后开始初始化的过程：
初始化阶段就是执行类构造器方法的过程。此方法不需要定义，一个类只会被加载一次，虚拟机必须保证在多线程条件下类的构造方法是被加锁的。</p>
</blockquote>
<h4 id="说说jvm的双亲委派模型">56.说说JVM的双亲委派模型</h4>
<blockquote>
<p>双亲委派模型的工作过程是,如果一个类加载器收到了类加载的请求,它首先不会自己去尝试加载这个类,而是把这个请求委派给父类加载器去完成,每一个层次的类加载器都是如此,因此所有的加载请求最终都应该传送到最顶层的启动类加载器中,只有当父加载器反馈自己无法完成这个加载请求时,子加载器才会尝试自己去完成加载</p>
</blockquote>
<h4 id="说说类的实例化过程">57.说说类的实例化过程</h4>
<blockquote>
<p>类实例化的过程。类加载，分配内存，初始化零值，状态设置，构造函数。</p>
</blockquote>
<h4 id="请你说说内存溢出">58.请你说说内存溢出</h4>
<blockquote>
<p>内存溢出：指程序运行过程中申请的内存大于系统能够提供的内存，导致无法申请到足够的内存，于是就发生了内存溢出。引起内存溢出的原因：1.内存加载的数据量过于庞大。如一次从数据库取出的过多的数据。2.代码中存在死循环或者死循环中产生大量的对象实体。3.启动内存值设定过小。解决内存溢出的方案：修改JVM启动参数，直接增加内存。2.检查错误日志，查看“OutOfMemory”错误之前是否存在异常。3.对代码进行debug分析。4.使用内存工具动态查看内存使用情况。常见的内存溢出出现在：1.堆。对象创建过多2.栈溢出3.方法区和运行时常量池；创建大量动态类。</p>
</blockquote>
<h4 id="请你说说内存泄漏">59.请你说说内存泄漏</h4>
<blockquote>
<p>内存泄露：指不再使用的对象仍然被引用，导致垃圾收集器无法回收它们的内存，最终导致OOM。</p>
</blockquote>
<h4 id="请你说说进程间的通信方式">60.请你说说进程间的通信方式</h4>
<blockquote>
<p>1.管道：管道本质是内核中维护的一块内存缓冲区。2.命名管道：因为无名管道只适用于具有亲缘关系的线程，所以就衍生出来命名管道，这样就可以实现了非亲缘关系进程之间的通信。3.信号：一种通知机制。4.消息队列：是一个消息链表，既可以读消息，也可以写消息。5.共享内存：多个线程共享一片内存区域。6.内存映射：就是将磁盘文件数据映射到内存，通过修改内存就能修改磁盘文件。7socket接口，socket接口一般用于不同主机上进程之间的通信</p>
</blockquote>
<h4 id="请你说说线程和协程的区别">61.请你说说线程和协程的区别</h4>
<blockquote>
<p>协程与线程的区别: 1)
一个线程可以多个协程，一个进程也可以单独拥有多个协程。 2)
线程进程都是同步机制，而协程则是异步。 3)
协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态。
4）线程是抢占式，而协程是非抢占式的，所以需要用户自己释放使用权来切换到其他协程，因此同一时间其实只有一个协程拥有运行权，相当于单线程的能力。
5）协程并不是取代线程, 而且抽象于线程之上, 线程是被分割的CPU资源,
协程是组织好的代码流程, 协程需要线程来承载运行, 线程是协程的资源,
但协程不会直接使用线程, 协程直接利用的是执行器(Interceptor),
执行器可以关联任意线程或线程池, 可以使当前线程, UI线程, 或新建新程.。
6）线程是协程的资源。协程通过Interceptor来间接使用线程这个资源。</p>
</blockquote>
<h4 id="请你说说线程和协程的区别-1">62.请你说说线程和协程的区别</h4>
<blockquote>
<ol type="1">
<li><p>线程是操作系统的资源,线程的创建、切换、停止等都非常消耗资源,而创建协程不需要调用操作系统的功能,编程语言自身就能完成,所以协程也被称为用户态线程,协程比线程轻量很多；</p></li>
<li><p>线程在多核环境下是能做到真正意义上的并行,而协程是为并发而产生的；</p></li>
<li><p>一个具有多个线程的程序可以同时运行几个线程,而协同程序却需要彼此协作的运行；</p></li>
<li><p>线程进程都是同步机制,而协程则是异步；</p></li>
<li><p>线程是抢占式,而协程是非抢占式的,所以需要用户自己释放使用权来切换到其他协程,因此同一时间其实只有一个协程拥有运行权,相当于单线程的能力；</p></li>
<li><p>操作系统对于线程开辟数量限制在千的级别,而协程可以达到上万的级别。</p></li>
</ol>
</blockquote>
<h4
id="请你说说死锁定义及发生的条件">63.请你说说死锁定义及发生的条件</h4>
<blockquote>
<p>死锁：两个或者两个以上的线程互相争夺对方的资源而不释放自己的资源，从而导致死锁的产生。
死锁产生的条件： 互斥：一个资源在同一个时刻只能由一个线程执行
请求与保持：一个线程在请求被占用资源时，对已经获得的资源保持不放。
循环等待：发生死锁时所有的线程都会形成一个死循环，一直阻塞。
不可剥夺条件：线程对所获得的资源在未使用完时不能被其他线程剥夺，只能自己释放。
避免死锁的方法就是破坏死锁产生的条件。</p>
</blockquote>
<h4 id="请你说说内存管理">64.请你说说内存管理</h4>
<blockquote>
<p>linux操作系统采用段页式内存管理方式：页式存储管理可以有效的提高内存利用率，段式内存管理能反映程序的逻辑结构并有利于段的共享。将这两种方法结合起来就形成了段页式储存管理方式。段页式储存管理方式就是先建好用户程序分成若干个段，再把每个段分成若干页，并为每个段赋予一个段名</p>
</blockquote>
<h4
id="请你说说虚拟内存和物理内存的区别">65.请你说说虚拟内存和物理内存的区别</h4>
<blockquote>
<ul>
<li>物理内存
以前,还没有虚拟内存概念的时候,程序寻址用的都是物理地址。程序能寻址的范围是有限的,这取决于
CPU 的地址线条数。比如在 32 位平台下,寻址的范围是 2^32 也就是
4G。并且这是固定的,如果没有虚拟内存,且每次开启一个进程都给 4G
物理内存,就可能会出现很多问题： -
因为物理内存是有限的,当有多个进程要执行的时候,都要给 4G
内存,很显然内存不够,这很快就分配完了,于是没有得到分配资源的进程就只能等待。当一个进程执行完了以后,再将等待的进程装入内存。这种频繁的装入内存的操作效率很低
-
由于指令都是直接访问物理内存的,那么任何进程都可以修改其他进程的数据,甚至会修改内核地址空间的数据,这是不安全的</li>
<li>虚拟内存
由于物理内存有很多问题,所以出现了虚拟内存。虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间）,而实际上,它通常是被分隔成多个物理内存碎片,还有部分暂时存储在外部磁盘存储器上,在需要时进行数据交换。</li>
</ul>
</blockquote>
<h4
id="请你说说io多路复用selectpollepoll">66.请你说说IO多路复用（select、poll、epoll）</h4>
<blockquote>
<p>IO多路复用指的是单个进程或者线程能同时处理多个IO请求，select，epoll，poll是LinuxAPI提供的复用方式。本质上由操作系统内核缓冲IO数据，使得单个进程线程能监视多个文件描述符。select是将装有文件描述符的集合从用户空间拷贝到内核空间，底层是数组，poll和select差距不大，但是底层是链表，这就代表没有上限，而select有数量限制。epoll则是回调的形式，底层是红黑树，避免轮询，时间复杂度从O（n）变为O（1）</p>
</blockquote>
<h4 id="epoll原理">67.epoll原理</h4>
<blockquote>
<p>epoll是一种高效地IO多路复用技术。调用epoll_create()会创建一个结构体数据，里面包含一个用于遍历扫描文件描述符状态的红黑树和一个就绪列表。调用epoll_ctr()可以进行增删改要监听的文件描述符及事件。调用epoll_wt()就会让内核检测就绪事件，将就绪事件到该表列表返回。epoll有两种触发机制。水平触发：当文件描述符状态改变时就立即进行IO操作，如果不进行处理将继续通知。边沿触发：是高速工作方式。该机制默认你已经知道了状态描述符改变，再你改变IO状态后描述状态改变后不会通知。该种方式减少了epoll的重复触发次数，提升了效率。必须使用非阻塞接口防止因一个文件描述符阻塞读写其他任务饿死</p>
</blockquote>
<h4 id="请你说说mysql的事务隔离级别">68.请你说说MySQL的事务隔离级别</h4>
<blockquote>
<p>事务隔离级别是为了解决脏读、不可重复读、幻读
脏读：一个事务读取了另一个事务未提交的数据
不可重复读：事务A两次读取的数据不一致，读第二次之前可能有其他事务修改了这个数据并提交了
幻读：事务A两次读取数据库，两次查询结果的条数不同，称为幻读。行数变了即为幻读，数据变了即为不可重复度
事务隔离级别如下： 读未提交：以上三个问题都解决不了
读已提交：只能解决脏读
可重复读：mysql的默认隔离级别，能解决脏读和不可重复读，包含了间隙锁，可以防止幻读
串行化：都可以解决。（为每个读取操作加一个共享锁）</p>
</blockquote>
<h4
id="请你说说innodb和myisam的区别">69.请你说说innodb和myisam的区别</h4>
<blockquote>
<p>1.innodb支持事务，myisam不支持。2.Innodb支持行级锁；myisam支持表级锁。3.Innodb的增删改性能更优；Myisam的查询性能更优。4.Innodb不支持全文索引，myisam默认支持。5.Innodb默认支持外键，而myisam不支持。</p>
</blockquote>
<h4
id="请你说说mysql索引以及它们的好处和坏处">70.请你说说MySQL索引,以及它们的好处和坏处</h4>
<blockquote>
<p>MySQL索引是一种帮助快速查找数据的数据结构，可以把它理解为书的目录，通过索引能够快速找到数据所在位置。场景的索引数据结构有：Hash表（通过hash算法快速定位数据，但不适合范围查询，因为需要每个key都进行一次hash）、二叉树（查找和修改效率都比较高），但是在InnoDB引擎中使用的索引是B+Tree，相较于二叉树，B+Tree这种多叉树，更加矮宽，更适合存储在磁盘中。使用索引增加了数据查找的效率，但是相对的由于索引也需要存储到磁盘，所以增加了存储的压力，并且新增数据时需要同步维护索引。但是合理的使用索引能够极大提高我们的效率！</p>
</blockquote>
<h4 id="请你讲讲b树和b树">71.请你讲讲B树和B+树</h4>
<blockquote>
<p>B树和B+树都是多路平衡查找树。B树中所有节点都存放数据。B+树只有叶子结点存放数据，其他节点存放key。B树中的叶子结点是独立的，B+书中的叶子结点通过链与相邻叶子结点连接。B树查找使用的是二分查找，没有查找到叶子结点就可能结束，而B+树必须从根节点进行查找，查询效率更稳定。</p>
</blockquote>
<h4 id="mysql主从同步是如何实现的">72.MySQL主从同步是如何实现的</h4>
<blockquote>
<p>复制（replication）是MySQL数据库提供的一种高可用高性能的解决方案,一般用来建立大型的应用。总体来说,replication的工作原理分为以下3个步骤：
1. 主服务器（master）把数据更改记录到二进制日志（binlog）中。 2.
从服务器（slave）把主服务器的二进制日志复制到自己的中继日志（relay
log）中。 3.
从服务器重做中继日志中的日志,把更改应用到自己的数据库上,以达到数据的最终一致性</p>
</blockquote>
<h4
id="请你说说数据库索引的底层数据结构">73.请你说说数据库索引的底层数据结构</h4>
<blockquote>
<p>数据库索引用的是B+树，它的叶子节点存储所有的数据，并且叶子节点通过指针进行链接，树的查找效率与其高度有关，树的高度越高，查找效率越低，B+树的高度一般在2-4层，这意味着查找到某一键值只需要2-4次IO操作，而且现在的数据库1s中至少可以做100次IO操作，2-4次的IO操作意味着查询时间只需要0.02-0.04s，所以其查找效率很高。</p>
</blockquote>
<h4
id="请你说说聚簇索引和非聚簇索引">74.请你说说聚簇索引和非聚簇索引</h4>
<blockquote>
<p>它们两个的最大区别就是索引和数据是否存放在一起。
聚簇索引：索引和数据存放在一起，叶子节点保留数据行。
非聚簇索引：索引和数据分开存放，叶子节点存放的是指向数据行的地址。</p>
</blockquote>
<h4
id="请你说说数据库引擎有哪些各自有什么区别">75.请你说说数据库引擎有哪些,各自有什么区别</h4>
<blockquote>
<p>1.InnoDB引擎支持MySQL事务，具有提交，回滚和崩溃恢复功能能够更加安全的保护用户数据；支持行级锁，提高多用户并发和性能；支持外键，维护数据完整性。
2.MyISAM引擎，占用空间较小，支持表级锁，能够限制读写工作的负载的性能，查询效率较高，常用于只读场景。
3.Memory引擎，将所有数据存储在RAM（主存）中，在非关键字查询时，查询效率较高。</p>
</blockquote>
<h4
id="数据库为什么不用红黑树而用b树">76.数据库为什么不用红黑树而用B+树</h4>
<blockquote>
<p>索引的数据结构会被存储在磁盘中，每次查询都需要到磁盘中访问，对于红黑树，树的高度可能会非常的高，会进行很多次的磁盘IO，效率会非常低，B+树的高度一般为2-4，也就是说在最坏的条件下，也最多进行2到4次磁盘IO，这在实际中性能时非常不错的</p>
</blockquote>
<h4 id="请你介绍一下数据库的acid">77.请你介绍一下数据库的ACID</h4>
<blockquote>
<p>原子性</p>
<p>事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。</p>
<p>回滚可以用回滚日志（Undo
Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</p>
<p>一致性</p>
<p>数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。</p>
<p>隔离性</p>
<p>一个事务所做的修改在最终提交以前，对其他事务是不可见的。</p>
<p>持久性</p>
<p>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</p>
<p>系统发生崩溃可以用重做日志（Redo
Log）进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。</p>
<p>事务的 ACID
特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：</p>
<ul>
<li>只有满足一致性，事务的执行结果才是正确的。</li>
<li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</li>
<li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li>
<li>事务满足持久化是为了能应对系统崩溃的情况。</li>
</ul>
</blockquote>
<h4
id="请你说说数据库的索引是什么结构为什么不用哈希表">78.请你说说数据库的索引是什么结构,为什么不用哈希表</h4>
<blockquote>
<p>MySQL中的索引是采用B+树的，哈希表的查询效率很高，但是哈希表最大的问题就是不支持范围和顺序查找，还会产生哈希冲突问题</p>
</blockquote>
<h4 id="请你说说innodb的mvcc">79.请你说说InnoDB的MVCC</h4>
<blockquote>
<p>多版本并发控制，最大的优点是无锁并发，读不加锁，因此读写不冲突，并发性好，它为每个数据都根据事务维护了多个版本，使其在并发事务中解决了读写冲突，同时使用快照读为MVCC提供了非阻塞读功能，所以它是一个用户解决读写冲突的无锁并发控制机制，它通过数据表的三个隐藏字段分别为
db_trx_id(最长操作事务id)，roll_point(undolog指针)，db_row_id(唯一性自增张列，可能没有)，undolog和readview实现。</p>
</blockquote>
<h4
id="请你说说索引怎么实现的b树为什么选这个数据结构">80.请你说说索引怎么实现的B+树,为什么选这个数据结构</h4>
<blockquote>
<p>- 如何实现： -
索引的本质上就是通过预排序+树型结构来加快检索效率，而MySQL中使用InnoDB和MyISAM引擎时都使用了B+树实现索引
- 为什么选取： -
在二叉查找树上查找一个数据时，当出现海量信数据时，查找效率将大大折扣 -
B+树是一种一棵平衡多路查找树，可以有效减少磁盘IO同时B+树增加了叶子节点间的连接，能保证范围查找时找到起点和终点后能快速取出需要的数据</p>
</blockquote>
<h4 id="请你说说乐观锁和悲观锁">81.请你说说乐观锁和悲观锁</h4>
<blockquote>
<p>乐观锁：乐观锁总是假设最好的情况，每次去拿数据的时候默认别人不会修改，所以不会上锁，只有当更新的时候会判断一下在此期间有没有人更新了这个数据。适用于多读，可以使用版本号机制进行控制
悲观锁：悲观锁总是假设最坏的情况，每次去拿数据是都认为别人会修改，所以每次在拿数据时都会上锁，这样别人想拿这个数据时会阻塞直到拿到锁。mysql数据库的共享锁和排他锁都是悲观锁的实现。</p>
</blockquote>
<h4 id="说说你对spring-boot的理解以及它和spring的区别">82.说说你对Spring
Boot的理解,以及它和Spring的区别</h4>
<blockquote>
<p>（1）1、从本质上来说,Spring Boot就是Spring,它帮你完成了一些Spring
Bean配置。 2、Spring
Boot使用“习惯优于配置”的理念让你的项目快速地运行起来 3、但Spring
Boot本身不提供Spring的核心功能,而是作为Spring的脚手架框架,达到快速构建项目的目的</p>
<p>（2）Spring Boot优点, 可以快速构建项目 -
可以对主流开发框架的无配置集成 - 项目可独立运行,无需外部依赖Servlet容器
- 提供运行时的应用监控 - 可以极大地提高开发、部署效率 -
可以与云计算天然集成</p>
<p>（3）核心功能： 1. 自动配置
针对很多Spring应用程序常见的应用功能,Spring Boot能自动提供相关配置。 2.
起步依赖 Spring
Boot通过起步依赖为项目的依赖管理提供帮助。起步依赖其实就是特殊的Maven依赖和Gradle依赖,利用了传递依赖解析,把常用库聚合在一起,组成了几个为特定功能而定制的依赖。
3. 端点监控 Spring Boot 可以对正在运行的项目提供监控。</p>
</blockquote>
<h4 id="说说spring-boot常用的注解">83.说说Spring Boot常用的注解</h4>
<blockquote>
<p><span class="citation"
data-cites="SpringBootApplication:它是SpringBoot的核心注解">@SpringBootApplication:它是SpringBoot的核心注解</span>，用于开启自动配置，准确的说是通过该注解内的@EnablAutoConfiguration注解实现的自动配置。
<span class="citation"
data-cites="EnableAutoConfiguration:自动配置注解">@EnableAutoConfiguration:自动配置注解</span>，在启动Spring应用程序上下文时进行自动配置，自动配置通常是基于项目classpath中引入的类和已定义的bean来实现的。
<span class="citation" data-cites="Import">@Import</span>:<span
class="citation"
data-cites="EnableAutoConfiguration的关键功能是通过">@EnableAutoConfiguration的关键功能是通过</span><span
class="citation"
data-cites="Import注解导入的ImportSelector来完成的">@Import注解导入的ImportSelector来完成的</span>。
<span class="citation"
data-cites="Congiguration">@Congiguration</span>：配置类注解，根据一些特定条件来控制bean的实例化的行为。
<span class="citation"
data-cites="ComponentScan">@ComponentScan</span>：位置在SpringBoot的启动类上，Spring包扫描。</p>
</blockquote>
<h4 id="说说soring-boot的起步依赖">84.说说Soring Boot的起步依赖</h4>
<blockquote>
<p>SpringBoot将日常企业应用研发中的各种常见都抽取出来，做成一个个的starter（启动器），starter中整合了该场景下各种可能用到的依赖，用户只需要在Maven中引入starter依赖，SpringBoot就能自动扫描到要加载的信息并启动相应的默认配置。starter提供了大量的自动配置，让用户摆脱了处理各种依赖和配置的困扰。所有这些starter都遵循这约定俗成的默认配置，并允许用户调整这些配置，即遵循“约定大于配置”的原子</p>
</blockquote>
<h4 id="说说spring-boot的启动流程">85.说说Spring Boot的启动流程</h4>
<blockquote>
<p>调用run方法，run方法执行流程
=》获取监听器参数配置-打印Banner信息-创建并初始化容器-监听器发送通知</p>
</blockquote>
<h4 id="说说spring-boot的自动装配">86.说说Spring Boot的自动装配</h4>
<blockquote>
<p>靠EnableAutoConfigurations注解，首先会从spring.factories中寻找有没有AutoConfiguration类满足Conditional注解的生效条件，有的话，就是实例化该AutoConfiguration类，然后加载到spring容器就实现了spring的自动装配</p>
</blockquote>
<h4 id="简单介绍spring">87.简单介绍Spring</h4>
<blockquote>
<p>Spring是一个轻量级的免费框架，它有两大核心功能，分别是ioc和aop，ioc控制反转是将创建对象的权限交给spring容器来进行管理，可以很好的起到解耦和的作用，aop是一种编程思想，底层使用的是动态代理，可以在程序原有的功能上进行增强，常用的地方有日志记录，权限验证等</p>
</blockquote>
<h4 id="说说你对ioc的理解">88.说说你对IoC的理解</h4>
<blockquote>
<p>IoC：控制反转。控制：对象的创建的控制权限；反转：将对象的控制权限交给spring。之前我们创建对象时用new，现在直接从spring容器中取，维护对象之间的依赖关系，降低对象之间的耦合度。
实现方式为DI,依赖注入，有三种注入方式：构造器、setter、接口注入</p>
</blockquote>
<h4 id="说说你对aop的理解">89.说说你对AOP的理解</h4>
<blockquote>
<p>AOP面向切面编程。是spring两大核心之一，它是一种编程思想，是对OOP的一种补充。它可以对业务逻辑的各个部分进行隔离，降低耦合，提高代码的可重用性。它的底层是通过动态代理实现的。它的应用场景有事务、日志管理等。</p>
</blockquote>
<h4 id="说说bean的生命周期">90.说说Bean的生命周期</h4>
<blockquote>
<p>创建，初始化，调用，销毁；
bean的创建方式有四种，构造器，静态工厂，实例工厂，setter注入的方式。
spring在调用bean的时候因为作用域的不同，不同的bean初始化和创建的时间也不相同。
在作用域为singleton的时候，bean是随着容器一起被创建好并且实例化的，
在作用域为pritotype的时候，bean是随着它被调用的时候才创建和实例化完成。
然后程序就可以使用bean了，当程序完成销毁的时候，bean也被销毁</p>
</blockquote>
<h4 id="说说autowired和resource注解的区别">91.说说@Autowired和<span
class="citation"
data-cites="Resource注解的区别">@Resource注解的区别</span></h4>
<blockquote>
<p><span class="citation"
data-cites="Autowied是Spring提供的注解">@Autowied是Spring提供的注解</span>，<span
class="citation"
data-cites="Resource是JDK提供的注解">@Resource是JDK提供的注解</span>。<span
class="citation"
data-cites="Autowied是只能按类型注入">@Autowied是只能按类型注入</span>，<span
class="citation"
data-cites="Resource默认按名称注入">@Resource默认按名称注入</span>，也支持按类型注入。<span
class="citation"
data-cites="Autowired按类型装配依赖对象">@Autowired按类型装配依赖对象</span>,默认情况下它要求依赖对象必须存在,如果允许null值,可以设置它required属性为false,如果我们想使用按名称装配,可以结合@Qualifier注解一起使用</p>
</blockquote>
<h4 id="说说spring事务管理">92.说说Spring事务管理</h4>
<blockquote>
<p>spring支持编程式事务管理和声明式事务管理两种方式：
①编程式事务管理使用TransactionTemplate。
②声明式事务管理建立在AOP之上的。其本质是通过AOP功能，对方法前后进行拦截，将事务处理的功能编织到拦截的方法中，也就是在目标方法开始之前启动一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。
声明式事务最大的优点就是不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明或通过@Transactional注解的方式，便可以将事务规则应用到业务逻辑中，减少业务代码的污染。唯一不足地方是，最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。</p>
</blockquote>
<h4
id="说说bean的作用域以及默认的作用域">93.说说Bean的作用域,以及默认的作用域</h4>
<blockquote>
<p>作用域分为singleton、prototype、request、session、globalsession。singleton表示在spring容器中仅存在一个实例，以单例的方式存在，prototype：每次调用都会返回一个新的实例，request：每次HTTP请求都会创建一个新的bean，session：同一个HTTP
session共享一个bean，不同的HTTP请求使用不同的session，global
session：同一个全局session共享一个bean。</p>
</blockquote>
<h4
id="说说beanfactory和factorybean的区别">94.说说BeanFactory和FactoryBean的区别</h4>
<blockquote>
<p>BeanFactory是最基础的IOC容器，给Spring
的容器定义一套规范，给IOC容器提供了一套完整的规范；
FactoryBean只是SpringIOC容器创建Bean的一种形式；</p>
</blockquote>
<h4 id="说说你对mvc的理解">95.说说你对MVC的理解</h4>
<blockquote>
<p>Spring mvc
是一个基于java的实现了mvc设计模式的轻量级web框架，在这种模式下软件被分为三层，即model、view、Controller。将软件分层的好处是
可
以将对象之间的耦合度降低，便于代码的维护。model封装了数据和对数据的操作，是实际进行数据处理的地方，view负责进行模型的展示，一般就是我们见
到的用户界面
Controller控制器负责视图和模型之间的交互主要负责两方面的动作，一是把用户的请求分发到相应的模型，二是把模型的改变及时地响应到
视图上。Spring
mvc框架已经成为了mvc模式地最主流实现，前端控制器是DispatcherServlet接口实现类，映射处理器是HandlerMapping接口实现类，视图
解析器是ViewResolver接口实现类，页面控制器是Controller接口实现类</p>
</blockquote>
<blockquote>
<p>MVC是一种设计模式，将软件分为三层，分别是模型层，视图层，控制器层。其中模型层代表的是数据，视图层代表的是界面，控制器层代表的是逻辑处理，是连接视图与模型之前的桥梁。降低耦合，便于代码的维护</p>
</blockquote>
<h4 id="介绍一下spring-mvc的执行流程">96.介绍一下Spring
MVC的执行流程</h4>
<blockquote>
<p>SpringMVC 的执行流程如下。</p>
<ol type="1">
<li>用户点击某个请求路径，发起一个 HTTP request 请求，该请求会被提交到
DispatcherServlet（前端控制器）；<br />
</li>
<li>由 DispatcherServlet 请求一个或多个
HandlerMapping（处理器映射器），并返回一个执行链（HandlerExecutionChain）。<br />
</li>
<li>DispatcherServlet 将执行链返回的 Handler 信息发送给
HandlerAdapter（处理器适配器）；<br />
</li>
<li>HandlerAdapter 根据 Handler 信息找到并执行相应的 Handler（常称为
Controller）；<br />
</li>
<li>Handler 执行完毕后会返回给 HandlerAdapter 一个 ModelAndView
对象（Spring MVC的底层对象，包括 Model 数据模型和 View
视图信息）；<br />
</li>
<li>HandlerAdapter 接收到 ModelAndView 对象后，将其返回给
DispatcherServlet ；<br />
</li>
<li>DispatcherServlet 接收到 ModelAndView 对象后，会请求
ViewResolver（视图解析器）对视图进行解析；<br />
</li>
<li>ViewResolver 根据 View 信息匹配到相应的视图结果，并返回给
DispatcherServlet；<br />
</li>
<li>DispatcherServlet 接收到具体的 View 视图后，进行视图渲染，将 Model
中的模型数据填充到 View 视图中的 request 域，生成最终的
View（视图）；<br />
</li>
<li>视图负责将结果显示到浏览器（客户端）。</li>
</ol>
</blockquote>
<h4 id="在mybatis中和有什么区别">97.在MyBatis中$和#有什么区别</h4>
<blockquote>
<p>$设置参数时,MyBatis会创建普通的SQL语句,然后在执行SQL
语句时将参数拼入SQL
#设置参数时,MyBatis会创建预编译的SQL语句,然后在执行SQL时MyBatis会为预编译SQL中的占位符赋值,预编译的SQL语句执行效率高,并且可以防止注入攻击,效率和安全性都大大优于前者</p>
</blockquote>
<h4 id="介绍一下mybatis的缓存机制">98.介绍一下MyBatis的缓存机制</h4>
<blockquote>
<p>MyBatis的缓存机制，一级缓存也称为本地缓存，它默认启用且不能关闭。一级缓存存在于SqlSession的生命周期中，即它是SqlSession级别的缓存，在同一个SqlSession中查询时，MyBatis会把执行的方法和参数通过算法生成缓存的键值，将键值和查询结果存入一个Map对象中，如果同一个SqlSession中执行的方法和参数完全一致，则会将缓存的对象返回；二级缓存则为SqlSessionFactory,mybaits的全局配置setting有一个参数cacheEnabled,这个参数是二级缓存的全局开关，默认值是true,初始状态为启用状态，映射语句文件中的所有SELECT
语句将会被缓存。 - 映射语句文件中的所有时INSERT 、UPDATE 、DELETE
语句会刷新缓存。 - 缓存会使用Least Recently Used ( LRU
,最近最少使用的）算法来收回</p>
</blockquote>
<h4 id="说说你对redis的了解">99.说说你对Redis的了解</h4>
<blockquote>
<p>Redis是一款基于键值对的NoSQL数据库，Redis中拥有string(字符串)，hash(哈希)、list(列表)、set（集合）等多种数据结构，redis将数据写进内存的性能很快，不仅如此，如遇到系统崩溃，内存中的数据不会丢失；redis访问速度快、支持的数据类型丰富，很适合用来储存热点数据、
而且适用业务广，如可以运用expire命令来做限时业务，设置一个键的生存时间，到时间后redis会自动删除它，，如排行榜可以借住redis的SortedSet进行热点数据的排序，还有分页查询，模糊查询，点赞好友等</p>
</blockquote>
<h4 id="请你说说redis的数据类型">100.请你说说Redis的数据类型</h4>
<blockquote>
<p>Redis拥有五种基本数据类型和四种特殊的数据类型。 五种基本数据类型：
1）String：String是Redis中最基本的数据类型，可以存储任何数据，包括二进制数据、序列化的数据、JSON化的对象甚至是图片。
2）List：List是字符串列表，按照插入的顺序排序，元素可以重复，你可以添加一个元素到哦列表的头部或者尾部，底层是一个链表结构。
3）Set：Set是一个无序不重复的集合。
4）Hash：Hash是String类型的filed和value的集合，适合用于存储对象。
5）Zset：Zset和set一样也是String类型元素的集合，且不允许有重复的元素，但不同的是Zset的每个元素都会关联一个分数，分数可以重复，Redis通过分数来为集合汇总的成员进行从小到大的排序。
四种特殊数据类型 1）bitmap 2）hyperloglog 3）geo 4）stream</p>
</blockquote>
<h4
id="请你说说redis数据类型中的zset它和set有什么区别底层是怎么实现的">101.请你说说Redis数据类型中的zset,它和set有什么区别？底层是怎么实现的？</h4>
<blockquote>
<p>zset是有序的，而set是无序的。
zset底层使用的是压缩列表以及跳跃表，当元素数量小于128个，所有member的长度都小于64字节，是使用压缩列表。不满足这两个条件时使用跳跃表。
set底层是hashtable和inset.</p>
</blockquote>
<h4 id="详细的说说redis的数据类型">102.详细的说说Redis的数据类型</h4>
<blockquote>
<p>redis中常用的五种数据结构：string、list、set、zset、hash。String结构底层是一个简单动态字符串，支持扩容，存储字符串。list存储线性有序且可重复的元素，底层数据结构可以是双向链表/压缩列表。set存储不可重复的元素，一般用于求交集、差集等，底层数据结构可以是hash和整数数组，zset存储的是有序不可重复的元素，zset为每个元素添加了一个score属性作为排序依据，底层数据结构可以是ziplist和跳表，hash类型存储的是键值对，底层数据结构是ziplist和hash。redis会在性能以及节省内存间考虑，选择最适合当前状态的底层数据结构实现</p>
</blockquote>
<blockquote>
<p>list（有序可重）的底层数据结构是双向链表/压缩列表</p>
<p>set（不可重）=hash+整数数组，</p>
<p>zset（有序不重）=ziplist+跳表</p>
<p>hash（存键值对）=ziplist+hash</p>
</blockquote>
<h4 id="说说redis的单线程架构">103.说说Redis的单线程架构</h4>
<blockquote>
<p>redis采用的是单线程+IO多路复用技术。这里单线程指的是redis中读写操作和网络IO使用的是是有一个线程来完成，但是其他操作是有其他线程完成，例如持久化操作。单线程既可以简化数据结构和算法的实现，同时也消除了线程切换和锁竞争所带来的消耗。redis中采用的IO多路复用技术实现了单线程下同时处理多个IO请求。redis为什么这么快：1.单线程进行读写操作，避免线程切换和锁竞争带来的消耗。2：redis操作是在内存中进行的。3.最重要的就是：采用了IO多路复用技术，实现了在网络IO中能够处理大量并发请求，实现高吞吐率。</p>
</blockquote>
<h4 id="说说redis的持久化策略">104.说说Redis的持久化策略</h4>
<blockquote>
<p>1.RDB: redis database
在指定的时间间隔内，将内存中的数据集的快照写入磁盘，文件名dump.rdb
适合大规模的数据恢复，对数据库的完整性和一致性要求不是很高
一定时间间隔备份一次，如果数据库意外down掉，就会失去最后一次快照的所有修改
2.AOF: append only file
以日志的形式记录每个写操作，只允许追加文件，不允许改写文件，redis启动时会读取这个文件，并从头到尾执行一遍，以此来恢复数据，文件名appendonly.aof
在最恶劣的环境下，也丢失不会超过2秒的数据，完整性较高，但是会对磁盘持续的进行IO，代价太大。企业级最少需要5G才能支持
如果.aof文件大小超过原来的一倍，会进行重写压缩，保留最小的指令集合
3.优先级 aof&gt;rdb</p>
</blockquote>
<h4 id="说说redis的主从同步机制">105.说说Redis的主从同步机制</h4>
<blockquote>
<p>主从同步分为全量同步和增量同步，从机第一次连接主机时不会携带主机id和数据偏移量，主机会对从机的主机id进行校验，如果不是则说明是第一次连接需要进行全量同步，原理就是将当前数据写到RDB文件发送给从机，从机接收到文件之后将数据读取到从机的内存中，增量同步是第二次和之后连接才会发生，当从机第一次同步完成之后，主机在这期间数据发生变化，会将命令存储在缓冲区，当校验到从机的id正确时会获取从机的偏移量，主机从偏移量记录的命令开始将从机没同步的数据的操作命令发送给从机执行，执行完成后即完成了数据同步</p>
</blockquote>
<h4 id="说说redis的缓存淘汰策略">106.说说Redis的缓存淘汰策略</h4>
<blockquote>
<p>惰性删除：
当你访问一个key的时候，redis检查它的过期时间，如果过期就会删除。
定期删除：redis会将设置了过期事件的key全都放入一个字典中，然后进行扫描，过期了的key就会被删除。但是扫描不是全局扫描，而是一种简单的贪心算法，从字典中随机选择20个key，将过期的key删除，当过期的key超过一定的比例时，将会再次随机选择，知道随机选择的key小于一定比例。
当写入数据超过最大内存限制时，redis也有8种淘汰方案： 1. 直接报错 2.
删除拥有过期时间的key中快要过期的 3. 在所有key中随机删除 4.
在具有过期时间的key中随机删除 5. lru 从所有key中删除使用时间离现在最久的
6. lru 从拥有过期时间的key中删除使用时间离现在最久的 7. lfu
从所有key中删除使用次数最少的 8. lfu
从拥有过期时间的key中删除使用次数最少的</p>
</blockquote>
<h4
id="说说缓存穿透击穿雪崩的区别">107.说说缓存穿透、击穿、雪崩的区别</h4>
<blockquote>
<p>缓存穿透：客户端访问不存在的数据，使得请求直达存储层，导致负载过大，直至宕机。原因可能是业务层误删了缓存和库中的数据，或是有人恶意访问不存在的数据。解决方式：1.存储层未命中后，返回空值存入缓存层，客户端再次访问时，缓存层直接返回空值。2.将数据存入布隆过滤器，访问缓存之前经过滤器拦截，若请求的数据不存在则直接返回空值。
缓存击穿：一份热点数据，它的访问量非常大，在它缓存失效的瞬间，大量请求直达存储层，导致服务崩溃。解决方案：1.永不过期：对热点数据不设置过期时间。2.加互斥锁，当一个线程访问该数据时，另一个线程只能等待，这个线程访问之后，缓存中的数据将被重建，届时其他线程就可以从缓存中取值。
缓存雪崩：大量数据同时过期、或是redis节点故障导致服务不可用，缓存层无法提供服务，所有的请求直达存储层，造成数据库宕机。解决方案：1.避免数据同时过期，设置随机过期时间。2.启用降级和熔断措施。3.设置热点数据永不过期。4.采用redis集群，一个宕机，另外的还能用</p>
</blockquote>
<h4
id="redis如何与数据库保持双写一致性">108.Redis如何与数据库保持双写一致性</h4>
<blockquote>
<p>共有四种同步策略：1.先更新数据库再更新缓存。缺点：多线程并发下会存在数据库中数据和缓存不一致的的现象。可能出现2.先更新缓存在更新数据库，优点就是每次数据变化都可以及时的更新缓存，但是消耗很大，影响服务器性能。3.先删除缓存在更新数据库。缺点：也会导致缓存和数据库数据不一致。4.先更新数据库再删除缓存。缺点仍然可能存在缓存和数据库中数据不一致的情况，但是，我们可以使用重试机制进行操作。，所以说这是效果最好的解决方案。</p>
</blockquote>
<h4 id="如何实现redis高可用">109.如何实现Redis高可用</h4>
<blockquote>
<p>主从复制：写一定是在主服务器上，然后主服务器同步给从服务器。缺点：当主服务器挂掉的时候，不能自动切换到从服务器上。主从服务器存储数据一样，内存可用性差。优点：在一定程度上分担主服务器读的压力。哨兵模式：构建多个哨兵节点监视主从服务器，当主服务器挂掉的时候，自动将对应的从服务器切换成主服务器。优点：实现自动切换，可用性高。缺点：主从服务器存储数据一致，内存可用性差。还要额外维护一套哨兵系统，较为麻烦。集群模式：采用无中心节点的方式实现。多个主服务器相连，一个主服务器可以有多个从服务器，不同的主服务器存储不同的数据。优点：可用性更高，内存可用性高。</p>
</blockquote>
<h4
id="如何利用redis实现一个分布式锁">？110.如何利用Redis实现一个分布式锁</h4>
<blockquote>
<p>最简单redis分布式锁的实现方式：加锁：setnx（key,1），解锁：del(key),问题：如果客户忘记解锁，将会出现死锁。第二种分布式锁的实现方式：setnx(key,1)+expire(key,30),解锁：del(key).问题：，由于setnx和expire的非原子性，当第二步挂掉，仍然会出现死锁。第三种方式：加锁：将setnx和expire变成原子性操作，set(key,1,30,NX),解锁：del（key）。同时考虑到线程A还在执行，但是锁已经到期，当线程A执行结束时去释放锁时，可能就会释放别的线程锁，所以在解锁时要先判断一下value值，看是不是该锁，如果是，再进行删除</p>
</blockquote>
<h4 id="设计模式了解么">111.设计模式了解么</h4>
<blockquote>
<p>常用的设计模式有单例模式、工厂模式、代理模式、适配器模式、装饰器模式、模板方法模式等等。像sping中的定义的bean默认为单例模式，spring中的BeanFactory用来创建对象的实例，他是工厂模式的体现。AOP面向切面编程时代理模式的体现，它的底层就是基于动态代理实现的。适配器模式在springMVC中有体现，它的处理器适配器会根据处理器规则适配相应的处理器执行，模板方法模式用来解决代码重复的问题等</p>
</blockquote>
<h4
id="请你讲讲单例模式请你手写一下单例模式">112.请你讲讲单例模式、请你手写一下单例模式</h4>
<blockquote>
<p>单例模式是一个类只能创建一个对象，单例模式又分为饿汉式和懒汉式，饿汉式就是在类加载的的时候不管后边会不会用到都创建一个对象并且做初始化，浪费资源。懒汉式是在类加载的的时候创建对象，但不进行初始化，只有在用的时候，先判断对象是否为空，如果为空，对对象进行初始化，然后返回初始化后的值。为了解决线程安全问题，又分为懒汉式线程安全、懒汉式双重检验锁、静态内部类等</p>
<p>public class Singleton{</p>
<p>​ private static Singleton instance;</p>
<p>​ private Singleton(){}</p>
<p>​ private static synchronized Singleton getInstance(){</p>
<p>​ if(instance == null){</p>
<p>​ instance = new Singleton();</p>
<p>​ }</p>
<p>​ return instance;</p>
<p>​ }</p>
<p>}</p>
</blockquote>
<h4
id="请你讲讲工厂模式手写实现工厂模式">113.请你讲讲工厂模式,手写实现工厂模式</h4>
<blockquote>
<p>工厂模式其用意是定义一个创建产品的接口将具体创建推迟到子类中去。工厂模式可以分为简单工厂、工厂方法、抽象工厂。简单工厂就是定义一个工厂类根据传入的参数返回不同的实例，被创建的实例具有共同的父类或接口。工厂方法工厂方法是定义一个工厂接口，但创建过程让子类去实现，去决定哪一个产品被实例化。抽象工厂模式是对工厂方法的进一步深化，在工厂类中可以创建一组对象。实现方式是提供一个创建一系列相关或相互依赖对象的接口而无需指定具体的类</p>
</blockquote>
<h4 id="说说垃圾收集器">114.说说垃圾收集器</h4>
<blockquote>
<p>Serial（新生代）、Serial
Old（老年代）：适用于单核小CPU，单核工作，回收时会暂停其他工作stop the
word。</p>
<p>PawNew（新生代）、CMS（老年代）：适用于多核CPU，最求短暂停时间，多核工作，使用标记清除算法，最短的暂停时间。</p>
<p>Parallel Scavenge（新生代-标记复制算法）、Parallel
Old（老年代-标记整理算法）：1.7,1.8默认的组合，适用于多核CPU，追求最大吞吐量</p>
<p>G1
jdk1.9默认，适用于大内存多核CPU服务器，它不按整个新生代或老年代去回收，而是开辟了面向局部收集，实现了较小的收集暂停时间和高吞吐量。</p>
</blockquote>
<h4
id="java中的error和exception有什么区别">Java中的error和exception有什么区别</h4>
<blockquote>
<p>Error（错误）:程序无法处理，通常指程序中出现的严重问题。</p>
<p>例如java.lang.VirtualMachineError（Java虚拟机运行错误）：当
Java虚拟机崩溃或用尽了它继续操作所需的资源时，抛出该错误
例如java.lang.StackOverflowError（栈溢出错误）：当应用程序递归太深而发生堆栈溢出时，抛出该错误。
例如java.lang.OutOfMemoryError（内存溢出）：内存溢出或没有可用的内存提供给垃圾回收器时，产生这个错误。
Error（错误）是不可查的，而且也常常在应用程序的控制和处理能力之外，因此当Error（错误）出现时，程序会立即奔溃，Java虚拟机立即停止运行，
Exception（异常）:是指程序本身可以处理的异常（可以向上抛出或者捕获处理）。</p>
<p>Java处理异常的默认方式是中断处理。</p>
<p>以java.lang.NullPointerException为例，当程序出现空指针异常时，会创建一个空指针异常对象，并向外抛出，并被虚拟机捕获，从而导致程序中断执行。</p>
</blockquote>
<h4 id="进程间通信的方式有几种">进程间通信的方式有几种</h4>
<blockquote>
<h2 id="一进程间的通信方式"><strong>一、进程间的通信方式</strong></h2>
<h3 id="管道-pipe">管道( pipe )：</h3>
<p>管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</p>
<h3 id="有名管道-namedpipe">有名管道 (namedpipe) ：</h3>
<p>有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</p>
<h3 id="信号量semophore">信号量(semophore ) ：</h3>
<p>信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p>
<h3 id="消息队列-messagequeue">消息队列( messagequeue ) ：</h3>
<p>消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p>
<h3 id="信号-sinal">信号 (sinal ) ：</h3>
<p>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p>
<h3 id="共享内存shared-memory">共享内存(shared memory ) ：</h3>
<p>共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的
IPC
方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。</p>
<h3 id="套接字socket">套接字(socket ) ：</h3>
<p>套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同设备及其间的进程通信。</p>
</blockquote>
<h4 id="dns域名解析过程">DNS域名解析过程</h4>
<blockquote>
<ol type="1">
<li>浏览器先检查自身缓存中有没有被解析过的这个域名对应的ip地址，如果有，解析结束。同时域名被缓存的时间也可通过TTL属性来设置。</li>
<li>如果浏览器缓存中没有（专业点叫还没命中），浏览器会检查操作系统缓存中有没有对应的已解析过的结果。而操作系统也有一个域名解析的过程。在windows中可通过c盘里一个叫hosts的文件来设置，如果你在这里指定了一个域名对应的ip地址，那浏览器会首先使用这个ip地址。</li>
<li>如果至此还没有命中域名，才会真正的请求本地域名服务器（LDNS）来解析这个域名，这台服务器一般在你的城市的某个角落，距离你不会很远，并且这台服务器的性能都很好，一般都会缓存域名解析结果，大约80%的域名解析到这里就完成了。</li>
<li>如果LDNS仍然没有命中，就直接跳到Root Server 域名服务器请求解析</li>
<li>根域名服务器返回给LDNS一个所查询域的主域名服务器（gTLD
Server，国际顶尖域名服务器，如.com .cn .org等）地址</li>
<li>此时LDNS再发送请求给上一步返回的gTLD</li>
<li>接受请求的gTLD查找并返回这个域名对应的Name Server的地址，这个Name
Server就是网站注册的域名服务器</li>
<li>Name Server根据映射关系表找到目标ip，返回给LDNS</li>
<li>LDNS缓存这个域名和对应的ip</li>
<li>LDNS把解析的结果返回给用户，用户根据TTL值缓存到本地系统缓存中，域名解析过程至此结束</li>
</ol>
</blockquote>
<h4
id="浏览器输入一个网址后发生了什么">浏览器输入一个网址后发生了什么</h4>
<blockquote>
<p>1.在客户端浏览器中输入URL.
2.发送到DNS(域名服务器)获得域名对应的web服务器的lP地址。
3.客户端浏览器与web服务器建立tcp连接.
4.客户端浏览器向对应IP地址的WEB服务器发送相应的http或https请求。
5.WEB服务器响应请求，返回指定的URL数据或错误信息。如果设定重定向，则重定向到新的URL地址。
6.客户端浏览器下载数据，解析HTML源文件，解析的过程中实现对页面的排版，解析完成后，在浏览器中显示基础界面。
7.分析页面中的超链接，显示在当前页面，重复以上过程直至没有超链接需要发送，完成页面的全部显示。</p>
</blockquote>
<h4 id="jvm内存划分">Jvm内存划分</h4>
<blockquote>
<figure>
<img
src="https://wang-nine.cn/images/%E9%9D%A2%E7%BB%8F01-jvm%E5%86%85%E5%AD%98%E5%88%92%E5%88%86.png"
alt="面经01-jvm内存划分" />
<figcaption aria-hidden="true">面经01-jvm内存划分</figcaption>
</figure>
<p>第一，是程序计数器（Program Counter
Register)，在JVM规范中，每个线程都有自己的程序计数器。这是一块比较小的内存空间，存储当前线程正在执行的Java方法的JVM指令地址，即字节码的行号。如果正在执行Native方法，则这个计数器为空。<strong>该内存区域是唯一一个在Java虚拟机规范中没有规定任何OOM情况的内存区域。</strong></p>
<p>第二，Java虚拟机栈(Java Virtal Machine
Stack)，同样也是属于线程私有区域，每个线程在创建的时候都会创建一个虚拟机栈，生命周期与线程一致，线程退出时，线程的虚拟机栈也回收。虚拟机栈内部保持一个个的栈帧，每次方法调用都会进行压栈，JVM对栈帧的操作只有出栈和压栈两种，方法调用结束时会进行出栈操作。</p>
<p>该区域存储着局部变量表，编译时期可知的各种基本类型数据、对象引用、方法出口等信息。</p>
<p>第三，本地方法栈（Native Method
Stack）与虚拟机栈类似，本地方法栈是在调用本地方法时使用的栈，每个线程都有一个本地方法栈。</p>
<p>第四，堆（Heap）,几乎所有创建的Java对象实例，都是被直接分配到堆上的。堆被所有的线程所共享，在堆上的区域，会被垃圾回收器做进一步划分，例如新生代、老年代的划分。Java虚拟机在启动的时候，可以使用“Xmx”之类的参数指定堆区域的大小。</p>
<p>第五，方法区（Method
Area)。方法区与堆一样，也是所有的线程所共享，存储被虚拟机加载的元（Meta）数据，包括类信息、常量、静态变量、即时编译器编译后的代码等数据。这里需要注意的是运行时常量池也在方法区中。</p>
<p>根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。由于早期HotSpot
JVM的实现，将CG分代收集拓展到了方法区，因此很多人会将方法区称为永久代。Oracle
JDK8中已永久代移除永久代，同时增加了元数据区（Metaspace）。</p>
<p>第六，运行时常量池（Run-Time Constant
Pool)，这是方法区的一部分，受到方法区内存的限制，当常量池无法再申请到内存时，会抛出OutOfMemoryError异常。</p>
<p>第七，直接内存（Direct
Memory），直接内存并不属于Java规范规定的属于Java虚拟机运行时数据区的一部分。Java的NIO可以使用Native方法直接在java堆外分配内存，使用DirectByteBuffer对象作为这个堆外内存的引用。</p>
</blockquote>
<h4 id="可重入锁">可重入锁</h4>
<blockquote>
<p>什么是“可重入"，可重入就是说某个线程已经获得某个锁，可以再次获取锁而不会出现死锁。例如</p>
<p>使用ReentrantLock的注意点
ReentrantLock和synchronized不一样，需要手动释放锁，所以使用ReentrantLock的时候一定要手动释放锁，并且加锁次数和释放次数要—样</p>
</blockquote>
<h4 id="java锁升级">Java锁升级</h4>
<blockquote>
<ul>
<li>Java中的锁有几种状态：无锁 → 偏向锁 → 轻量级锁 → 重量级锁</li>
</ul>
<h4 id="无锁状态">无锁状态</h4>
<blockquote>
<p>程序不会有锁的竞争。那么这种情况我们不需要加锁，所以这种情况下对象锁状态为无锁。</p>
</blockquote>
<h4 id="偏向锁">偏向锁</h4>
<blockquote>
<p>偏向锁，顾名思义，它会偏向于第一个访问锁的线程</p>
</blockquote>
<p>如果在运行过程中，同步锁只有一个线程访问，不存在多线程争用的情况，则线程是不需要触发同步的，这种情况下，就会给线程加一个偏向锁。线程第二次到达同步代码块时，会判断此时持有锁的线程是否就是自己，如果是则正常往下执行。由于之前没有释放锁，这里也就不需要重新加锁。如果自始至终使用锁的线程只有一个，很明显偏向锁几乎没有额外开销，性能极高。
如果在运行过程中，遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会消除它身上的偏向锁，将锁恢复到标准的轻量级锁。偏向锁通过消除资源无竞争情况下的同步原语，进一步提高了程序的运行性能。一旦有第二个线程加入锁竞争，偏向锁就升级为轻量级锁（自旋锁）。升级为轻量级锁的时候需要撤销偏向锁，撤销偏向锁的时候会导致STW(stop
the word)操作；</p>
<h4 id="轻量级锁自旋锁">轻量级锁（自旋锁）</h4>
<blockquote>
<p>自旋锁：自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。</p>
</blockquote>
<p>在轻量级锁状态下继续锁竞争，如果成功就成功获取轻量级锁。否则进入锁膨胀阶段，没有抢到锁的线程将自旋，即不停地循环判断锁是否能够被成功获取。长时间的自旋操作是非常消耗资源的，一个线程持有锁，其他线程就只能在原地空耗CPU，执行不了任何有效的任务，这种现象叫做忙等（busy-waiting）。如果锁竞争情况严重，某个达到最大自旋次数的线程，会将轻量级锁升级为重量级锁。
自旋锁:竞争锁失败的线程，并不会真实的在操作系统层面挂起等待，而是JVM会让线程做几个空循环(基于预测在不久的将来就能获得)，在经过若干次循环后，如果可以获得锁，那么进入临界区，如果还不能获得锁，才会真实的将线程在操作系统层面进行挂起。这样的好处就是快，坏处就是消耗cpu资源。</p>
<h4 id="重量级锁">重量级锁</h4>
<blockquote>
<p>当后续线程尝试获取锁时，发现被占用的锁是重量级锁，则直接将自己挂起，等待将来被唤醒。在JDK1.6之前，synchronized直接加重量级锁，很明显现在得到了很好的优化。</p>
</blockquote>
<p>重量级锁的特点：其他线程试图获取锁时，都会被阻塞，只有持有锁的线程释放锁之后才会唤醒这些线程。</p>
<table style="width:100%;">
<colgroup>
<col style="width: 5%" />
<col style="width: 39%" />
<col style="width: 31%" />
<col style="width: 23%" />
</colgroup>
<thead>
<tr class="header">
<th>锁</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>偏向锁</td>
<td>加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。</td>
<td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗。</td>
<td>适用于只有一个线程访问同步块场景。</td>
</tr>
<tr class="even">
<td>轻量级锁</td>
<td>竞争的线程不会阻塞，提高了程序的响应速度。</td>
<td>如果始终得不到锁竞争的线程使用自旋会消耗CPU。</td>
<td>追求响应时间。同步块执行速度非常快。</td>
</tr>
<tr class="odd">
<td>重量级锁</td>
<td>线程竞争不使用自旋，不会消耗CPU。</td>
<td>线程阻塞，响应时间缓慢。</td>
<td>追求吞吐量。同步块执行速度较长。</td>
</tr>
</tbody>
</table>
<h4 id="锁升级场景">锁升级场景</h4>
<ul>
<li>场景1： 经常只有某一个线程来加锁。</li>
</ul>
<p>加锁过程：也许获取锁的经常为同一个线程，这种情况下为了避免加锁造成的性能开销，加偏向锁。
偏向锁的执行流程如下： 1、线程首先检查该对象头的线程ID是否为当前线程；
2、A：如果对象头的线程ID和当前线程ID一致，则直接执行代码；B：如果不是当前线程ID则使用CAS方式替换对象头中的线程ID，如果使用CAS替换不成功则说明有线程正在执行，存在锁的竞争，这时需要撤销偏向锁，升级为轻量级锁。
3、如果CAS替换成功，则把对象头的线程ID改为自己的线程ID，然后执行代码。
4、执行代码完成之后释放锁，把对象头的线程ID修改为空。</p>
<ul>
<li>场景2： 有线程来参与锁的竞争，但是获取锁的冲突时间很短。</li>
</ul>
<p>当开始有锁的竞争了，那么偏向锁就会升级到轻量级锁；
线程获取锁出现冲突时，线程必须做出决定是继续在这里等，还是先去做其他事情，等会再来看看，而轻量级锁的采用了继续在这里等的方式。当发现有锁竞争，线程首先会使用自旋的方式循环在这里获取锁，因为使用自旋的方式非常消耗CPU。当一定时间内通过自旋的方式无法获取到锁的话，那么锁就开始升级为重量级锁了。</p>
<ul>
<li>场景3： 有大量的线程参与锁的竞争，冲突性很高。</li>
</ul>
<p>当获取锁冲突多，时间越长的时候，线程肯定无法继续在这里死等了，所以只好先挂起，然后等前面获取锁的线程释放了锁之后，再开启下一轮的锁竞争，而这种形式就是我们的重量级锁。</p>
</blockquote>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEAVIM设置</title>
    <url>/posts/20001.html</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;</span>配置篇<span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">set showmatch</span><br><span class="line">set hlsearch</span><br><span class="line">set incsearch</span><br><span class="line">set ignorecase</span><br><span class="line">set smartcase</span><br><span class="line">set history=<span class="number">3000000</span></span><br><span class="line">set commentary</span><br><span class="line">:set vb</span><br><span class="line">:set keep-english-in-normal</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;</span>基础篇<span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"><span class="string">&quot;debug神器</span></span><br><span class="line"><span class="string">nmap &lt;C-j&gt; :action StepOver&lt;CR&gt;</span></span><br><span class="line"><span class="string">nmap &lt;C-k&gt; :action Resume&lt;CR&gt;</span></span><br><span class="line"><span class="string">nmap &lt;C-h&gt; :action StepOut&lt;CR&gt;</span></span><br><span class="line"><span class="string">nmap &lt;C-l&gt; :action ForceStepInto&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>移动专精</span><br><span class="line">vmap &lt;C-j&gt; &lt;C-e&gt;</span><br><span class="line">vmap &lt;C-k&gt; &lt;C-y&gt;</span><br><span class="line">vmap &lt;C-h&gt; 10zh</span><br><span class="line">vmap &lt;C-l&gt; 10zl</span><br><span class="line"><span class="string">&quot;移动专精</span></span><br><span class="line"><span class="string">&quot;</span>imap &lt;C-j&gt; &lt;Esc&gt;ja</span><br><span class="line"><span class="string">&quot;imap &lt;C-k&gt; &lt;Esc&gt;ka</span></span><br><span class="line"><span class="string">&quot;</span>imap &lt;C-h&gt; &lt;Esc&gt;10zhi</span><br><span class="line"><span class="string">&quot;imap &lt;C-l&gt; &lt;Esc&gt;l10zla</span></span><br><span class="line"><span class="string">imap &lt;C-j&gt; &lt;Down&gt;</span></span><br><span class="line"><span class="string">imap &lt;C-k&gt; &lt;Up&gt;</span></span><br><span class="line"><span class="string">imap &lt;C-h&gt; &lt;Left&gt;</span></span><br><span class="line"><span class="string">imap &lt;C-l&gt; &lt;Right&gt;</span></span><br><span class="line"><span class="string">imap &lt;C-i&gt; &lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>左右视野</span><br><span class="line">nnoremap zH 50zh</span><br><span class="line">nnoremap zL 50zl</span><br><span class="line"><span class="string">&quot;^$符号太难按了</span></span><br><span class="line"><span class="string">map gh ^</span></span><br><span class="line"><span class="string">map gl $</span></span><br><span class="line"><span class="string">&quot;</span>代码提示</span><br><span class="line"><span class="string">&quot;imap &lt;C-n&gt; &lt;ESC&gt;:action HippieCompletion&lt;CR&gt;a</span></span><br><span class="line"><span class="string">&quot;</span>imap &lt;C-p&gt; &lt;ESC&gt;:action HippieBackwardCompletion&lt;CR&gt;a</span><br><span class="line"><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;</span>重构篇<span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"><span class="string">&quot;元素名称重构</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;re :action RenameElement&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>移动重构</span><br><span class="line">noremap &lt;Space&gt;mv :action Move&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;成员变量转换为静态变量重构(配合移动重构有奇效)</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;ms :action MakeStatic&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>静态变量转换为成员变量重构</span><br><span class="line">noremap &lt;Space&gt;ci :action ConvertToInstanceMethod&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;内联重构(合并无效变量无效方法)</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;il :action Inline&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>抽取方法重构</span><br><span class="line">noremap &lt;Space&gt;em :action ExtractMethod&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;抽取接口重构</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;ei :action ExtractInterface&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>字段的访问限制</span><br><span class="line">noremap &lt;Space&gt;ef :action EncapsulateFields&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;切换方法为方法对象</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;rmo :action ReplaceMethodWithMethodObject&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>引入临时变量</span><br><span class="line">noremap &lt;Space&gt;iv :action IntroduceVariable&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;引入常量</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;ic :action IntroduceConstant&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>引入方法参数</span><br><span class="line">noremap &lt;Space&gt;ip :action IntroduceParameter&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;引入字段</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;if :action IntroduceField&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>引入参数对象(指定参数)</span><br><span class="line">noremap &lt;Space&gt;po :action IntroduceParameterObject&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;方法下放到子类</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;pd :action MemberPushDown&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>方法上移到父类</span><br><span class="line">noremap &lt;Space&gt;pu :action MembersPullUp&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;文件名称重构</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;RF :action RenameFile&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>修改方法签名</span><br><span class="line">noremap &lt;Space&gt;cs  :action ChangeSignature&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;抽取类</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;ec :action ExtractClass&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>匿名类到内部类</span><br><span class="line">noremap &lt;Space&gt;ai :action AnonymousToInner&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;</span>跳转篇<span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"><span class="string">&quot;搜索任何位置</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;te :action SearchEverywhere&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>特殊变量跳转</span><br><span class="line">nnoremap &lt;Space&gt;ts mm`m:action GotoSymbol&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;url地址跳转</span></span><br><span class="line"><span class="string">noremap  &lt;Space&gt;tu  mm`m:action Toolkit.GotoService&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>动作跳转</span><br><span class="line">nnoremap &lt;Space&gt;ta mm`m:action GotoAction&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;文件跳转</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;tf mm`m:action GotoFile&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>测试类跳转</span><br><span class="line">noremap &lt;Space&gt;tt mm`m:action GotoTest&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;java类跳转</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;tc mm`m:action GotoClass&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>文本跳转</span><br><span class="line">noremap &lt;Space&gt;tp mm`m:action FindInPath&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;跳转下个报错处</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;ne mm`m:action GotoNextError&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>跳转上个报错处</span><br><span class="line">noremap &lt;Space&gt;pe mm`m:action GotoPreviousError&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;从子类方法跳到父类的方法</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;gs mm`m:action GotoSuperMethod&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>跳到方法实现</span><br><span class="line">noremap &lt;Space&gt;gi mm`m:action GotoImplementation&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;跳转到下个改动处</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;g, mm`m:action JumpToLastChange&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>跳转到上个改动处</span><br><span class="line">noremap &lt;Space&gt;g; mm`m:action JumpToNextChange&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;最近查看文件间相互跳转</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;rf mm`m:action RecentFiles&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>最近改动文件间相互跳转</span><br><span class="line">noremap &lt;Space&gt;rF mm`m:action RecentChangedFiles&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;项目之间的跳转(上一个)</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;nw :action NextProjectWindow&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>项目之间的跳转(下一个)</span><br><span class="line">noremap &lt;Space&gt;pw :action PreviousProjectWindow&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;跳转 需要安装AceJump插件</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;tj mm`m:action AceWordAction&lt;CR&gt;</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;jp mm`m:action AceDeclarationAction&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;SQL篇&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">&quot;</span>sql提交</span><br><span class="line">noremap &lt;Space&gt;sc :action Console.Transaction.Commit&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;sql回滚</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;sr :action Console.Transaction.Rollback&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>sql执行</span><br><span class="line">noremap &lt;Space&gt;se :action Console.Jdbc.Execute&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;sql执行计划</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;ep :action Console.Jdbc.ExplainPlan&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>sql-raw执行计划</span><br><span class="line">noremap &lt;Space&gt;EP :action Console.Jdbc.ExplainPlan.Raw&lt;CR&gt;</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;打开数据库日志窗口,前提安装了MyBatis Log Plugin插件</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;sl :action TailMyBatisLog0&lt;CR&gt;</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;SL :action ActivateMyBatisLogToolWindow&lt;CR&gt;</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;AL :action TailMyBatisLog0&lt;CR&gt;:action ActivateMyBatisLogToolWindow&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;运行篇&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">&quot;</span>设置运行配置</span><br><span class="line">nnoremap &lt;Space&gt;rc :action RunConfiguration&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;运行上次运行的类</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;rr :action Run&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>运行当前(now)类</span><br><span class="line">noremap &lt;Space&gt;rn :action RunClass&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;debug上次运行的类</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;dd :action Debug&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>debug当前(now)类</span><br><span class="line">noremap &lt;Space&gt;dn :action DebugClass&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;统计单元测试覆盖率运行上个类</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;cc :action Coverage&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>统计单元测试覆盖率运行当前(now)类</span><br><span class="line">noremap &lt;Space&gt;cn :action RunCoverage&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;项目停止运行</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;sp   :action Stop&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;Debug篇&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">&quot;</span>开启或关闭当前行断点</span><br><span class="line">noremap &lt;Space&gt;bp :action ToggleLineBreakpoint&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;debug时快速计算表达式</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;qe :action QuickEvaluateExpression &lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>debug计算器</span><br><span class="line">noremap &lt;Space&gt;ee :action EvaluateExpression &lt;CR&gt;</span><br><span class="line"><span class="string">&quot;debug强制返回</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;fr :action Debugger.ForceEarlyReturn&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>添加新的debug观察</span><br><span class="line">noremap &lt;Space&gt;daw :action Debugger.AddToWatch&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;debug强制运行到光标处</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;fc :action ForceRunToCursor&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>安装了JRebel且在JRebel debug下才生效,热更新</span><br><span class="line">noremap &lt;Space&gt;hs :action Hotswap&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;安装了JRebel的debug运行</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;DD :action JRebel Debug&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>去除所有断点在当前文件中</span><br><span class="line">noremap &lt;Space&gt;rab :action Debugger.RemoveAllBreakpointsInFile&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;去除所有断点</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;raB :action Debugger.RemoveAllBreakpoints&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>弹出帧</span><br><span class="line">noremap &lt;Space&gt;df :action Debugger.PopFrame&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;显示当前断点位置</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;pp :action ShowExecutionPoint&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>流追踪技术</span><br><span class="line">noremap &lt;Space&gt;ds :action StreamTracerAction&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;哑断点技术</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;mb :action XDebugger.MuteBreakpoints&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>条件断点编辑</span><br><span class="line">noremap &lt;Space&gt;eb :action EditBreakpoint&lt;CR&gt;</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;</span>窗口篇<span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"><span class="string">&quot;激活maven窗口</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;AM  :action ActivateMavenToolWindow&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>激活database窗口</span><br><span class="line">noremap &lt;Space&gt;AD  :action ActivateDatabaseToolWindow&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;激活todo的窗口</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;AT   :action ActivateTODOToolWindow&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>激活Favorites的窗口</span><br><span class="line">noremap &lt;Space&gt;AF :action ActivateFavoritesToolWindow&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;激活project的窗口</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;AP :action ActivateProjectToolWindow&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>激活git的窗口</span><br><span class="line">noremap &lt;Space&gt;AG :action ActivateVersionControlToolWindow&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;激活git的窗口</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;AS :action ActivateServicesToolWindow&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>激活Breakpoints的窗口.</span><br><span class="line">noremap &lt;Space&gt;AB :action ViewBreakpoints&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;激活Rest的窗口(需要安装插件)</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;AR :action ActivateRestServicesToolWindow&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>激活debug的运行窗口</span><br><span class="line">nnoremap &lt;Space&gt;wd :action ActivateDebugToolWindow&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;激活run的运行窗口</span></span><br><span class="line"><span class="string">nnoremap &lt;Space&gt;wr :action ActivateRunToolWindow&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>隐藏窗口(windows hide)</span><br><span class="line">nnoremap &lt;Space&gt;wh :action HideActiveWindow&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;窗口最大化windows max</span></span><br><span class="line"><span class="string">nnoremap &lt;Space&gt;mm :action MaximizeToolWindow&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>隐藏所有窗口</span><br><span class="line">noremap &lt;Space&gt;ha :action HideAllWindows&lt;CR&gt;</span><br><span class="line">noremap &lt;Space&gt;&lt;Space&gt; :action HideAllWindows&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;激活窗口,选中当前位置</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;si :action SelectInProjectView&lt;CR&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;信息篇&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">&quot;</span>弹出警告信息</span><br><span class="line">noremap &lt;Space&gt;ed :action ShowErrorDescription&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;弹出类型信息</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;ti :action ExpressionTypeInfo&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>弹出参数信息</span><br><span class="line">noremap &lt;Space&gt;pi :action ParameterInfo&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;快速显示当前方法信息</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;jd :action QuickJavaDoc&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>弹出文件结构信息</span><br><span class="line">noremap &lt;Space&gt;fs mm`m:action FileStructurePopup&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;显示maven的依赖层级信息</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;sd  :action ShowUmlDiagram&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>弹出方法调用层级信息</span><br><span class="line">noremap &lt;Space&gt;ch :action CallHierarchy&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;查找引用了当前方法的文件信息</span></span><br><span class="line"><span class="string">nnoremap &lt;Space&gt;fu :action FindUsages&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>查找方法内使用该变量的引用信息</span><br><span class="line">nnoremap &lt;Space&gt;su :action ShowUsages&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;弹出方法结构信息</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;mh :action MethodHierarchy&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>弹出设置信息</span><br><span class="line">noremap &lt;Space&gt;ss  :action ShowSettings&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;弹出项目结构信息</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;ps :action ShowProjectStructureSettings&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;项目篇&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">&quot;</span>关闭项目</span><br><span class="line">noremap &lt;Space&gt;cP :action CloseProject&lt;CR&gt;</span><br><span class="line">noremap &lt;Space&gt;CP :action CloseProject&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;打开项目</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;oP :action OpenFile&lt;CR&gt;</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;OP :action OpenFile&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>新建项目</span><br><span class="line">noremap &lt;Space&gt;nP :action NewProject&lt;CR&gt;</span><br><span class="line">noremap &lt;Space&gt;NP :action NewProject&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;</span>实用工具篇<span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"><span class="string">&quot;代码环绕</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;sw :action SurroundWith&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>整理代码</span><br><span class="line">noremap &lt;Space&gt;= :action ReformatCode&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;弹出菜单</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;sm :action ShowPopupMenu&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>保存模板</span><br><span class="line">noremap &lt;Space&gt;st :action SaveAsTemplate&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;复制当前文件的绝对路径</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;cap   :action CopyAbsolutePath&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>复制当前文件名</span><br><span class="line">noremap &lt;Space&gt;ccp   :action CopyContentRootPath&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;优化导入</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;oi :action OptimizeImports&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>改变视图</span><br><span class="line">nnoremap &lt;Space&gt;cv :action ChangeView&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;关闭到只剩当前tab栏</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;co :action CloseAllEditorsButActive&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>g4文件生成代码(需要安装anltr4插件)</span><br><span class="line">noremap &lt;Space&gt;ag :action antlr.Generate&lt;CR&gt;:action antlr.Generate&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;显示字节码</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;bc   :action ByteCodeViewer&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>快速翻译(需要安装翻译插件)</span><br><span class="line">noremap &lt;Space&gt;qq   :action $TranslateTextComponent&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;替换翻译(需要安装翻译插件)</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;tr :action $TranslateAndReplaceAction&lt;CR&gt;</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;gfu :action GenerateFullRestUrl&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>添加到收藏文件</span><br><span class="line">noremap &lt;Space&gt;atf :action AddToFavorites&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;复制文件元素</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;cE :action CopyElement&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>新建文件元素</span><br><span class="line">noremap &lt;Space&gt;nE :action NewElement&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;删除当前文件元素</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;dE :action SafeDelete&lt;CR&gt;</span></span><br><span class="line"><span class="string">nnoremap &lt;Space&gt;cp :action CheckinProject&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>idea智能提示</span><br><span class="line">nnoremap &lt;CR&gt;&lt;CR&gt; :action ShowIntentionActions&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;跳转下个报错处(这个与idea智能提示配起来,炒鸡爽)</span></span><br><span class="line"><span class="string">nnoremap &lt;Space&gt;&lt;CR&gt; :action GotoNextError&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>新建类,比nE快</span><br><span class="line">noremap &lt;Space&gt;nc :action NewClass&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;打开项目设置</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;ps :action ShowProjectStructureSettings&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>露出文件夹</span><br><span class="line">noremap &lt;Space&gt;ri :action RevealIn&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;代码生成</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;ga :action Generate&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>删除未修改的tab</span><br><span class="line">noremap &lt;Space&gt;cu :action CloseAllUnmodifiedEditors&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;Codota查找类似代码，需要提前安装Codota插件</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;oc :action OpenCodotaSearch&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>Codota激活窗口，需要提前安装Codota插件</span><br><span class="line">noremap &lt;Space&gt;AC :action ActivateCodotaToolWindow&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;Codota激活窗口，需要提前安装Codota插件</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;cl :action CodotaLeanSearchCrossRefAction&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>CSDN万能工具，需要提前安装CSDN插件</span><br><span class="line">noremap &lt;Space&gt;csdn :action SearchByCSDN&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;大小写，驼峰，下划线，中划线转换</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;uu :action de.netnexus.CamelCasePlugin.ToggleCamelCase&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>替换</span><br><span class="line">noremap &lt;Space&gt;rp :action ReplaceInPath&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;vim配置操作</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;vm :action VimActions&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>查看代码git作者</span><br><span class="line">noremap &lt;Space&gt;us :action Annotate&lt;CR&gt;</span><br><span class="line"><span class="string">&quot;打开ddl语句</span></span><br><span class="line"><span class="string">noremap &lt;Space&gt;dl :action DatabaseView.OpenDdlInConsole&lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>大小写切换，必须要先安装插件</span><br><span class="line">noremap &lt;Space&gt;u :action de.netnexus.CamelCasePlugin.ToggleCamelCase&lt;CR&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>VIM</category>
      </categories>
      <tags>
        <tag>VIM</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis基础入门</title>
    <url>/posts/20004.html</url>
    <content><![CDATA[<h1 id="mybatis">Mybatis</h1>
<p>MyBatis是一款优秀的持久层框架，==用于简化JDBC的开发。==</p>
<h2 id="jdbc">JDBC</h2>
<p>JDBC：（Java DataBase
Connectivity），就是使用ava语言操作关系型数据库的一套API。</p>
<ul>
<li>sun公司官方定义的一套操作所有关系型数据库的规范，即接口。</li>
<li>各个数据库厂商去实现这套接口，提供数据库驱动jar包。</li>
<li>我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span> <span class="comment">//springboot整合单元测试的注解</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpringbootMybatisQuickstartApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testListUser</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;User&gt; userList = userMapper.list();</span><br><span class="line">        userList.stream().forEach(user -&gt; &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJdbc</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1. 注册驱动</span></span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 获取连接对象</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/mybatis&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;1234&quot;</span>;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, username, password);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 获取执行SQL的对象Statement,执行SQL,返回结果</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user&quot;</span>;</span><br><span class="line">        <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement();</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> statement.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 封装结果数据</span></span><br><span class="line">        List&lt;User&gt; userList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (resultSet.next())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> resultSet.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> resultSet.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">            <span class="type">short</span> <span class="variable">age</span> <span class="operator">=</span> resultSet.getShort(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">            <span class="type">short</span> <span class="variable">gender</span> <span class="operator">=</span> resultSet.getShort(<span class="string">&quot;gender&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> resultSet.getString(<span class="string">&quot;phone&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(id,name,age,gender,phone);</span><br><span class="line">            userList.add(user);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. 释放资源</span></span><br><span class="line">        statement.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="mybatis使用流程">MyBatis使用流程</h2>
<ul>
<li>1.准备工作(创建springboot工程、数据库表user、实体类User)</li>
<li>2.引入Mybatis的相关依赖，配置Mybatis</li>
<li>3.编写SQL语句(注解/XML)</li>
</ul>
<h2 id="数据库连接池">数据库连接池</h2>
<ul>
<li>数据库连接池是个容器，负责分配、管理数据库连接(Connection)</li>
<li>它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个</li>
<li>释放空闲时间超过最大空闲时间的连接，来避免因为没有释放连接而引起的数据库连接遗漏</li>
</ul>
<blockquote>
<p>优点：</p>
<ul>
<li>资源重用</li>
<li>提升系统响应速度</li>
<li>避免数据库连接遗漏</li>
</ul>
</blockquote>
<h2 id="lombok">lombok</h2>
<p>Lombok是一个实用的Java类库，能通过注解的形式自动生成构造器、getter/setter、equals、hashcode、toString等方法，并可以自动化生成日志变量，简化java开发、提高效率。</p>
<table>
<colgroup>
<col style="width: 27%" />
<col style="width: 72%" />
</colgroup>
<thead>
<tr class="header">
<th>注解</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="citation" data-cites="Getter">@Getter</span>/ <span
class="citation" data-cites="Setter">@Setter</span></td>
<td>为所有的属性提供get/set方法</td>
</tr>
<tr class="even">
<td><span class="citation" data-cites="ToString">@ToString</span></td>
<td>会给类自动生成易阅读的toString方法</td>
</tr>
<tr class="odd">
<td><span class="citation"
data-cites="EqualsAndHashcode">@EqualsAndHashcode</span></td>
<td>根据类所拥有的非静态字段自动重写equals方法和 hashCode方法</td>
</tr>
<tr class="even">
<td><strong><span class="citation"
data-cites="Data">@Data</span></strong></td>
<td>提供了更综合的生成代码功能(<span class="citation"
data-cites="Getter">@Getter</span> + <span class="citation"
data-cites="Setter">@Setter</span> +<span class="citation"
data-cites="ToString">@ToString</span> +<span class="citation"
data-cites="EqualsAndHashCode">@EqualsAndHashCode</span>)</td>
</tr>
<tr class="odd">
<td><strong><span class="citation"
data-cites="NoArgsConstructor">@NoArgsConstructor</span></strong></td>
<td>为实体类生成无参的构造器方法</td>
</tr>
<tr class="even">
<td><strong><span class="citation"
data-cites="AllArgsConstructor">@AllArgsConstructor</span></strong></td>
<td>为实体类生成除了static修饰的字段之外带有各参数的构造器方法。</td>
</tr>
</tbody>
</table>
<h1 id="第一步准备工作">第一步：准备工作</h1>
<ul>
<li>准备好数据库表 Emp （员工表）</li>
<li>创建一个新的springboot工程，选择引入对应的起步依赖（mybatis、mysql驱动、lombok）</li>
<li>application.properties中引入数据库连接信息</li>
<li>创建对应的实体类Emp（实体类属性采用驼峰命名）</li>
<li>准备Mapper接口EmpMapper（加上Mapper接口）</li>
</ul>
<h1
id="第二步先开发简单的增删改查mapper">第二步：先开发简单的增删改查Mapper</h1>
<ul>
<li>使用@Delete <span class="citation"
data-cites="Insert">@Insert</span> <span class="citation"
data-cites="Select">@Select</span></li>
</ul>
<blockquote>
<p>注意SQL语句中的占位符 #{变量名}</p>
<p>注意接口方法的返回值现在先可以自己定义，在后期会统一换成自己设定的Result类，确保返回给前端的数据解析方便</p>
</blockquote>
<ul>
<li><p>每次开发好一个接口方法时，进行测试，确保测试的覆盖率</p></li>
<li><p>application.properties配置mybatis的日志，指定输出到控制台</p></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">#配置mybatis的日志，指定输出到控制台</span><br><span class="line">mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdoutImpl</span><br></pre></td></tr></table></figure>
<p>==注意变量名与pojo中一致，表示获取实体类的属性==</p>
<h2 id="预编译sql">预编译SQL</h2>
<blockquote>
<p>为什么java会使用预编译的SQL语句？</p>
<ul>
<li>性能更高</li>
<li>更安全（防止SQL注入）</li>
</ul>
</blockquote>
<blockquote>
<p>java项目在执行SQL语句时的步骤</p>
<ul>
<li>缓存
<ul>
<li>SQL语法解析检查</li>
<li>优化SQL</li>
<li>编译SQL</li>
</ul></li>
<li>执行SQL</li>
</ul>
</blockquote>
<p>为什么性能更高呢？</p>
<blockquote>
<p>例如：</p>
<p>delete from emp where id = 1;</p>
<p>delete from emp where id = 2;</p>
<p>delete from emp where id = 3;</p>
<p>上述三条不进行预编译会缓存编译三次</p>
<p>预编译如下添加占位符：</p>
<p>delete from emp where id = ?</p>
<p>1 2 3</p>
<p>缓存编译一次</p>
</blockquote>
<p>为什么更安全呢？</p>
<p>SQL注入是通过操作输入的数据来修改事先定义好的SQL语句，以达到执行代码对服务器进行攻击的方法</p>
<blockquote>
<p>解决了SQL注入</p>
<p>例如正常的账号 wang 密码 123456</p>
<p>SQL语句：select conut(*) from emp where username = ‘wang’ and
password = ‘123456’;</p>
<p>SQL注入攻击：</p>
<p>账号：whatever 密码 ‘ or ’1‘ = ’1</p>
<p>SQL语句：select conut(*) from emp where username = ‘whatever’ and
password = ‘==‘ or ’1‘ = ’1==’;</p>
<p>上述语句必然成立，达到了攻击的效果</p>
<p>预编译SQL：</p>
<p>SQL语句：select count(*) from emp where username =? and password =
?</p>
<p>参数传递，避免了SQL注入</p>
</blockquote>
<ul>
<li>==使用预编译SQL语句（#{}）==</li>
<li>==使用拼接SQL语句（${}）==</li>
</ul>
<h2 id="如何拿到主键值">如何拿到主键值？</h2>
<p>正常的属性方法getId无法拿到主键值，需要使用注解</p>
<blockquote>
<p><span class="citation"
data-cites="Options">@Options</span>(keyProperty=“id”,
useGeneratedKeys=true)</p>
<p>useGeneratedKeys=true代表我们需要拿到主键，keyProperty=‘Id’表示我们需要将主键封装的emp的Id中去</p>
</blockquote>
<h2 id="数据封装">数据封装</h2>
<ul>
<li><p>实体类属性名和数据库表查询返回的字段名一致，mybatis会自动封装。</p></li>
<li><p>实体类属性名和数据库表查询返回的字段名不一致，不能自动封装。</p></li>
</ul>
<p>如何封装</p>
<ul>
<li>1.为字段不同的字段起别名，就是SQL中的as起别名，将别名与实体类属性名一致即可</li>
<li>2.通过@Results，<span class="citation"
data-cites="Result注解手动映射封装">@Result注解手动映射封装</span>（不建议）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">	@Result(column = &quot;dept_id&quot;, property = &quot;deptId&quot; ),</span></span><br><span class="line"><span class="meta">	@Result(column = &quot;create_time&quot;, property = &quot;createTime&quot;)</span></span><br><span class="line"><span class="meta">    @Result(column = &quot;update_time&quot;, property = &quot;updateTime&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>3.开启Mybatis驼峰命名映射开关（==建议，但是要确保开发时的命名规范==）</li>
</ul>
<p>application.properties配置mybatis的驼峰命名映射开关</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">#开启mybatis的驼峰命名自动映射开关a_column ------&gt; aCloumn</span><br><span class="line">mybatis.configuration.map-underscore-to-camel-case=true</span><br></pre></td></tr></table></figure>
<h2 id="注意的使用时机">注意${}的使用时机</h2>
<p>#{}不能出现在引号中，所以类似于SQL中的like ‘%#{name}%’
这类模糊匹配需要改为</p>
<ul>
<li>like ‘%${name}%’ ==性能低，存在SQL注入攻击问题==</li>
<li>concat(‘%’, #{name}, ‘%’) ==性能高，更安全==</li>
</ul>
<h2 id="单独使用mybatis时的参数映射">单独使用Mybatis时的参数映射</h2>
<figure>
<img
src="https://wang-nine.cn/images/%25E6%259D%2582%25E9%25A1%25B904-01%25E5%258F%2582%25E6%2595%25B0%25E6%2598%25A0%25E5%25B0%2584.png"
alt="mybatis参数映射" />
<figcaption aria-hidden="true">mybatis参数映射</figcaption>
</figure>
<h2 id="xml映射文件">XML映射文件</h2>
<p><strong>规范</strong></p>
<ul>
<li>XML映射文件的名称与Mapper接口名称一致，并且将XML映射文件和Mapper接口放置在相同包下(同包同名)</li>
<li>XML映射文件的namespace属性为Mapper接口全限定名一致。</li>
<li>XML映射文件中sql语句的id与Mapper接口中的方法名一致，并保持返回类型一致。</li>
</ul>
<figure>
<img
src="https://wang-nine.cn/images/MyBatis%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8.png"
alt="MyBatis快速入门" />
<figcaption aria-hidden="true">MyBatis快速入门</figcaption>
</figure>
<h2 id="动态sql">动态SQL</h2>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 66%" />
</colgroup>
<thead>
<tr class="header">
<th>标签</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>&lt;if &gt; &lt;/if&gt;</td>
<td>用于判断条件是否成立。使用test属性进行条件判断，如果条件为true，则拼接SQL</td>
</tr>
<tr class="even">
<td>&lt;where&gt;&lt;/where&gt;</td>
<td>where
元素只会在子元素有内容的情况下才插入where子句。而且会自动去除子句的开头的AND或OR。</td>
</tr>
<tr class="odd">
<td>&lt;set&gt;&lt;/set&gt;</td>
<td>动态地在行首插入SET关键字，并会删掉额外的逗号。(用在update语句中)</td>
</tr>
<tr class="even">
<td>&lt;foreach 五个属性&gt;&lt;/foreach&gt;</td>
<td>collection:遍历的集合<br>item:遍历出来的元素<br>separator:分隔符<br/>open:遍历开始前拼接的SQL工片段<br>close:遍历结束后拼接的SQL片段</td>
</tr>
<tr class="odd">
<td>&lt;sql id=&gt;&lt;/sql&gt;</td>
<td>抽取相同的SQL片段</td>
</tr>
<tr class="even">
<td>&lt;include refid=&gt;&lt;/include&gt;</td>
<td>引用SQL片段</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>VIM基础教程</title>
    <url>/posts/20002.html</url>
    <content><![CDATA[<h2 id="vim-三种基本的工作模式">1、vim 三种基本的工作模式</h2>
<p>vim有三种基本的工作模式，分别为：命令模式、末行模式、编辑模式。关于这三种工作模式的介绍，请见下文。</p>
<h3 id="命令模式">1.1、命令模式</h3>
<p>使用vim打开文件之后，首先进入命令模式，它是vim编辑器的入口模式。在命令模式下，通过使用命令对文件进行常规的编辑操作，例如：复制、粘贴、删除、定位、翻页等等。</p>
<h3 id="末行模式">1.2、末行模式</h3>
<p>末行模式是vim编辑器的出口，要退出vim，必须要在末行模式下。在末行模式下，执行退出文件、保存并退出文件等操作。</p>
<h3 id="编辑模式">1.3、编辑模式</h3>
<p>正常的编辑文字模式。</p>
<h2 id="三种模式的切换操作">2、三种模式的切换操作</h2>
<p>（1）vim打开一个文件进入的就是命令模式，另外两种模式需要回到命令模式才能进入彼此。</p>
<p>（2）在命令模式中按下<code>i，I，o，O，a，A，r，R</code>任何一个字母后进入编辑模式，进入编辑模式后，下方会出现<code>INSERT</code>或者<code>REPLACE</code>字样，按<code>Esc</code>键退出编辑模式，回到命令模式。</p>
<p>（3）在命令模式中按下<code>:，/，?</code>中任意一个即可进入末行模式，末行模式可以对文档或者vim环境进行操作，例如查找、读取、存盘、替换、离开、显示行号等。</p>
<h2 id="各种模式切换">3、各种模式切换</h2>
<h3 id="普通模式-----normal-----插入模式-----insert----">普通模式 - -
NORMAL - - ———&gt; 插入模式 - - INSERT - -</h3>
<ul>
<li><p>insert</p>
<ul>
<li><p>i 在光标前插入</p></li>
<li><p>I 在行首插入</p></li>
</ul></li>
<li><p>open a new line</p>
<ul>
<li><p>o 在下一行插入</p></li>
<li><p>O 在上一行插入</p></li>
</ul></li>
<li><p>append</p>
<ul>
<li>a 在光标后插入</li>
<li>A 在行尾插入</li>
</ul></li>
</ul>
<h3 id="普通模式-----normal-----插入模式-----insert-----1">普通模式 - -
NORMAL - - &lt;——— 插入模式 - - INSERT - -</h3>
<ul>
<li>ESC</li>
<li>jj / CapsLock</li>
</ul>
<h3 id="普通模式-----normal-----可视模式-----visual----">普通模式 - -
NORMAL - - ———&gt; 可视模式 - - VISUAL - -</h3>
<ul>
<li>v</li>
</ul>
<h3 id="普通模式-----normal-----可视模式-----visual-----1">普通模式 - -
NORMAL - - &lt;——— 可视模式 - - VISUAL - -</h3>
<ul>
<li>v</li>
<li>Esc</li>
</ul>
<h3 id="普通模式-----normal-----命令模式">普通模式 - - NORMAL - -
———&gt; 命令模式</h3>
<ul>
<li>:</li>
</ul>
<h3 id="普通模式-----normal-----命令模式-1">普通模式 - - NORMAL - -
&lt;——— 命令模式</h3>
<ul>
<li>Esc</li>
</ul>
<h3 id="总结">总结</h3>
<figure>
<img src="https://wang-nine.cn/images/Vim01.png" alt="Vim01" />
<figcaption aria-hidden="true">Vim01</figcaption>
</figure>
<figure>
<img src="https://wang-nine.cn/images/Vim02.png" alt="Vim02" />
<figcaption aria-hidden="true">Vim02</figcaption>
</figure>
<figure>
<img src="https://wang-nine.cn/images/Vim03.png" alt="Vim03" />
<figcaption aria-hidden="true">Vim03</figcaption>
</figure>
<figure>
<img src="https://wang-nine.cn/images/Vim04.png" alt="Vim04" />
<figcaption aria-hidden="true">Vim04</figcaption>
</figure>
<figure>
<img src="https://wang-nine.cn/images/Vim05.png" alt="Vim05" />
<figcaption aria-hidden="true">Vim05</figcaption>
</figure>
<h2 id="光标移动">4、光标移动</h2>
<figure>
<img src="https://wang-nine.cn/images/Vim06.png" alt="Vim06" />
<figcaption aria-hidden="true">Vim06</figcaption>
</figure>
<figure>
<img src="https://wang-nine.cn/images/Vim07.png" alt="Vim07" />
<figcaption aria-hidden="true">Vim07</figcaption>
</figure>
<p>解释：</p>
<ul>
<li>w : word</li>
<li>b : begin</li>
<li>e : end</li>
<li>ge : 不太常用</li>
</ul>
<figure>
<img src="https://wang-nine.cn/images/Vim08.png" alt="Vim08" />
<figcaption aria-hidden="true">Vim08</figcaption>
</figure>
<figure>
<img src="https://wang-nine.cn/images/Vim09.png" alt="Vim09" />
<figcaption aria-hidden="true">Vim09</figcaption>
</figure>
<table style="width:100%;">
<colgroup>
<col style="width: 5%" />
<col style="width: 33%" />
<col style="width: 20%" />
<col style="width: 28%" />
<col style="width: 11%" />
</colgroup>
<thead>
<tr class="header">
<th>字符</th>
<th>单词</th>
<th>行</th>
<th>跳转</th>
<th>句和段</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>h 左</td>
<td>w下一个单词开头</td>
<td>0 行首</td>
<td>f char 跳到char位置</td>
<td>( 到句首</td>
</tr>
<tr class="even">
<td>j 下</td>
<td>b本单词或上一个单词开头</td>
<td>^ 行首非空字符</td>
<td>F char 反向</td>
<td>) 到句尾</td>
</tr>
<tr class="odd">
<td>k 上</td>
<td>e本单词或下一个单词结尾</td>
<td>$ 行尾</td>
<td>t char char前一位置</td>
<td>{ 到段首</td>
</tr>
<tr class="even">
<td>l 右</td>
<td>ge上一个单词结尾</td>
<td>gg 首行</td>
<td>T char char后一位置</td>
<td>} 到段尾</td>
</tr>
<tr class="odd">
<td></td>
<td>W长单词 E长单词 B长单词</td>
<td>G 尾行</td>
<td>; 重复上次的跳转</td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td>ngg 第n行</td>
<td>, 反向查找上次的查找</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="动作-motion">5、动作 motion</h2>
<figure>
<img src="https://wang-nine.cn/images/Vim10.png" alt="Vim10" />
<figcaption aria-hidden="true">Vim10</figcaption>
</figure>
<figure>
<img src="https://wang-nine.cn/images/Vim11.png" alt="Vim11" />
<figcaption aria-hidden="true">Vim11</figcaption>
</figure>
<ul>
<li>it : inner tag</li>
<li>is : inner sentence</li>
<li>ip : inner paragraph</li>
</ul>
<h2 id="操作符">6、操作符</h2>
<figure>
<img src="https://wang-nine.cn/images/Vim12.png" alt="Vim12" />
<figcaption aria-hidden="true">Vim12</figcaption>
</figure>
<table>
<thead>
<tr class="header">
<th>操作符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>d(delete)</td>
<td>删除</td>
</tr>
<tr class="even">
<td>c(change)</td>
<td>修改（删除并且进入插入模式）</td>
</tr>
<tr class="odd">
<td>y(yank)</td>
<td>复制</td>
</tr>
<tr class="even">
<td>v(visual)</td>
<td>选中并且进入 VISUAL 模式</td>
</tr>
<tr class="odd">
<td>p(paste)</td>
<td>粘贴</td>
</tr>
<tr class="even">
<td>b(bracket)</td>
<td>小括号的简写</td>
</tr>
<tr class="odd">
<td>B(Bracket)</td>
<td>大括号的简写</td>
</tr>
<tr class="even">
<td>e(entire)</td>
<td>全选</td>
</tr>
</tbody>
</table>
<h2 id="大小写">7、大小写</h2>
<figure>
<img src="https://wang-nine.cn/images/Vim13.png" alt="Vim13" />
<figcaption aria-hidden="true">Vim13</figcaption>
</figure>
<ul>
<li>‘g’ means goto</li>
<li>‘U’ means Uppercase</li>
<li>‘u’ 与上一个相反</li>
</ul>
<h2 id="tips">Tips</h2>
<ul>
<li>gd : goto definition 跳转到定义</li>
<li>ctrl + o : 跳回</li>
<li>gh : goto (mouse) hover 鼠标悬浮</li>
<li>gt : goto tab 跳转下一个标签页</li>
<li>gT : 与上一个相反 跳转上一个标签页</li>
<li>ngt / ngT : 跳转到第n个标签页</li>
</ul>
<h2 id="vscode中的vim">VSCode中的Vim</h2>
<ul>
<li><p>vscode中&lt;leader&gt;默认为space</p></li>
<li><p>&lt;leader&gt;&lt;leader&gt; S{Charactor} : 寻找某个字符</p></li>
<li><p>&lt;leader&gt;&lt;leader&gt; xxx : 详见配置</p></li>
</ul>
<table>
<colgroup>
<col style="width: 36%" />
<col style="width: 63%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Motion Command</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td
style="text-align: left;"><code>&lt;leader&gt;&lt;leader&gt; s &lt;char&gt;</code></td>
<td style="text-align: left;">Search character</td>
</tr>
<tr class="even">
<td
style="text-align: left;"><code>&lt;leader&gt;&lt;leader&gt; f &lt;char&gt;</code></td>
<td style="text-align: left;">Find character forwards</td>
</tr>
<tr class="odd">
<td
style="text-align: left;"><code>&lt;leader&gt;&lt;leader&gt; F &lt;char&gt;</code></td>
<td style="text-align: left;">Find character backwards</td>
</tr>
<tr class="even">
<td
style="text-align: left;"><code>&lt;leader&gt;&lt;leader&gt; t &lt;char&gt;</code></td>
<td style="text-align: left;">Til character forwards</td>
</tr>
<tr class="odd">
<td
style="text-align: left;"><code>&lt;leader&gt;&lt;leader&gt; T &lt;char&gt;</code></td>
<td style="text-align: left;">Til character backwards</td>
</tr>
<tr class="even">
<td
style="text-align: left;"><code>&lt;leader&gt;&lt;leader&gt; w</code></td>
<td style="text-align: left;">Start of word forwards</td>
</tr>
<tr class="odd">
<td
style="text-align: left;"><code>&lt;leader&gt;&lt;leader&gt; b</code></td>
<td style="text-align: left;">Start of word backwards</td>
</tr>
<tr class="even">
<td
style="text-align: left;"><code>&lt;leader&gt;&lt;leader&gt; l</code></td>
<td style="text-align: left;">Matches beginning &amp; ending of word,
camelCase, after <code>_</code>, and after <code>#</code> forwards</td>
</tr>
<tr class="odd">
<td
style="text-align: left;"><code>&lt;leader&gt;&lt;leader&gt; h</code></td>
<td style="text-align: left;">Matches beginning &amp; ending of word,
camelCase, after <code>_</code>, and after <code>#</code> backwards</td>
</tr>
<tr class="even">
<td
style="text-align: left;"><code>&lt;leader&gt;&lt;leader&gt; e</code></td>
<td style="text-align: left;">End of word forwards</td>
</tr>
<tr class="odd">
<td
style="text-align: left;"><code>&lt;leader&gt;&lt;leader&gt; ge</code></td>
<td style="text-align: left;">End of word backwards</td>
</tr>
<tr class="even">
<td
style="text-align: left;"><code>&lt;leader&gt;&lt;leader&gt; j</code></td>
<td style="text-align: left;">Start of line forwards</td>
</tr>
<tr class="odd">
<td
style="text-align: left;"><code>&lt;leader&gt;&lt;leader&gt; k</code></td>
<td style="text-align: left;">Start of line backwards</td>
</tr>
<tr class="even">
<td
style="text-align: left;"><code>&lt;leader&gt;&lt;leader&gt; / &lt;char&gt;... &lt;CR&gt;</code></td>
<td style="text-align: left;">Search n-character</td>
</tr>
<tr class="odd">
<td
style="text-align: left;"><code>&lt;leader&gt;&lt;leader&gt;&lt;leader&gt; bdt</code></td>
<td style="text-align: left;">Til character</td>
</tr>
<tr class="even">
<td
style="text-align: left;"><code>&lt;leader&gt;&lt;leader&gt;&lt;leader&gt; bdw</code></td>
<td style="text-align: left;">Start of word</td>
</tr>
<tr class="odd">
<td
style="text-align: left;"><code>&lt;leader&gt;&lt;leader&gt;&lt;leader&gt; bde</code></td>
<td style="text-align: left;">End of word</td>
</tr>
<tr class="even">
<td
style="text-align: left;"><code>&lt;leader&gt;&lt;leader&gt;&lt;leader&gt; bdjk</code></td>
<td style="text-align: left;">Start of line</td>
</tr>
<tr class="odd">
<td
style="text-align: left;"><code>&lt;leader&gt;&lt;leader&gt;&lt;leader&gt; j</code></td>
<td style="text-align: left;">JumpToAnywhere motion; default behavior
matches beginning &amp; ending of word, camelCase, after <code>_</code>
and after <code>#</code></td>
</tr>
</tbody>
</table>
<p><code>&lt;leader&gt;&lt;leader&gt; (2s|2f|2F|2t|2T) &lt;char&gt;&lt;char&gt;</code>
and
<code>&lt;leader&gt;&lt;leader&gt;&lt;leader&gt; bd2t &lt;char&gt;char&gt;</code>
are also available. The difference is character count required for
search. For example,
<code>&lt;leader&gt;&lt;leader&gt; 2s &lt;char&gt;&lt;char&gt;</code>
requires two characters, and search by two characters. This mapping is
not a standard mapping, so it is recommended to use your custom
mapping.</p>
<ul>
<li>surround</li>
</ul>
<table>
<colgroup>
<col style="width: 31%" />
<col style="width: 68%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Surround Command</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td
style="text-align: left;"><code>y s &lt;motion&gt; &lt;desired&gt;</code></td>
<td style="text-align: left;">Add <code>desired</code> surround around
text defined by <code>&lt;motion&gt;</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>d s &lt;existing&gt;</code></td>
<td style="text-align: left;">Delete <code>existing</code> surround</td>
</tr>
<tr class="odd">
<td
style="text-align: left;"><code>c s &lt;existing&gt; &lt;desired&gt;</code></td>
<td style="text-align: left;">Change <code>existing</code> surround to
<code>desired</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>S &lt;desired&gt;</code></td>
<td style="text-align: left;">Surround when in visual modes (surrounds
full selection)</td>
</tr>
</tbody>
</table>
<p>Some examples:</p>
<ul>
<li><code>"test"</code> with cursor inside quotes type <code>cs"'</code>
to end up with <code>'test'</code></li>
<li><code>"test"</code> with cursor inside quotes type <code>ds"</code>
to end up with <code>test</code></li>
<li><code>"test"</code> with cursor inside quotes type <code>cs"t</code>
and enter <code>123&gt;</code> to end up with
<code>&lt;123&gt;test&lt;/123&gt;</code></li>
</ul>
<h2 id="多光标功能">多光标功能</h2>
<h3 id="multi-cursor-mode">🖱️ Multi-Cursor Mode</h3>
<blockquote>
<p>:warning: Multi-Cursor mode is experimental. Please report issues in
our <a href="https://github.com/VSCodeVim/Vim/issues/824">feedback
thread.</a></p>
</blockquote>
<p>Enter multi-cursor mode by:</p>
<ul>
<li>On OSX, <code>cmd-d</code>. On Windows, <code>ctrl-d</code>.</li>
<li><code>gb</code>, a new shortcut we added which is equivalent to
<code>cmd-d</code> (OSX) or <code>ctrl-d</code> (Windows). It adds
another cursor at the next word that matches the word the cursor is
currently on.</li>
<li>Running "Add Cursor Above/Below" or the shortcut on any
platform.</li>
</ul>
<p>Once you have multiple cursors, you should be able to use Vim
commands as you see fit. Most should work; some are unsupported (ref <a
href="https://github.com/VSCodeVim/Vim/pull/587">PR#587</a>).</p>
<ul>
<li>Each cursor has its own clipboard.</li>
<li>Pressing Escape in Multi-Cursor Visual Mode will bring you to
Multi-Cursor Normal mode. Pressing it again will return you to Normal
mode.</li>
</ul>
<p>vscode中可以使用 cmd + d 批量修改</p>
<p>vim中可以使用 gb 批量膝盖</p>
<h2 id="将光标定位到终端">将光标定位到终端</h2>
<p>在settings.json添加如下快捷键</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//由editor 转到 terminal</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;before&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;leader&quot;</span><span class="punctuation">,</span> <span class="string">&quot;t&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;commands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;workbench.action.terminal.focus&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>space + t 即可跳转到终端中</p>
<h2 id="跳转tab">跳转Tab</h2>
<p>进入命令模式 :</p>
<ul>
<li>输入 tabn : tab next 即进入下一个标签页</li>
<li>输入 tabp : tab prev 即进入下一个标签页</li>
</ul>
]]></content>
      <categories>
        <category>VIM</category>
      </categories>
      <tags>
        <tag>VIM</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot基础原理</title>
    <url>/posts/20005.html</url>
    <content><![CDATA[<h1 id="配置优先级">配置优先级</h1>
<p>优先级(低→高)</p>
<ul>
<li>application.yaml （忽略)</li>
<li>application.yml</li>
<li>application.properties</li>
<li>java系统属性(-Dxxx=xxx)</li>
<li>命令行参数(- -xxx=xxx)</li>
</ul>
<h1 id="获取bean">获取Bean</h1>
<ul>
<li>默认情况下，Spring项目启动时，会把bean都创建好放在IOC容器中，如果想要主动获取这些bean，可以通过如下方式：
<ul>
<li>根据name获取bean：object getBean (String name)</li>
<li>根据类型获取bean：&lt;T&gt; T
getBean(Class&lt;T&gt;crequiredType)</li>
<li>根据name获取bean(带类型转换):&lt;T&gt; T getBean(String
name，Class&lt;T&gt; requiredType)</li>
</ul></li>
</ul>
<blockquote>
<p>上述所说的【Spring项目启动时，会把其中的bean都创建好】还会受到作用域及延迟初始化影响，这里主要针对于默认的单例非延迟加载的bean而言。</p>
</blockquote>
<h1 id="bean的作用域">Bean的作用域</h1>
<table>
<thead>
<tr class="header">
<th>作用域</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>singleton</td>
<td>容器内同名称的bean只有一个实例(单例)（默认)</td>
</tr>
<tr class="even">
<td>prototype</td>
<td>每次使用该 bean时会创建新的实例(非单例)</td>
</tr>
<tr class="odd">
<td>request</td>
<td>每个请求范围内会创建新的实例（web环境中，了解)</td>
</tr>
<tr class="even">
<td>session</td>
<td>每个会话范围内会创建新的实例(web环境中，了解)</td>
</tr>
<tr class="odd">
<td>application</td>
<td>每个应用范围内会创建新的实例(web环境中，了解)</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意事项</p>
<ul>
<li>默认singleton的bean，在容器启动时被创建，可以使用@Lazy注解来延迟初始化(延迟到第一次使用时）</li>
<li>prototype的bean，每一次使用该bean的时候都会创建一个新的实例。</li>
<li>实际开发当中，绝大部分的Bean是单例的，也就是说绝大部分Bean不需要配置scope属性。</li>
</ul>
</blockquote>
<h1 id="第三方bean">第三方Bean</h1>
<p>==<span class="citation" data-cites="Bean">@Bean</span>==
==如果要管理的bean对象来自于第三方〈不是自定义的)，是无法用@Component及衍生注解声明bean的，就需要用到@Bean注解。==</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/posts/5.html</url>
    <content><![CDATA[<p>事务隔离</p>
<p>索引</p>
<p>jwt</p>
<p>微服务</p>
<p>多线程</p>
<p>乐观/悲观</p>
<p>limit 1000000</p>
<p>aqs</p>
<p>g1 cms</p>
<p>redis</p>
<p>tcp拥塞控制</p>
<p>jmm</p>
<p>jvm</p>
<p>可达性分析</p>
<p>接雨水</p>
<p>协程</p>
<p>Spring SpringMVC SpringBoot</p>
<p>cas 和 volatile</p>
<p>3握4挥</p>
<p>拦截与过滤区别</p>
<p>Session</p>
<p>循环队列</p>
<p>基于session存储用户的登陆信息，后采用redis存储进行优化，设置了拦截器链解决了</p>
]]></content>
  </entry>
  <entry>
    <title>JUC</title>
    <url>/posts/20007.html</url>
    <content><![CDATA[<h1 id="java.util.concurrent">Java.util.concurrent</h1>
<p>进程:指在系统中正在运行的一个应用程序﹔程序一旦运行就是进程﹔进程——资源分配的最小单位。。
线程:系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个单元执行流。线程——程序执行的最小单位。</p>
<h2
id="线程的状态可以通过thread.state枚举类查看">线程的状态（可以通过Thread.State枚举类查看）</h2>
<ul>
<li>NEW （新建态）</li>
<li>RUNNABLE（准备就绪）</li>
<li>BLOCKED（阻塞）</li>
<li>WAITING（不见不散）</li>
<li>TIMED WAITING（过时不候）</li>
<li>TERMINATED（终止）</li>
</ul>
<h2 id="wait和sleep的区别">Wait和Sleep的区别</h2>
<ul>
<li>sleep是Thread的静态方法，wait是
Object的方法，任何对象实例都能调用</li>
<li>sleep不会释放锁，它也不需要占用锁。wait会释放锁，但调用它的前提是当前线程占有锁(即代码要在synchronized中)</li>
<li>它们都可以被interrupted方法中断</li>
</ul>
]]></content>
      <categories>
        <category>JUC</category>
      </categories>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>项目重构</title>
    <url>/posts/20006.html</url>
    <content><![CDATA[<h1 id="环境搭建">环境搭建</h1>
<ul>
<li>准备数据库表（dept，emp)</li>
<li>创建SpringBoot工程
<ul>
<li>引入web开发起步依赖，mybatis依赖（mybatis依赖和mysql驱动），lombok依赖</li>
</ul></li>
<li>在application.properties中引入mybatis的配置信息</li>
<li>准备对应的实体类</li>
<li>准备对应的Mapper、Service(接口、实现类)、Controller基础结构</li>
</ul>
<h1
id="部门管理开发根据接口文档阅读开发restful风格">部门管理开发：根据接口文档阅读开发Restful风格</h1>
<ul>
<li>明确三层架构的功能</li>
<li>Controller
<ul>
<li>1.接收请求</li>
<li>2.调用service层功能</li>
<li>3.响应</li>
</ul></li>
<li>Service
<ul>
<li>调用mapper接口功能</li>
</ul></li>
<li>Mapper
<ul>
<li>执行对应的SQL语句与数据库进行互动</li>
</ul></li>
</ul>
<blockquote>
<p>简化开发：二者效果相同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestNapping(value = &quot;/depts&quot;, method = RequestNethod.GET)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/ depts&quot;)</span></span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>注意在接口中注入Bean对象，例如Controller中注入Service对象，Service中注入Mapper对象，达到解耦的效果</p>
</blockquote>
<p>==接口测试，postman / 前后端联调==</p>
<p>==日志：<span class="citation" data-cites="Slf4j">@Slf4j</span>==</p>
<p>==注意某些路径的 <span class="citation"
data-cites="PathVariable">@PathVariable</span>==</p>
<p>==注意解析json格式的前端请求参数可以使用@RequestBody来将json封装到实体类中==</p>
<p>==<span class="citation"
data-cites="RequestMapping">@RequestMapping</span>(“/depts”)
公共路径抽取：完整的请求路径，应该是类上的@RequestMapping
的value属性＋方法上的@RequestMapping的value属性。==</p>
<h1 id="员工管理开发">员工管理开发：</h1>
<ul>
<li>难点：分页查询</li>
</ul>
<h2 id="分页查询">分页查询</h2>
<h3 id="需要两条sql语句">需要两条SQL语句</h3>
<ul>
<li>显示当前页面</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp limit ?, ?;</span><br></pre></td></tr></table></figure>
<ul>
<li>显示所有数据</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select count(*) from emp;</span><br></pre></td></tr></table></figure>
<h3 id="前端传来的数据">前端传来的数据</h3>
<ul>
<li>当前页码:page</li>
<li>每页展示记录数:pageSize</li>
</ul>
<h3 id="后端响应的数据">后端响应的数据</h3>
<ul>
<li>数据列表:List select * from emp limit ?,?;</li>
<li>总记录数:total select count (*) from emp;</li>
</ul>
<p>==目前需要返回两项数据，方法只能返回一个数据，使用实体类封装返回==</p>
<p>==<span class="citation"
data-cites="ResultParam">@ResultParam</span>(defaultvalue = ”默认值“)
参数 可以设置参数的默认值==</p>
<h3 id="分页查询插件pagehelper">分页查询插件PageHelper</h3>
<figure>
<img
src="https://wang-nine.cn/images/%E6%9D%82%E9%A1%B904-02PageHelper.png"
alt="杂项04-02PageHelper" />
<figcaption aria-hidden="true">杂项04-02PageHelper</figcaption>
</figure>
<h1 id="文件上传">文件上传</h1>
<figure>
<img
src="https://wang-nine.cn/images/%E6%9D%82%E9%A1%B904-02%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0.png"
alt="杂项04-02文件上传" />
<figcaption aria-hidden="true">杂项04-02文件上传</figcaption>
</figure>
<h2 id="方法1将文件保存到本地">方法1：将文件保存到本地</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*@PostMapping(&quot;/upload&quot;)</span></span><br><span class="line"><span class="comment">public Result upload(String username, Integer age, MultipartFile image) throws Exception &#123;</span></span><br><span class="line"><span class="comment">    log.info(&quot;文件上传：&#123;&#125;，&#123;&#125;，&#123;&#125;&quot;, username, age, image);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    //获取原始文件名</span></span><br><span class="line"><span class="comment">    String originalFilename = image.getOriginalFilename();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    //构造唯一的文件名（不能重复）-- uuid（通用唯一识别码）</span></span><br><span class="line"><span class="comment">    int index = originalFilename.lastIndexOf(&#x27;.&#x27;);</span></span><br><span class="line"><span class="comment">    String extname = originalFilename.substring(index);</span></span><br><span class="line"><span class="comment">    String newFileName = UUID.randomUUID().toString() + extname;</span></span><br><span class="line"><span class="comment">    log.info(&quot;新的文件名：&#123;&#125;&quot;, newFileName);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    //将接收到的文件存储在服务器的磁盘目录中 D:\image</span></span><br><span class="line"><span class="comment">    image.transferTo(new File(&quot;D:\\image\\&quot; + newFileName));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    return Result.success();</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br></pre></td></tr></table></figure>
<h2 id="方法2将文件保存到alioss">方法2：将文件保存到AliOSS</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/upload&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">upload</span><span class="params">(MultipartFile image)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    log.info(<span class="string">&quot;文件上传，文件名：&#123;&#125;&quot;</span>, image.getOriginalFilename());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用阿里云OSS工具类</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> aliOSSUtils.upload(image);</span><br><span class="line">    log.info(<span class="string">&quot;文件上传完成，文件访问的url为：&#123;&#125;&quot;</span>, url);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.success(url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>==修改员工需要查询回显和update语句==</p>
<p>==配置注入使用@Value(“#{配置中的key}”)注解来防止硬编码==</p>
<h1 id="登陆校验难点">登陆校验（难点）</h1>
<p>==若按照普通的开发区编写映射页面，通过数据库判别是否用户名与密码正确式不可取的==</p>
<p>如此的话，直接访问类似于 /emps /depts
等页面可以直接进入控制台面板而跳过了判断是否为管理员的步骤</p>
<p>因此，我们需要在 /login /depts /emps 之间建立一种联系</p>
<p>实现思路：</p>
<ul>
<li>员工登陆成功存储一个标记</li>
<li>在每一个方法接口前判断员工是否登陆，登陆则访问，未登录则返回给前端错误信息</li>
<li>因此，需要两种技术==1.统一拦截== ==2.登陆标记缓存==
<ul>
<li>统一拦截
<ul>
<li>Servlet提供的过滤器Filter</li>
<li>Spring提供的拦截器Interceptor</li>
</ul></li>
<li>用户登陆
<ul>
<li>会话技术</li>
</ul></li>
</ul></li>
</ul>
<h2 id="会话技术">会话技术</h2>
<ul>
<li><p>会话：指的是用户打开浏览器，访问web服务器的资源，会话建立，直到有一方断开连接，会话结束。在一次会话中可以包含<strong>多次</strong>请求和响应。</p></li>
<li><p>会话跟踪：一种维护浏览器状态的方法，服务器需要识别多次请求是否来自于同一浏览器，以便在同一次会话的多次请求间<strong>共享数据</strong>。</p></li>
</ul>
<p>​ http协议是无状态协议，不会携带上一次会话的信息，因此无法数据共享</p>
<ul>
<li>会话跟踪方案
<ul>
<li>客户端会话跟踪技术：Cookie（存储在浏览器）</li>
<li>服务端会话跟踪技术：Session（存储在服务器端）</li>
<li>令牌技术</li>
</ul></li>
</ul>
<blockquote>
<ul>
<li>Cookie：浏览器第一次请求时在服务器端设置Cookie，响应时携带Cookie，而后Cookie缓存在浏览器本地，之后的每次请求都会携带Cookie与客户端进行对比，服务器自动响应Cookie，浏览器自动保存Cookie，发起请求自动携带Cookie，三个自动表名Http支持Cookie技术
<ul>
<li>请求头Cookie</li>
<li>响应头Set-Cookie</li>
</ul></li>
</ul>
<blockquote>
<p>优点：HTTP协议支持</p>
<p>缺点：1.移动端无法使用 2.不安全，用户可以自己禁用
3.Cookie不能跨域（跨域：协议、IP/域名、端口不同）</p>
</blockquote>
<ul>
<li>Session：浏览器第一次请求时在服务器端设置Session（ID），响应时通过Cookie返回Session的ID，之后的每次请求都会携带Cookie中的Session的ID到服务器端对比</li>
</ul>
<blockquote>
<p>优点：存储在服务器端，安全</p>
<p>缺点：1.服务器集群在负载均衡后有可能无法使用，因此无法在服务器集群环境下使用
2.Cookie的缺点</p>
</blockquote>
<ul>
<li>令牌技术（==建议使用==）：用户身份表示，登陆成功生成令牌，响应给浏览器，可以存储在Cookie或者其他存储空间中，之后的每次请求都会携带令牌，比对是否有效，而且想要共享数据只需要将数据保存在令牌中即可</li>
</ul>
<blockquote>
<p>优点：1.支持PC、移动端 2、解决集群环境下的认证问题
3、减轻了服务器端的存储压力</p>
<p>缺点：需要自己去实现</p>
</blockquote>
</blockquote>
<h2 id="jwtjson-web-token令牌">JWT（JSON Web Token）令牌</h2>
<p>定义了一种简洁的、自包含的格式，用于在通信双方以json数据格式安全的传输信息。由于数字签名的存在，这些信息是可靠的。</p>
<p>jwt令牌组成</p>
<ul>
<li>第一部分:Header(头)，记录令牌类型、签名算法等。例如: {"alg":"HS256"
,"type":"JWT"}</li>
<li>第二部分:Payload(有效载荷)，携带一些自定义信息、默认信息等。例如:
{"id":" 1" ,"username":"Tom"}</li>
<li>第三部分:Signature(签名)，防止Token被篡改、确保安全性。将header、
payload，并加入指定秘钥，通过指定签名算法计算而来。</li>
</ul>
<p>pom.xml引入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--JTW令牌--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>jwt生成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">signKey</span> <span class="operator">=</span> <span class="string">&quot;wangnine&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Long</span> <span class="variable">expire</span> <span class="operator">=</span> <span class="number">43200000L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成JWT令牌</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> claims JWT第二部分负载 payload 中存储的内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">generateJwt</span><span class="params">(Map&lt;String, Object&gt; claims)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">jwt</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line">                .addClaims(claims)</span><br><span class="line">                .signWith(SignatureAlgorithm.HS256, signKey)</span><br><span class="line">                .setExpiration(<span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis() + expire))</span><br><span class="line">                .compact();</span><br><span class="line">        <span class="keyword">return</span> jwt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析JWT令牌</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jwt JWT令牌</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> JWT第二部分负载 payload 中存储的内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Claims <span class="title function_">parseJWT</span><span class="params">(String jwt)</span>&#123;</span><br><span class="line">        <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> Jwts.parser()</span><br><span class="line">                .setSigningKey(signKey)</span><br><span class="line">                .parseClaimsJws(jwt)</span><br><span class="line">                .getBody();</span><br><span class="line">        <span class="keyword">return</span> claims;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="统一拦截技术">统一拦截技术</h2>
<h3 id="filter过滤器">Filter过滤器</h3>
<p>JavaWeb三大组件(Servlet、Filter、Listener)之一。</p>
<ul>
<li>过滤器可以把对资源的请求拦截下来，从而实现一些特殊的功能。</li>
<li>过滤器一般完成一些通用的操作，比如:登录校验、统一编码处理、敏感字符处理等。</li>
</ul>
<p>相当于抽取了各个页面的登陆校验，优点aop的思想</p>
<p>==如何实现过滤器==</p>
<ul>
<li>1.定义Filter:定义一个类，实现 Filter接口，并重写其所有方法。</li>
<li>配置Filter:
Filter类上加@WebFilter注解，配置拦截资源的路径。引导类上加@ServletComponentScan开启Servlet组件支持。</li>
</ul>
<p>结合了jwt后的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="comment">//@WebFilter(urlPatterns = &quot;/*&quot;)  //拦截所有</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginCheckFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">req</span> <span class="operator">=</span> (HttpServletRequest) servletRequest;</span><br><span class="line">        <span class="type">HttpServletResponse</span> <span class="variable">resp</span> <span class="operator">=</span> (HttpServletResponse) servletResponse;</span><br><span class="line">        <span class="comment">//1.获取请求url</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> req.getRequestURL().toString();</span><br><span class="line">        log.info(<span class="string">&quot;请求的url：&#123;&#125;&quot;</span>, url);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.判断请求的url中是否包含login，如果包含，说明是登录操作，直接放行</span></span><br><span class="line">        <span class="keyword">if</span>(url.contains(<span class="string">&quot;login&quot;</span>)) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;登录操作，放行...&quot;</span>);</span><br><span class="line">            filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.获取请求头中的token令牌</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jwt</span> <span class="operator">=</span> req.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.判断令牌是否存在，如果不存在，则返回错误结果（未登录）</span></span><br><span class="line">        <span class="keyword">if</span>(!StringUtils.hasLength(jwt)) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;请求头token为空，返回未登录的信息&quot;</span>);</span><br><span class="line">            <span class="type">Result</span> <span class="variable">error</span> <span class="operator">=</span> Result.error(<span class="string">&quot;NOT_LOGIN&quot;</span>);</span><br><span class="line">            <span class="comment">//手动将对象转换为json格式</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">notLogin</span> <span class="operator">=</span> JSONObject.toJSONString(error);</span><br><span class="line">            resp.getWriter().write(notLogin);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.解析token，如果解析失败，则返回错误结果（未登录）</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            JwtUtils.parseJWT(jwt);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;解析令牌失败，返回未登录的误信息&quot;</span>);</span><br><span class="line">            <span class="type">Result</span> <span class="variable">error</span> <span class="operator">=</span> Result.error(<span class="string">&quot;NOT_LOGIN&quot;</span>);</span><br><span class="line">            <span class="comment">//手动将对象转换为json格式</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">notLogin</span> <span class="operator">=</span> JSONObject.toJSONString(error);</span><br><span class="line">            resp.getWriter().write(notLogin);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.放行</span></span><br><span class="line">        log.info(<span class="string">&quot;令牌合法，放行&quot;</span>);</span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于init 和 destroy 有默认实现，二者只调用一次</span></span><br></pre></td></tr></table></figure>
<h2 id="interceptor拦截器">Interceptor拦截器</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginCheckInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>   <span class="comment">//目标资源方法运行前运行，返回true放行，返回false不放行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest req, HttpServletResponse resp, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.获取请求url</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> req.getRequestURL().toString();</span><br><span class="line">        log.info(<span class="string">&quot;请求的url：&#123;&#125;&quot;</span>, url);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.判断请求的url中是否包含login，如果包含，说明是登录操作，直接放行</span></span><br><span class="line">        <span class="keyword">if</span>(url.contains(<span class="string">&quot;login&quot;</span>)) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;登录操作，放行...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.获取请求头中的token令牌</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jwt</span> <span class="operator">=</span> req.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.判断令牌是否存在，如果不存在，则返回错误结果（未登录）</span></span><br><span class="line">        <span class="keyword">if</span>(!StringUtils.hasLength(jwt)) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;请求头token为空，返回未登录的信息&quot;</span>);</span><br><span class="line">            <span class="type">Result</span> <span class="variable">error</span> <span class="operator">=</span> Result.error(<span class="string">&quot;NOT_LOGIN&quot;</span>);</span><br><span class="line">            <span class="comment">//手动将对象转换为json格式</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">notLogin</span> <span class="operator">=</span> JSONObject.toJSONString(error);</span><br><span class="line">            resp.getWriter().write(notLogin);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.解析token，如果解析失败，则返回错误结果（未登录）</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            JwtUtils.parseJWT(jwt);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;解析令牌失败，返回未登录的误信息&quot;</span>);</span><br><span class="line">            <span class="type">Result</span> <span class="variable">error</span> <span class="operator">=</span> Result.error(<span class="string">&quot;NOT_LOGIN&quot;</span>);</span><br><span class="line">            <span class="comment">//手动将对象转换为json格式</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">notLogin</span> <span class="operator">=</span> JSONObject.toJSONString(error);</span><br><span class="line">            resp.getWriter().write(notLogin);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.放行</span></span><br><span class="line">        log.info(<span class="string">&quot;令牌合法，放行&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>   <span class="comment">//目标资源方法运行后运行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;postHandle...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>   <span class="comment">//视图渲染完毕后运行，最后运行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterCompletion...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="异常处理">异常处理</h1>
<p>在Controller层定义一个全局异常处理器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestControllerAdvice;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 全局异常处理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span>      <span class="comment">//捕获所有的异常</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">ex</span><span class="params">(Exception ex)</span> &#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> Result.error(<span class="string">&quot;对不起，操作失败，请联系管理员&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><span class="citation"
data-cites="RestControllerAdvice">@RestControllerAdvice</span></p>
<p><span class="citation"
data-cites="ExceptionHandler">@ExceptionHandler</span>(Exception.class)
//捕获所有的异常</p>
</blockquote>
]]></content>
      <categories>
        <category>项目重构</category>
      </categories>
      <tags>
        <tag>重构</tag>
      </tags>
  </entry>
  <entry>
    <title>分类</title>
    <url>/categories/index.html</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/index.html</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title>关于</title>
    <url>/about/index.html</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title>相册</title>
    <url>/gallery/index.html</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title>标签</title>
    <url>/tags/index.html</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title>资源</title>
    <url>/resources/index.html</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title>峨眉山之行</title>
    <url>/gallery/%E8%83%8C%E6%99%AF/index.html</url>
    <content><![CDATA[
]]></content>
  </entry>
</search>
